
var tipuesearch = {'pages': [{'title':'Mutable specification syntax', 'text':'The  page presents one syntax for declaring examples in a mutable specification:class MySpecification extends org.specs2.mutable.Specification:  "this is my specification" >> {    "where example 1 must be true" >> {      1 must ===(1)    }    "where example 2 must be true" >> {      2 must ===(2)    }  }You can also use the `should/in` syntax:class MySpecification extends org.specs2.mutable.Specification:  "this is my specification" should {    "have one example" in {      1 must ===(1)    }    "and another one" in {      2 must ===(2)    }  }<img src="images/icon_failure_sml.gif"/> You might get clashes with should which can also be used to declare expectations on strings:class MySpecification extends org.specs2.mutable.Specification:  "this" should {    "will not compile because should is overloaded" in  {      "a string" should not(beEmpty)    }  }The easiest work around in that case is to use must for the expectation:class MySpecification extends org.specs2.mutable.Specification:  "this" should {    "compile now" in {      "a string" must not(beEmpty)    }  }', 'tags':'', 'loc':'org.specs2.guide.MutableSpecSyntax.html'},
{'title':'Console output', 'text':'You will get a "console" output whenever you run a specification from  or a .There are arguments you can use to change the output:  Name               | Value format            | Comments ------------------- | ----------------------- | ------------------------------------------------------------------------ `xonly`             | boolean                 | only report failures and errors `showonly`          | String                  | only report some examples based on their status `failtrace`         | boolean                 | show a stack trace for failures `fullstacktrace`    | boolean                 | show a full stack trace `tracefilter`       | regexp-csv/regexp-csv   | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`        | see below               | define the parameters for the `SmartDiffs` instance for differences `diffsclass`        | class name              | use a specific instance of the `Diffs` trait `color`             | boolean                 | use colors `nocolor`           | boolean                 | dont use colors `colors`            | map                     | use different colors `colorsclass`       | class name              | use a specific instance of the `Colors` trait `showtimes`         | boolean                 | show execution times for examples `all`               | boolean                 | execute and report linked specifications (default = `false`) `indentation`       | int                     | number of spaces to use to indent nested examples in unit specifications (default = 2)Some of these arguments deserve further explanations. Show onlyYou can decide what you want to _show_ in the console by using the `showonly` arguments and the following flags:  Flag | Description ----- | ------------  `+`  | successful example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `#`  | title  `1`  | statisticsFor example if you just want to show text and failures you can use `showonly -x`. And the `xonly` argument is actually a shortcut for `showonly #x!`. StackTraceFilterThe `tracefilter` argument uses include/exclude patterns to define an instance of the `org.specs2.control.StackTraceFilter` trait which will filter stacktraces. By default the `DefaultStackTraceFilter` filter will exclude lines matching the following packages: * `org.specs2` * `scala\\.`, `java\\.` * `sbt\\.`, `com.intellij`, `org.eclipse.jdt`, `org.junit`If this is not what you want, you can either use the `tracefilter` argument with other patterns. For example `tracefilter com.acme\com.acme.impl` will only keep traces of classes in the `com.acme` package but will reject the ones in `com.acme.impl`.Note also that the default filter also truncates the stacktrace in the middle if it is bigger than 1000 lines to avoid reports being filled by out-of-control stacktraces. If you still want to see those lines you can re-run with the `fullstacktrace` argument. DiffsWhen using the equality matcher specs2 tries to display the difference between the expected and the actual values using a class: `org.specs2.main.SmartDiffs`. There are several parameters for that class which you can specify from the command line as:sbt> testOnly -- smartdiffs show,separators,triggerSize,shortenSize,diffRatio,full,seqTriggerSize,seqMaxSize// for examplesbt> testOnly -- smartdiffs true,[],20,5,30,false,0,1000000 Parameter          | Description -----------        | ---------------------------------------------------- `show`             | will not show anything (default = true) `separators`       | allows to change the separators used to show the differences (default = "[]") `triggerSize`      | controls the size above which the differences must be shown (default = 20) `shortenSize`      | controls the number of characters to display around each difference (default = 5) `diffRatio`        | percentage of differences above which the differences must not be shown (default = 30) `full`             | displays the full original expected and actual strings (default = false) `seqTriggerSize`   | the minimum size to compute differences on Seq, Set and Maps (default = 0) `seqMaxSize`       | the maximum size to compute differences on Seq, Set and Maps (default = 1000000)You can also specify your own enhanced algorithm for displaying the difference by providing an instance of the `org.specs2.main.Diffs` trait:trait Diffs {  /** @return true if the differences must be shown */  def show: Boolean  /** @return true if the differences must be shown for 2 different values */  def show(actual: Any, expected: Any): Boolean  /** @return true if the differences must be shown for 2 different sequences of values */  def showSeq(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): Boolean  /** @return true if the differences must be shown for 2 different maps */  def showMap(actual: Map[Any, Any], expected: Map[Any, Any]): Boolean  /** @return the diffs */  def showDiffs(actual: Any, expected: Any): (String, String)  /** @return the diffs for sequences with missing / added values  */  def showSeqDiffs(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): (Seq[String], Seq[String])  /** @return the diffs for sequences with missing / added values  */  def showMapDiffs(actual: Map[Any, Any], expected: Map[Any, Any]): (Seq[String], Seq[String], Seq[String])  /** @return true if the full strings must also be shown */  def showFull: Boolean}Here is an example:sbt> testOnly -- diffsclass org.acme.MyDiffClass ColorsBy default, the reporting will output colors. If youre running on windows you might either: * use the [following tip](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) to install colors in the DOS console * or pass `nocolor` as a command line argumentIt is possible to set colors by passing the `colors` argument. This argument must be a list of `key:value` pairs (comma-separated) where keys are taken from this table:Property  | Default value |--------- | ------------- |`text`    |  white        |`success` |  green        |`failure` |  yellow       |`error`   |  red          |`pending` |  cyan         |`skipped` |  magenta      |`stats`   |  cyan         |All the available colors are listed here, with their corresponding abbreviation which you can use to refer to them as well: Color   | Abbreviation | ------  | ------------ | white   | w            | green   | g            | yellow  | y            | red     | r            | blue    | be           | cyan    | c            | black   | bk           | magenta | m            |For example you can pass on the command line: `colors text:blue,failure:magenta`to have the text colored in blue and the failures in Magenta.If the `colors` option contains `whitebg` then the default colors are considered to be [`InvertedColors`](https://etorreborre.github.io/specs2/api/SPECS2-5.6.2/index.html#org.specs2.text.Colors):Property  | Default value |--------- | ------------  |`text`    |  black        |`success` |  green        |`failure` |  magenta      |`error`   |  red          |`pending` |  blue         |`skipped` |  cyan         |`stats`   |  blue         |You can also change the color scheme thats being used on the console by implementing your own [`org.specs2.text.Colors`](https://etorreborre.github.io/specs2/api/SPECS2-5.6.2/index.html#org.specs2.text.Colors) trait or override values in the existing `ConsoleColors` class and pass this class to the `colorsclass` argument. For example if you want to output magenta everywhere yellow is used you can write:class MyColors extends org.specs2.text.ConsoleColors {  override val failureColor = magenta}and invoke `colorsclass org.acme.MyColors`Finally note that the the color support for sbt on Windows is a bit tricky. You need to follow the instructions [here](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) then add to your script launching sbt:-Djline.terminal=jline.UnsupportedTerminal', 'tags':'', 'loc':'org.specs2.guide.ConsoleOutput.html'},
{'title':'JUnit XML output', 'text':'Many continuous integration servers (like [Jenkins](http://jenkins-ci.org)) accept JUnit XML as their de facto standard for reporting test results.You can output a JUnit XML file by simply using the `junitxml` argument: `testOnly org.acme.MySpec -- junitxml`The JUnit XML file corresponding to the specification will be produced by default in the `target/test-reports` directory. You can change this directory by passing the `junit.outdir` argument like so: `testOnly org.acme.MySpec -- junitxml junit.outdir custom_xml_folder`This will output the xml files in the `custom_xml_folder` in the top level project directory. that using `junitxml` by itself will turn off the console reporting. You need to add `console` to get it back. Output directory with `sbt test``sbt test` does not take parameters so the default behavior is to produce the JUnit XML files for all specifications in the default output directory.In order to change the default output directory of the junit xml files when running the tests with `test`, add the following to your sbt build file: `Test / testOptions += Tests.Argument("junitxml", "junit.outdir", "custom_xml_folder")`This will suppress the console output, which may be what you want if this is a configuration for a build machine. To re-enable console output, use instead:  Test / testOptions ++= Seq(    Tests.Argument("junitxml", "junit.outdir", "custom_xml_folder"),    Tests.Argument("console") ) ', 'tags':'', 'loc':'org.specs2.guide.JUnitXmlOutput.html'},
{'title':'Html output', 'text':'specs2 can be used to produce HTML documentation to either: - report the execution of specifications - provide a user guide like this oneIf Markdown notation is used in the specification text and you have [Pandoc](http://johnmacfarlane.net/pandoc) installed on the command linethen it will rendered in the final output. Create Html filesWhen you execute a specification with the `html` command-line argument an HTML report is created in the `target/specs2-reports` directory.It will show the status of examples (success, failure,...) and stack traces if there are any errors.You can use the following arguments to change the HTML generation: Name                         | Default value                                 | Description ---------------------------- | --------------------------------------------- | ------------------------------ `all`                        | `false`                                       | execute and report linked specifications `html.outdir`                | `target/specs2-reports`                       | output directory `html.template`              | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`             | `Map[String, String]()`                       | those variables will be replaced during template evaluation `html.nostats`               | `false`                                       | if true no stats are displayed `html.search`                | `false`                                       | add a search box to the generated files `html.toc`                   | `false`                                       | add a table of contents to the generated files `html.toc.entrymaxsize`      | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs`      | `true`                                        | report "see" references which do not correspond to any generated file Use Pandoc for Markdown[Markdown](http://commonmark.org) text is supported if [Pandoc](http://johnmacfarlane.net/pandoc) is available on the command line andif the `!pandoc` boolean flag is not set. Name                    | Default value                                                                     | Description ----------------------- | --------------------------------------------------------------------------------- | ------------------------------ `pandoc`                | `true`                                                                            | set to `false` by passing `!pandoc` `pandoc.exec`           | `pandoc`                                                                          | path to the Pandoc executable `pandoc.inputformat`    | `markdown+pipe_tables+auto_identifiers+header_attributes+inline_code_attributes`  | pandoc arguments (see the Pandoc [user guide](http://johnmacfarlane.net/pandoc/README.html)) `pandoc.outputformat`   | `html`                                                                            | Use a different templateYou can change the overall structure of the html page for a specification by providing a different template with the `html.template` variable.When using your custom template the following variables will be replaced: Name                    | Description ----------------------- | ------------------------------ `$title$`             | specification title `$issues$`            | true if there are issues in the specification `$body$`              | the specification bodyYou can also pass your own variables by passing a map `name1=value1,name2=value2,...` to the `html.variables` argument.Those variables can then be used in the template: - by enclosing them in `$`: `$myVariable$` - by using the `if/else/endif` construct:$if(issues)$<h1>Failed! $title$$else$<h1>$title$</h1>$endif$ Use other CSS/Javascript filesCustom CSS and JavaScript files can be used without changing the template. In order to do this just put your own `specs2-user.css` file in `src/test/resources/css` or your own `specs2-user.js` file in `src/test/resources/javascript`. Create an indexHere is something you can do to automatically create an index page for your specifications: import org.specs2.*import org.specs2.runner.*import specification.core.*class index(env: Env) extends Specification:  def is =    examplesLinks("Example specifications")  // see the SpecificationsFinder trait for the parameters of the specifications method  def examplesLinks(t: String) = {    val finder = SpecificationsFinder.create(env)    t.title       Fragments.foreach(finder.specifications())(s => link(s)  br)  }The specification above creates an index.html file in the `target/specs2-reports` directory. The specifications method creates specifications using the following parameters: Name                    | Default                                       | Description ------                  | -------                                       | --------------------- `glob`                  | `**/*.scala`                                  | glob pattern to filter specification files `pattern`               | `.*Spec`                                      | pattern to use when trying to retrieve the specification names from the source files `filter`                | `(name: String) => true`                      | function to keep only some specifications depending on their name `basePath`              | `src/test/scala`                              | the path where to start the search `verbose`               | `false`                                       | boolean indicating if information about finding files and specifications must be printed `classLoader`           | `Thread.currentThread.getContextClassLoader`  | classloader used to load the specification classes `filePathReader`        | `org.specs2.io.FileSystem`                    | object used to read source files', 'tags':'', 'loc':'org.specs2.guide.HtmlOutput.html'},
{'title':'Markdown output', 'text':' Markdown printerThere is a simple printer for creating Markdown files based on your specifications. You simply invoke it by passing the `markdown` argument on the command line. ArgumentsThe following arguments are available to fine-tune the generation of Markdown pages Name                     | Default                         | Description ------------------------ | ------------------------------- | ----------- `markdown.outdir`        | `target/specs2-reports`         | output directory for Markdown files `markdown.ext`           | `md`                            | extension for Markdown files', 'tags':'', 'loc':'org.specs2.guide.MarkdownOutput.html'},
{'title':'Custom output', 'text':'You can implement your own reporting of specs2 specifications: - using the `Notifier` trait which acts like a listener - using a `Printer` which gives you more flexibility for reporting exactly what you want - using a `Reporter` which allow you to even change the default flow for reporting specifications: selection -> execution -> printing NotifierThe `org.specs2.reporter.Notifier` trait can be used to report execution events. It notifies of the following: Event                | Description -------------------- | ----------- specification start  | the beginning of a specification, with its name specification end    | the end of a specification, with its name context start        | the beginning of a sub-level when the specification is seen as a tree or Fragments context end          | the end of a sub-level when the specification is seen as a tree or Fragments text                 | any Text fragment that needs to be displayed example start        | the beginning of an example example result       | `success / failure / error / skipped / pending`All those notifications come with a location (to trace back to the originating fragment in the Specification) and a duration when relevant (i.e. for examples).You can then using the `notifier` argument to pass the name of your custom notifier:sbt> testOnly *BinarySpec* -- notifier org.acme.reporting.FtpNotifier PrinterThe `org.specs2.reporter.Printer` trait defines how to output each fragment of the specification. The only method to implement is:def fold(env: Env, spec: SpecStructure): Fold[Fragment]So what you need to create is a `Fold` over the executing specification. What is it? A `Fold` is composed of 3 operations:trait Fold[M[_], A, B]:  type S  def start: M[S]  def fold: (S, A) => S  def end(s: S): M[B] * `start` is an initial state of type `S`. By using some state you can accumulate information about the execution of the whole specification * `fold` is the function calculating the next state based on the current `Fragment` and the previous state * `end` take the last state and returns a computation doing the last action like reporting the final statisticsOnce youve defined your `Printer` trait you can use the `printer` argument like so:sbt> testOnly *BinarySpec* -- printer org.acme.reporting.LatexPrinter ReporterThe `org.specs2.reporter.Reporter` trait defines the full lifecycle for running specifications:// prepare the environment before any reportingdef prepare(env: Env, printers: List[Printer]): List[SpecStructure] => Action[Unit]// finalize the reporting (to save overall statistics for example)def finalize(env: Env, printers: List[Printer]): List[SpecStructure] => Action[Unit]/** * report a spec structure with the given printers * * The default implementation selects fragments to execute, executes them and uses the printers to * display results */def report(env: Env, printers: List[Printer]): SpecStructure => Action[Unit] TroubleshootingIf your custom `Notifier` or `Printer` fails to be instantiated you can re-run the execution with the `verbose` argument in order to get an error message and a stack trace.', 'tags':'', 'loc':'org.specs2.guide.CustomOutput.html'},
{'title':'Selection', 'text':'Many specifications are written incrementally. You specify a little bit then you implement the application. When you gothrough this "Specify-Implement-Execute" cycle it is useful to be able to focus on just one example, the one you arecurrently working on. The `ex` argument is what you need (`ex` stands for "example"):sbt> testOnly *MySpecification* -- ex containsThe command above will execute any example which description matches the regular expression `.*contains.*` (which meansthat you can pass regular expressions in general). If you want to match a few words you will need to use double quotes:sbt> testOnly *MySpecification* -- ex "contains hello" sequential Use tagsTags can be used in a Specification to include or exclude some examples or a complete section of fragments from theexecution. Lets have a look at one example: class TaggedSpecification extends Specification:  def is = s2"""  this is some introductory text    and the first group of examples    example 1 $success ${tag("feature1", "unit")}    example 2 $success ${tag("integration")}    and the second group of examples ${section("checkin")}    example 3 $success    example 4 $success ${section("checkin")}  """In that specification we are defining several tags and sections:* `feature 1` is a tag that is applied to `example1` (the _preceding_ Fragment)* `feature 2` is a tag that is applied to `example2` (the _preceding_ Fragment)* `checkin` marks a section which goes from the Text `and the second group of examples` to `example 4`Armed with this, it is now easy to include or exclude portions of the specification at execution time:* `include feature1` will only include `example 1`* `exclude integration` will include everything except `example 2`* `include checkin,unit` will include anything having either `checkin` OR `unit`: i.e. `example 1` and the second group of examples (`example 3` and `example 4`)* `include feature1 && unit` will include anything having `feature1` AND `unit`: i.e. `example 1`* `include feature1 && unit, checkin` will include anything having `feature1` AND `unit`, OR having `checkin`: i.e. `example 1`, `example 3`, `example4` In a unit specificationA _unit_ specification will accept the same `tag` and `section` methods but the behavior will be slightly different: import org.specs2.mutable.*class TaggedSpecification extends Specification:  "this is some introductory text" >> {    "and the first group of examples" >> {      tag("feature 1", "unit")      "example 1" in success      "example 2" in success    }  }  section("checkin")  "and the second group of examples" >> {    "example 3" in success    "example 4" in success  }  section("checkin")  "and the last group of examples" >> {    "example 5" in success tag "integration"    "example 6" in success  } section "slow"For that specification above, tags can be applied to fragments following them: * when the `tag` call is inserted on a new line, the tagged fragment is the one just _after_ the tag method call: `example 1` is tagged with `feature1 and unit`, * when the `section` call is inserted on a new line, this opens a section for all the following fragments. This should be closed by a corresponding `section` call on a new line. For example, `example 3` and `example 4` are part of the "checkin" sectionBut they can also be applied to fragments preceding them: * when the `tag` is appended to an example, it applies to that example: `example 5` is tagged with `integration` * when the `section` call is appended to a block of Fragments on the same line, all the fragments of that block are part of the section: `example 5` and `example 6` are tagged with `slow` Automatic sectionsIf you call `addSections` from inside the specification, each "block" will be surrounded by section tags having the samename as the block text:import org.specs2.mutable.*class SectionsSpecification extends Specification:  addSections()  "first section" >> {    "example 1" in success    "example 2" in success  }  "second section" >> {    "example 3" in success    "example 4" in success  }  "third section" >> {    "example 5" in success    "example 6" in success  }If you want you can execute only example 3 and 4 by running `sbt> testOnly *SectionsSpecification -- include "second section"`. `Always` tagSome specifications need to have `Steps` which will always be included whatever tags are specified on the command line.This is the case when defining a  with setup/teardown steps: trait DatabaseSpec extends Specification:  override def map(fs: =>Fragments) =    step(success("startDb"))  tag(AlwaysTag)       fs       step(success("cleanDb"))  tag(AlwaysTag) Select failed examplesAnother frequent mode of selection is the selection based on previous execution.Generally we want to re-execute only what was broken before. For this, using the `was` argument on the command-line:sbt> testOnly *MyFailedSpecification* -- was xOn the line above `x` is the status of the previous example. Here is a table of all the flags you can use:  Flag | Description ----- | ------------  `+`  | successful example  `x`  | failed example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `1`  | statisticsThis selection works because specs2 stores the state of each specification in a directory after a run (`target/specs2-reports/stats` by default). If you decide that this storing is useless and you want to skip it you can use the `neverstore` argument. Otherwise if you want to make sure that the `stats` directory doesnt become too big over time you can use the `resetstore` argument which will remove the current store before running the specification.<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - learn how to  - consult the  for a list of all arguments</div>', 'tags':'', 'loc':'org.specs2.guide.Selection.html'},
{'title':'Execution', 'text':' Parallel by defaultspecs2 examples are executed concurrently by default: - this makes the execution faster - it encourages to write independent examples when the result of a given example should not be influenced by othersStarting from this default you can progressively add constraints to get more control over the execution. StepsA `Step` is an action which can be executed anywhere in a specification. When you declare a `Step` like this:class StepSpec extends Specification:  def is = s2"""  this is example 1 $ok  this is example 2 $ok  ${step(success("stop here for a second"))}  this is example 3 $ok  this is example 4 $ok  """Then the specification will:  1. execute examples 1 and 2 in parallel  2. execute the step  3. execute examples 3 and 4 in parallelThere is no "result" for a step but if it throws an Exception an `Error` will be reported. This will not however stop the execution of the rest of the specification. Stop the executionYou can still control if the rest of the specification must be executed by adding some constraints on the step. For example:class StepWithStopOnErrorSpec extends Specification:  def is = s2"""  this is example 1 $ok  this is example 2 $ok  ${step { sys.error("sorry!"); ko("stop here for a second") }.stopOnError}  this is example 3 $ok  this is example 4 $ok  """When this specification is executed examples 3 and 4 will be skipped because the step returns an `Error`. An `Error` is likely to be a fatal condition but you can use other methods to stop the execution: - `stopOnFail` stop if there is a failure in the previous examples or in the step - `stopOnSkipped` stop if there is a skipped result in the previous examples or in the step - `stopWhen(Result => Boolean)` stop if the and-ed result of the previous examples and the step verifies a given condition SequentialIf your specification is a list of well-ordered examples you can use the `sequential` argument to make sure that they are executed in order:class SequentialSpec extends Specification:  def is = sequential  s2"""  this is example 1 $ok  this is example 2 $ok  this is example 3 $ok  this is example 4 $ok  """Thanks to the `sequential` argument the 4 examples above will execute one after the other. ActionFinally if you want to execute "silent" actions, like steps, but with no impact on the sequencing of the specification, you can use an `Action`:class ActionSpec extends Specification:  def is = s2"""  this is example 1 $ok  this is example 2 $ok  // this will only be reported if there is a failure  ${action(ok("do something here"))}  this is example 3 $ok  this is example 4 $ok  """<h3 id="Now learn how to..." class="ribbon both-ribbon">Now learn how to...</h3><div class="ribbon-content">     - use  to select the examples to execute</div><h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - add  to your specification - consult the  for a list of all arguments</div>', 'tags':'', 'loc':'org.specs2.guide.Execution.html'},
{'title':'Run in IDE', 'text':' Intellij IDEA[IntelliJ IDEA](https://github.com/jetbrains/intellij-scala) is the IDE with the best specs2 integration for now. You can: * execute a specification by selecting its name and pressing `CTRL+SHIFT+F10` * execute a single example by selecting its description and pressing `CTRL+SHIFT+F10` ![specs2 in Intellij](https://etorreborre.github.io/specs2/guide/SPECS2-5.6.2/images/intellij.png)However passing arguments needs to be done through system properties for now. So if you need to use the `xonly` argument you need to pass `-Dspecs2.xonly`. VSCodespecs2 is integrated to the [`metals` language server](https://scalameta.org/metals), which means that any compiling specification in VSCode should beadorned with a small `test` button to run it.', 'tags':'', 'loc':'org.specs2.guide.RunInIDE.html'},
{'title':'Run in shell', 'text':'It is not necessary to use a build tool to run a specification. You just need to have the right dependencies on the classpath and use one of the specs2 runners. DependenciesWhen you use a build tool you generally only need to specify the main dependencies then any transitive dependency will be fetched for you.However, when you run specifications from the shell you need to specify the classpath yourself. The best way to do this is to use `sbt` tomake sure your specification compiles with all the required dependencies, then export the project classpath:sbt> export Runtime / fullClasspathsbt> export Test / fullClasspathWith the output of both commands you can define an environment variable, `$SPECS2_PATH`sh> export $SPECS2_PATH=<runtime classpath>:<test classpath> From the shell Run one specificationThe `specs2.run` object can be used to run a specification from the shell. The first argument is expected to be the class namesh> java -cp $SPECS2_PATH specs2.run org.acme.MySpec xonlyAnd the other arguments are used to drive the execution of the specification as described in the  section. Run several specificationsThe `specs2.files` object will select and execute all specifications found in the test source directory according to the following parameters:Name                    | Default value              | Description-----------             | ---------------            | -------------------------`filesrunner.basepath`  | `src/test/scala`  | source directory for test files`filesrunner.path`      | `**/*.scala`      | glob pattern for the file paths`filesrunner.pattern`   | `(.*Spec)\s*extends\s*.*`   | regular expression capturing the specification class/object name`filesrunner.verbose`   | `false`                    | logs of searched paths and potential classes to instantiateSpecification arguments can be passed after those parameterssh> java -cp $SPECS2_PATH specs2.files filesrunner.basepath examples xonly**Tip!** use the `filesrunner.verbose` argument to make sure that you are looking for specifications in the right place**Tip!** dont forget to quote the `filesrunner.path` argument, since this is a glob and your shell might expand it too soonsh> java -cp $SPECS2_PATH specs2.files filesrunner.path **/examples/*Spec.scala OutputsBy default the `specs2.run` and `specs2.files` runners will output their results to the console but you can also use other printers as described in the  section. From the scala consoleThe `specs2.run` object also has an `apply` method to execute specifications from the Scala consolescala> specs2.run(spec1, spec2)If you want to pass specific arguments you can import the `specs2.arguments` object member functionsscala> import specs2.arguments.*scala> specs2.run(spec1)(nocolor)Or you can set implicit arguments which will be used for any specification executionscala> import specs2.arguments.*scala> given Arguments = nocolorscala> specs2.run(spec1).', 'tags':'', 'loc':'org.specs2.guide.RunInShell.html'},
{'title':'Random execution', 'text':' The  page describes the most frequent modes of execution:  - fully concurrent  - concurrent with steps  - fully sequentialExecuting the specification concurrently in particular can be a good way to test the stability of the system in presence of random commands. However it is sometimes not possible to overlap examples executions because that could break the external state. Random sequential executionIn this case you can use another mode of execution. The `sequentialRandom` argument adds randomdependencies to your examples so that they will force them to be executed in a random order,one after the other. This randomization is only being done for examples in between stepsso if you have steps inside the specification guaranteeing some kind of checkpoints during the execution, they will be preserved.Lets see this on an example:class RandomSequentialSpec extends Specification:  def is = sequentialRandom  s2"""    example1 $e1    example2 $e2    example3 $e3    ${step(ok("here"))}    example4 $e4    example5 $e5    example6 $e6  """ def e1 = { "e1".pp; ok } def e2 = { "e2".pp; ok } def e3 = { "e3".pp; ok } def e4 = { "e4".pp; ok } def e5 = { "e5".pp; ok } def e6 = { "e6".pp; ok }With such a specification you might see in the console:[info] e3[info] e2[info] e1[info] here[info] e5[info] e6[info] e4 Using ScalaCheckThe `sequentialRandom` argument is a simple way to test random commands on a system.A better approach is to use ScalaCheck and its notion of [stateful property-based testing](http://www.scalacheck.org/files/scaladays2014/index.html).', 'tags':'', 'loc':'org.specs2.guide.RandomExecution.html'},
{'title':'Selection', 'text':'Many specifications are written incrementally. You specify a little bit then you implement the application. When you gothrough this "Specify-Implement-Execute" cycle it is useful to be able to focus on just one example, the one you arecurrently working on. The `ex` argument is what you need (`ex` stands for "example"):sbt> testOnly *MySpecification* -- ex containsThe command above will execute any example which description matches the regular expression `.*contains.*` (which meansthat you can pass regular expressions in general). If you want to match a few words you will need to use double quotes:sbt> testOnly *MySpecification* -- ex "contains hello" sequential Use tagsTags can be used in a Specification to include or exclude some examples or a complete section of fragments from theexecution. Lets have a look at one example: class TaggedSpecification extends Specification:  def is = s2"""  this is some introductory text    and the first group of examples    example 1 $success ${tag("feature1", "unit")}    example 2 $success ${tag("integration")}    and the second group of examples ${section("checkin")}    example 3 $success    example 4 $success ${section("checkin")}  """In that specification we are defining several tags and sections:* `feature 1` is a tag that is applied to `example1` (the _preceding_ Fragment)* `feature 2` is a tag that is applied to `example2` (the _preceding_ Fragment)* `checkin` marks a section which goes from the Text `and the second group of examples` to `example 4`Armed with this, it is now easy to include or exclude portions of the specification at execution time:* `include feature1` will only include `example 1`* `exclude integration` will include everything except `example 2`* `include checkin,unit` will include anything having either `checkin` OR `unit`: i.e. `example 1` and the second group of examples (`example 3` and `example 4`)* `include feature1 && unit` will include anything having `feature1` AND `unit`: i.e. `example 1`* `include feature1 && unit, checkin` will include anything having `feature1` AND `unit`, OR having `checkin`: i.e. `example 1`, `example 3`, `example4` In a unit specificationA _unit_ specification will accept the same `tag` and `section` methods but the behavior will be slightly different: import org.specs2.mutable.*class TaggedSpecification extends Specification:  "this is some introductory text" >> {    "and the first group of examples" >> {      tag("feature 1", "unit")      "example 1" in success      "example 2" in success    }  }  section("checkin")  "and the second group of examples" >> {    "example 3" in success    "example 4" in success  }  section("checkin")  "and the last group of examples" >> {    "example 5" in success tag "integration"    "example 6" in success  } section "slow"For that specification above, tags can be applied to fragments following them: * when the `tag` call is inserted on a new line, the tagged fragment is the one just _after_ the tag method call: `example 1` is tagged with `feature1 and unit`, * when the `section` call is inserted on a new line, this opens a section for all the following fragments. This should be closed by a corresponding `section` call on a new line. For example, `example 3` and `example 4` are part of the "checkin" sectionBut they can also be applied to fragments preceding them: * when the `tag` is appended to an example, it applies to that example: `example 5` is tagged with `integration` * when the `section` call is appended to a block of Fragments on the same line, all the fragments of that block are part of the section: `example 5` and `example 6` are tagged with `slow` Automatic sectionsIf you call `addSections` from inside the specification, each "block" will be surrounded by section tags having the samename as the block text:import org.specs2.mutable.*class SectionsSpecification extends Specification:  addSections()  "first section" >> {    "example 1" in success    "example 2" in success  }  "second section" >> {    "example 3" in success    "example 4" in success  }  "third section" >> {    "example 5" in success    "example 6" in success  }If you want you can execute only example 3 and 4 by running `sbt> testOnly *SectionsSpecification -- include "second section"`. `Always` tagSome specifications need to have `Steps` which will always be included whatever tags are specified on the command line.This is the case when defining a  with setup/teardown steps: trait DatabaseSpec extends Specification:  override def map(fs: =>Fragments) =    step(success("startDb"))  tag(AlwaysTag)       fs       step(success("cleanDb"))  tag(AlwaysTag) Select failed examplesAnother frequent mode of selection is the selection based on previous execution.Generally we want to re-execute only what was broken before. For this, using the `was` argument on the command-line:sbt> testOnly *MyFailedSpecification* -- was xOn the line above `x` is the status of the previous example. Here is a table of all the flags you can use:  Flag | Description ----- | ------------  `+`  | successful example  `x`  | failed example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `1`  | statisticsThis selection works because specs2 stores the state of each specification in a directory after a run (`target/specs2-reports/stats` by default). If you decide that this storing is useless and you want to skip it you can use the `neverstore` argument. Otherwise if you want to make sure that the `stats` directory doesnt become too big over time you can use the `resetstore` argument which will remove the current store before running the specification.<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - learn how to  - consult the  for a list of all arguments</div>', 'tags':'', 'loc':'org.specs2.guide.Selection.html'},
{'title':'Specification template', 'text':'On the  page we saw that there is a way to define an action which will be executed before all examples with the `BeforeSpec` trait.You actually might want to create your own trait extending `BeforeSpec` in order to reuse this action in more than one specification:trait DatabaseSetup extends BeforeSpec:  def beforeSpec = step(println("prepare database"))class DatabaseSpecification1 extends Specification with DatabaseSetup:  def is = s2"""  // do something with the database"""How does this work? The `BeforeSpec` trait overrides a method called `map` in the `SpecificationStructure` trait (a parent of `Specification`)and adds the fragments defined by `beforeSpec` before anything else in the specification:override def map(fs: =>Fragments): Fragments =  // the AlwaysTag is there to make sure that those fragments are always executed  // even if we filter by name or other tags  super.map(fs).prepend(beforeSpec.append(fragmentFactory.markAs(AlwaysTag)))The `map` method is indeed called every time the specification returns the list of `Fragment`s defining it. You can leverage this method and define your own "Specification templates": - adding some text before/after a Specification - filtering out some undesirable fragments - reformatting all text - ...<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">    You will probably need to learn a bit more about specs2   in order to modify, delete or add new "Fragments".</div>', 'tags':'', 'loc':'org.specs2.guide.SpecificationTemplate.html'},
{'title':'Skip examples', 'text':'The section on  already presents two methods for skipping examples.But this works for individual examples only. In some circumstances you might want to skip a whole specification.For example, your specification needs to access a web service in order to work and this service might not be available on all testing machines.You can skip this specification conditionally with the `skipAllIf` argument:class InactiveSpec extends Specification:  def is = skipAllIf(databaseIsDown)  s2"""  There is a list of customers in the database $e1  One of them is called Eric $e2  """  def e1 = database.getCustomers must not(beEmpty)  def e2 = database.getCustomers must contain((_: Customer).name === "Eric")There also is a version of `skipAllIf` which reads better for some conditions: `skipAllUnless`.', 'tags':'', 'loc':'org.specs2.guide.SkipExamples.html'},
{'title':'Standard results', 'text':'The specs2  guide introduces matchers to create expectations but you can use other kinds of predefined results to implement your examples. Boolean resultsThis is the simplest kind of result you can define for an expectation but also the least expressive!It can be useful for simple expectations but a failure will give few information on what went wrong: new mutable.Specification:  "this example is ok" >> {    1 == 1  }  "this one is not" >> {    // fails with the value is false...    1 == 2  }Not only that but in unit specification no exception will be thrown so you need to `&&` and `||` operators to connect your assertions if they span several lines. Standard resultsSome other results will give you an additional piece of meaning:`success` when your example is ok`failure` when your example is incorrect`anError` when an exception occurs`skipped` when you want to skip the example. You can add a more specific message with `skipped("because it just doesnt work in these conditions")``pending` usually means "not implemented yet", but you can add a more specific message with `pending("because I dont have time for this")`Two additional results are also available to track the progress of features:`done` a `Success` with the message "DONE"`todo` a `Pending` with the message "TODO" Skipping an exampleIf you already have some code for your example, adding `skipped` at the end to skip it is not very effective: - there is a possibility that the code throws an exception - the code will be executed which will waste resourcesWhat you want in that case in to skip the whole block:s2" this example *must* be skipped $e1"def e1 = skipped {  // whatever code is in there, it will not be executed and the result will be skipped  throw new Exception("uh-oh")  1 === 1} Setting an example as PendingSimilarly you can mark the example as `Pending`:s2" this example is pending for now$e1"def e1 = pending {  // whatever code is in there, it will not be executed and the result will be pending  throw new Exception("uh-oh")  1 === 1} Standard `MatchResults`When combining matchers you might be expected to return a `Result`. There are predefined values for those too: * `ok` or `ok(message)` for a Success * `ko` or `ko(message)` for a Failure', 'tags':'', 'loc':'org.specs2.guide.StandardResults.html'},
{'title':'Timeout examples', 'text':' Global timeoutSome examples take too long to run and it is desirable to interrupt them if they do. You can specify a global timeout by passing a value in millisecondson the command line:sbt> testOnly -- timeout 500 Specification timeoutIt is also possible to specify a specification timeout overriding the global timeout by specifying the timeout argument: class MySpecification extends Specification:  def is = args.execute(timeout = 10.seconds)  s2"""  this example should not take too long $e1  this one too $e2  """  def e1 = { 1 + 1 === 2 }  def e2 = { 2 + 2 === 4 }', 'tags':'', 'loc':'org.specs2.guide.TimeoutExamples.html'},
{'title':'Use command-line arguments', 'text':'Some specifications need to be fine-tuned and constantly modified. Sometimes to access a specific environment, or to disable some examples,or to execute more ScalaCheck properties. For all those situations it is desirable to modify the specification directly from the command-linewithout having to recompile it. Control an exampleLets see first how to use the command line to modify the outcome of just one example:import org.specs2.main.*class SpecificationWithArgs(args: CommandLine) extends Specification:  def is = s2"""  This example is controlled from the command line $e1  """  def e1 =  if args.isSet("isOk") then    1 === 1  else    1 === 2With a mutable specification the code is similar:class SpecificationWithArgs(args: CommandLine) extends mutable.Spec:  "This example is controlled from the command line" >> {    if args.isSet("isOk") then      1 === 1    else      1 === 2  }Then you can set the argument, or not in sbt withsbt> testOnly *ArgsSpec*sbt> testOnly *ArgsSpec* -- !isOksbt> testOnly *ArgsSpec* -- isOkThe first 2 invocations of the specification will report a failure (1st one, the argument is not set and for the second one it is negated) and the 3rd invocation will make the specification pass. Control a specificationAny specification with a 1-parameter constructor can be instantiated provided that: - the parameter has itself a constructor with no parameters or a 1-parameter constructor which we can instantiate - the parameter is of type `Env`, `ExecutionEnv`, `Arguments`, `CommandLine`In particular this means that you can define a `Specification` with a constructor using a `CommandLine` argument and whenthe specification will be created it will be passed the command line arguments: case class MyDbSpec(commandLine: CommandLine) extends Specification with DbSpec:  def is = s2"""  create a user $createUser  """  // the database client is created from the command line  // arguments and can be used in the examples  def createUser = client.createUser("xxx") must beSome// Template trait for accessing the database// this trait can be controlled from command line arguments// and it takes care of the setup of the database before and after all// the examplestrait DbSpec extends Specification with BeforeAfterSpec:  def commandLine: CommandLine  def beforeSpec = step(println("start db here"))  def afterSpec  = step(println("stop db here"))  lazy val client = {    if (commandLine.contains("prod")) DbClient("production")    else                              DbClient("test")  }case class DbClient(env: String):  def createUser(name: String): Option[String] = ???', 'tags':'', 'loc':'org.specs2.guide.UseCommandLineArguments.html'},
{'title':'Expectation description', 'text':' Enhance failures messagesSome expressions using matchers might not produce very useful messages. For example: val ticketsNumber = 5// will fail with 5 is not equal to 3ticketsNumber must be_==(3)You can improve this failure message by describing what `ticketsNumber` represents: val ticketsNumber = 5// will fail with "the number of tickets 5 is not equal to 3"ticketsNumber aka "the number of tickets" must be_==(3)The `aka` (*also known as*) method has a few variations:* `value.aka` is a shortcut for `value aka value.toString`* `"a" post "is the first letter"` prints `a is the first letter`* `"b" as ((s:String) => "a"+s+"c")` prints `abc`* `Seq(1, 2, 3, 4).showAs((_:Seq[Int]).filter(isEven).mkString("|"))` prints `2|4`. This one is especially useful to filter out big data structures (lists, maps, xml...) before the displaying the failure message Update the failure messageOn a `Matcher` or a `Result` you can use `updateMessage(f: String => String)` or `setMessage(m: String)` to change the failure message. Describe an expectationAnother way to provide a description for an expectation is to use the `==>` (or `<==>`) operator:s2"""A byname function can be transformed into a strict one $e1"""def e1 = {  def byNameFunction(u: =>Unit): Unit = {}  var parameter = "not evaluated"  toStrictFunction1(byNameFunction) { parameter = "evaluated" }  "The byname function has become a strict one" ==> (parameter === "evaluated")}In the example above, testing if `parameter == "evaluated"` is just a way to observe what we wanted to achieve. If that doesnt work, the failure message will be[error] x The byname function has not become a strict one because evaluated is not equal to not evaluated', 'tags':'', 'loc':'org.specs2.guide.ExpectationDescription.html'},
{'title':'Execution', 'text':' Parallel by defaultspecs2 examples are executed concurrently by default: - this makes the execution faster - it encourages to write independent examples when the result of a given example should not be influenced by othersStarting from this default you can progressively add constraints to get more control over the execution. StepsA `Step` is an action which can be executed anywhere in a specification. When you declare a `Step` like this:class StepSpec extends Specification:  def is = s2"""  this is example 1 $ok  this is example 2 $ok  ${step(success("stop here for a second"))}  this is example 3 $ok  this is example 4 $ok  """Then the specification will:  1. execute examples 1 and 2 in parallel  2. execute the step  3. execute examples 3 and 4 in parallelThere is no "result" for a step but if it throws an Exception an `Error` will be reported. This will not however stop the execution of the rest of the specification. Stop the executionYou can still control if the rest of the specification must be executed by adding some constraints on the step. For example:class StepWithStopOnErrorSpec extends Specification:  def is = s2"""  this is example 1 $ok  this is example 2 $ok  ${step { sys.error("sorry!"); ko("stop here for a second") }.stopOnError}  this is example 3 $ok  this is example 4 $ok  """When this specification is executed examples 3 and 4 will be skipped because the step returns an `Error`. An `Error` is likely to be a fatal condition but you can use other methods to stop the execution: - `stopOnFail` stop if there is a failure in the previous examples or in the step - `stopOnSkipped` stop if there is a skipped result in the previous examples or in the step - `stopWhen(Result => Boolean)` stop if the and-ed result of the previous examples and the step verifies a given condition SequentialIf your specification is a list of well-ordered examples you can use the `sequential` argument to make sure that they are executed in order:class SequentialSpec extends Specification:  def is = sequential  s2"""  this is example 1 $ok  this is example 2 $ok  this is example 3 $ok  this is example 4 $ok  """Thanks to the `sequential` argument the 4 examples above will execute one after the other. ActionFinally if you want to execute "silent" actions, like steps, but with no impact on the sequencing of the specification, you can use an `Action`:class ActionSpec extends Specification:  def is = s2"""  this is example 1 $ok  this is example 2 $ok  // this will only be reported if there is a failure  ${action(ok("do something here"))}  this is example 3 $ok  this is example 4 $ok  """<h3 id="Now learn how to..." class="ribbon both-ribbon">Now learn how to...</h3><div class="ribbon-content">     - use  to select the examples to execute</div><h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - add  to your specification - consult the  for a list of all arguments</div>', 'tags':'', 'loc':'org.specs2.guide.Execution.html'},
{'title':'Pending until fixed', 'text':'Some examples may be temporarily failing but you may not want the entire test suite to fail just for those examples.Instead of commenting them out and then forgetting about those examples when the code is fixed, you can append `pendingUntilFixed` to the example: class SpecificationWithPendingExamples extends mutable.Spec:  "this example fails for now" >> pendingUntilFixed {    1 must ===(2)  }  // or, with a more specific message  "this example fails for now" >> pendingUntilFixed("ISSUE-123") {    1 must ===(2)  }The example above will be reported as `Pending` until it succeeds. \Then it is marked as a failure so that you can remember to remove the `pendingUntilFixed` marker.', 'tags':'', 'loc':'org.specs2.guide.PendingUntilFixedExamples.html'},
{'title':'Console output', 'text':'You will get a "console" output whenever you run a specification from  or a .There are arguments you can use to change the output:  Name               | Value format            | Comments ------------------- | ----------------------- | ------------------------------------------------------------------------ `xonly`             | boolean                 | only report failures and errors `showonly`          | String                  | only report some examples based on their status `failtrace`         | boolean                 | show a stack trace for failures `fullstacktrace`    | boolean                 | show a full stack trace `tracefilter`       | regexp-csv/regexp-csv   | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`        | see below               | define the parameters for the `SmartDiffs` instance for differences `diffsclass`        | class name              | use a specific instance of the `Diffs` trait `color`             | boolean                 | use colors `nocolor`           | boolean                 | dont use colors `colors`            | map                     | use different colors `colorsclass`       | class name              | use a specific instance of the `Colors` trait `showtimes`         | boolean                 | show execution times for examples `all`               | boolean                 | execute and report linked specifications (default = `false`) `indentation`       | int                     | number of spaces to use to indent nested examples in unit specifications (default = 2)Some of these arguments deserve further explanations. Show onlyYou can decide what you want to _show_ in the console by using the `showonly` arguments and the following flags:  Flag | Description ----- | ------------  `+`  | successful example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `#`  | title  `1`  | statisticsFor example if you just want to show text and failures you can use `showonly -x`. And the `xonly` argument is actually a shortcut for `showonly #x!`. StackTraceFilterThe `tracefilter` argument uses include/exclude patterns to define an instance of the `org.specs2.control.StackTraceFilter` trait which will filter stacktraces. By default the `DefaultStackTraceFilter` filter will exclude lines matching the following packages: * `org.specs2` * `scala\\.`, `java\\.` * `sbt\\.`, `com.intellij`, `org.eclipse.jdt`, `org.junit`If this is not what you want, you can either use the `tracefilter` argument with other patterns. For example `tracefilter com.acme\com.acme.impl` will only keep traces of classes in the `com.acme` package but will reject the ones in `com.acme.impl`.Note also that the default filter also truncates the stacktrace in the middle if it is bigger than 1000 lines to avoid reports being filled by out-of-control stacktraces. If you still want to see those lines you can re-run with the `fullstacktrace` argument. DiffsWhen using the equality matcher specs2 tries to display the difference between the expected and the actual values using a class: `org.specs2.main.SmartDiffs`. There are several parameters for that class which you can specify from the command line as:sbt> testOnly -- smartdiffs show,separators,triggerSize,shortenSize,diffRatio,full,seqTriggerSize,seqMaxSize// for examplesbt> testOnly -- smartdiffs true,[],20,5,30,false,0,1000000 Parameter          | Description -----------        | ---------------------------------------------------- `show`             | will not show anything (default = true) `separators`       | allows to change the separators used to show the differences (default = "[]") `triggerSize`      | controls the size above which the differences must be shown (default = 20) `shortenSize`      | controls the number of characters to display around each difference (default = 5) `diffRatio`        | percentage of differences above which the differences must not be shown (default = 30) `full`             | displays the full original expected and actual strings (default = false) `seqTriggerSize`   | the minimum size to compute differences on Seq, Set and Maps (default = 0) `seqMaxSize`       | the maximum size to compute differences on Seq, Set and Maps (default = 1000000)You can also specify your own enhanced algorithm for displaying the difference by providing an instance of the `org.specs2.main.Diffs` trait:trait Diffs {  /** @return true if the differences must be shown */  def show: Boolean  /** @return true if the differences must be shown for 2 different values */  def show(actual: Any, expected: Any): Boolean  /** @return true if the differences must be shown for 2 different sequences of values */  def showSeq(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): Boolean  /** @return true if the differences must be shown for 2 different maps */  def showMap(actual: Map[Any, Any], expected: Map[Any, Any]): Boolean  /** @return the diffs */  def showDiffs(actual: Any, expected: Any): (String, String)  /** @return the diffs for sequences with missing / added values  */  def showSeqDiffs(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): (Seq[String], Seq[String])  /** @return the diffs for sequences with missing / added values  */  def showMapDiffs(actual: Map[Any, Any], expected: Map[Any, Any]): (Seq[String], Seq[String], Seq[String])  /** @return true if the full strings must also be shown */  def showFull: Boolean}Here is an example:sbt> testOnly -- diffsclass org.acme.MyDiffClass ColorsBy default, the reporting will output colors. If youre running on windows you might either: * use the [following tip](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) to install colors in the DOS console * or pass `nocolor` as a command line argumentIt is possible to set colors by passing the `colors` argument. This argument must be a list of `key:value` pairs (comma-separated) where keys are taken from this table:Property  | Default value |--------- | ------------- |`text`    |  white        |`success` |  green        |`failure` |  yellow       |`error`   |  red          |`pending` |  cyan         |`skipped` |  magenta      |`stats`   |  cyan         |All the available colors are listed here, with their corresponding abbreviation which you can use to refer to them as well: Color   | Abbreviation | ------  | ------------ | white   | w            | green   | g            | yellow  | y            | red     | r            | blue    | be           | cyan    | c            | black   | bk           | magenta | m            |For example you can pass on the command line: `colors text:blue,failure:magenta`to have the text colored in blue and the failures in Magenta.If the `colors` option contains `whitebg` then the default colors are considered to be [`InvertedColors`](https://etorreborre.github.io/specs2/api/SPECS2-5.6.2/index.html#org.specs2.text.Colors):Property  | Default value |--------- | ------------  |`text`    |  black        |`success` |  green        |`failure` |  magenta      |`error`   |  red          |`pending` |  blue         |`skipped` |  cyan         |`stats`   |  blue         |You can also change the color scheme thats being used on the console by implementing your own [`org.specs2.text.Colors`](https://etorreborre.github.io/specs2/api/SPECS2-5.6.2/index.html#org.specs2.text.Colors) trait or override values in the existing `ConsoleColors` class and pass this class to the `colorsclass` argument. For example if you want to output magenta everywhere yellow is used you can write:class MyColors extends org.specs2.text.ConsoleColors {  override val failureColor = magenta}and invoke `colorsclass org.acme.MyColors`Finally note that the the color support for sbt on Windows is a bit tricky. You need to follow the instructions [here](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) then add to your script launching sbt:-Djline.terminal=jline.UnsupportedTerminal', 'tags':'', 'loc':'org.specs2.guide.ConsoleOutput.html'},
{'title':'For loops', 'text':'It is very tempting to use `foreach` to create examples or results from a sequence of values:(1 to 3).foreach(i => "example " + i ! { i must ===(i) })The problem with `foreach` is that the return value of the expression above is `Unit`. So you wont be able to use it in an acceptance specification or a mutable one. A list of examplesWhen we want to create a list of examples we need to return a `Fragments` object. The long-winded way to do so is to use a `foldLeft`:(1 to 3).foldLeft(Fragments.empty)((res, i) => res.append("example " + i ! { i must ===(i) }))Or, a bit fancier with `foldMap`:// Fragments has a Monoid instance so you can use the foldMap method(1 to 3).toList.foldMap(i => Fragments("example " + i ! { i must ===(i) }))Because this is a recurring pattern there are two methods encapsulating it:// when the function only returns a FragmentFragment.foreach(1 to 3)(i => "example " + i ! { i must ===(i) }): Fragments// when the function returns a Fragments objectFragments.foreach(1 to 3) { i =>  "examples for " + i  br     "1 + " + i ! { (1 + i) must ===((i + 1)) }  br     "2 + " + i ! { (2 + i) must ===((i + 2)) }}: FragmentsNow you can create a list of examples inside a "should" block in a mutable specification:class MySpec extends mutable.Specification:  "this block should have lots of examples" >> {    Fragment.foreach(1 to 1000) { i =>      "example " + i ! { i must ===(i) }    }  } A list of expectationsSimilarly, when you want to create a list of expectations inside an example, you should use a variant of `foreach` and `forall` methods: - If you need "thrown expectations", use the `foreach` and `forall` methods of `mutable.Specification`:class MySpec extends mutable.Specification:  "this collects results of all expectations and throws an exception" >> {    foreach(1 to 10) { i =>      i === 2    } // Collects results of all expectations. Throws an exception.    foreach(1 to 10) { i =>      i === i    } // This is not executed.  }  "this stops after the first failed expectation and throws an exception" >> {    forall(1 to 10) { i =>      i === 2    } // Stops after the first failed expectation. Throws an exception.  } - If you need "functional expectations" that return a `Result`, use `Result.foreach` or `Result.forall`:class MySpec extends mutable.Specification:  "this collects results of all expectations and returns a Result" >> {    Result.forall(1 to 10) { i =>      i === 2    }  }  "this stops after the first failed expectation and returns a Result" >> {    Result.foreach(1 to 10) { i =>      i === 2    }  }<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">   read about theunderstand why the `Result.foreach` method uses the </div>', 'tags':'', 'loc':'org.specs2.guide.ForLoops.html'},
{'title':'Capture snippets', 'text':'It is possible to include pieces of code in your documentation with the `org.specs2.specification.Snippets` trait using the `snippet` method to capture a block code with marker comments to delimit the parts you want to show.What does this look like? SnippetHere is an example of using the `snippet` method:s2"""This is a multi-line string with a code snippet: ${snippet{def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))factorial(3) == 6}}"""When you use the `snippet` method, the reports will show:This is a multi-line string with a code snippet:def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))factorial(3) == 6 CutsSince snippets are compiled code, you might have to include many declarations, like imports or variables definitions to make the code compile. This can make your documentation more verbose than necessary so you can hide those definitions by delimiting the code to show with some comments of the form `// 8<--`:s2"""This is a snippet of code with one relevant line: ${snippet{// 8<--def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))// 8<--factorial(3) == 6// 8<--}}"""The snippet above will only show `factorial(3) == 6`. You can repeat this pattern several times:s2"""This is a snippet of code with 2 relevant lines: ${snippet{// 8<--def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))// 8<--factorial(3) == 6// 8<--val n = 4// 8<--factorial(n) == 24}}"""This just displays:factorial(3) == 6factorial(n) == 24 EvaluationBy default the last value of a Snippet is not shown but you can display it with the `eval` method:s2"""This is a snippet of code with a result: ${snippet{factorial(3)}.eval}"""This displays:factorial(3)> 6 OffsetsIt is possible to adjust the margin of captured source code by adding or removing whitespace:s2"""This is a snippet of code with a negative offset to align the code to the border of the screen: ${snippet{   def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))   factorial(3)}.offsetIs(-3)}"""This displays:factorial(3) ParametersAll of the settings above: cuts, offset,... are coming from an given `SnippetParams` instance that is changing thebehavior of the created Snippets. You can choose, for a given scope, to replace these parameters with other ones andsimply shadow the default parameters with your own, for example to always evaluate the snippets results:given SnippetParams[T] = SnippetParams(evalCode = true)The parameters you can set are:name              | description----------------- | ---------------- `trimExpression` | function that is trimming the expression from newlines or accolades `cutter`         | function to remove parts which must not be shown `asCode`         | function to render the resulting text (as Markdown for example) `prompt`         | function to display the evaluated result with a prompt `evalCode`       | boolean indicating if a snippet must be evaluated `verify`         | function checking the snippet value', 'tags':'', 'loc':'org.specs2.guide.CaptureSnippets.html'},
{'title':'Html output', 'text':'specs2 can be used to produce HTML documentation to either: - report the execution of specifications - provide a user guide like this oneIf Markdown notation is used in the specification text and you have [Pandoc](http://johnmacfarlane.net/pandoc) installed on the command linethen it will rendered in the final output. Create Html filesWhen you execute a specification with the `html` command-line argument an HTML report is created in the `target/specs2-reports` directory.It will show the status of examples (success, failure,...) and stack traces if there are any errors.You can use the following arguments to change the HTML generation: Name                         | Default value                                 | Description ---------------------------- | --------------------------------------------- | ------------------------------ `all`                        | `false`                                       | execute and report linked specifications `html.outdir`                | `target/specs2-reports`                       | output directory `html.template`              | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`             | `Map[String, String]()`                       | those variables will be replaced during template evaluation `html.nostats`               | `false`                                       | if true no stats are displayed `html.search`                | `false`                                       | add a search box to the generated files `html.toc`                   | `false`                                       | add a table of contents to the generated files `html.toc.entrymaxsize`      | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs`      | `true`                                        | report "see" references which do not correspond to any generated file Use Pandoc for Markdown[Markdown](http://commonmark.org) text is supported if [Pandoc](http://johnmacfarlane.net/pandoc) is available on the command line andif the `!pandoc` boolean flag is not set. Name                    | Default value                                                                     | Description ----------------------- | --------------------------------------------------------------------------------- | ------------------------------ `pandoc`                | `true`                                                                            | set to `false` by passing `!pandoc` `pandoc.exec`           | `pandoc`                                                                          | path to the Pandoc executable `pandoc.inputformat`    | `markdown+pipe_tables+auto_identifiers+header_attributes+inline_code_attributes`  | pandoc arguments (see the Pandoc [user guide](http://johnmacfarlane.net/pandoc/README.html)) `pandoc.outputformat`   | `html`                                                                            | Use a different templateYou can change the overall structure of the html page for a specification by providing a different template with the `html.template` variable.When using your custom template the following variables will be replaced: Name                    | Description ----------------------- | ------------------------------ `$title$`             | specification title `$issues$`            | true if there are issues in the specification `$body$`              | the specification bodyYou can also pass your own variables by passing a map `name1=value1,name2=value2,...` to the `html.variables` argument.Those variables can then be used in the template: - by enclosing them in `$`: `$myVariable$` - by using the `if/else/endif` construct:$if(issues)$<h1>Failed! $title$$else$<h1>$title$</h1>$endif$ Use other CSS/Javascript filesCustom CSS and JavaScript files can be used without changing the template. In order to do this just put your own `specs2-user.css` file in `src/test/resources/css` or your own `specs2-user.js` file in `src/test/resources/javascript`. Create an indexHere is something you can do to automatically create an index page for your specifications: import org.specs2.*import org.specs2.runner.*import specification.core.*class index(env: Env) extends Specification:  def is =    examplesLinks("Example specifications")  // see the SpecificationsFinder trait for the parameters of the specifications method  def examplesLinks(t: String) = {    val finder = SpecificationsFinder.create(env)    t.title       Fragments.foreach(finder.specifications())(s => link(s)  br)  }The specification above creates an index.html file in the `target/specs2-reports` directory. The specifications method creates specifications using the following parameters: Name                    | Default                                       | Description ------                  | -------                                       | --------------------- `glob`                  | `**/*.scala`                                  | glob pattern to filter specification files `pattern`               | `.*Spec`                                      | pattern to use when trying to retrieve the specification names from the source files `filter`                | `(name: String) => true`                      | function to keep only some specifications depending on their name `basePath`              | `src/test/scala`                              | the path where to start the search `verbose`               | `false`                                       | boolean indicating if information about finding files and specifications must be printed `classLoader`           | `Thread.currentThread.getContextClassLoader`  | classloader used to load the specification classes `filePathReader`        | `org.specs2.io.FileSystem`                    | object used to read source files', 'tags':'', 'loc':'org.specs2.guide.HtmlOutput.html'},
{'title':'Debug statements', 'text':'When quick and hacky `println` statements are what you want, the `Debug` trait, mixed in every `Specification`, provides useful methods: * `pp` or "print and pass", prints a value to the console, then returns it to be used in the rest of the expression:  graph.pp must haveSize(3) `pp(condition)` prints a value if a condition holds * `pp(f: T => Boolean)` prints a value if a condition on that value holds', 'tags':'', 'loc':'org.specs2.guide.DebugStatements.html'},
{'title':'JUnit XML output', 'text':'Many continuous integration servers (like [Jenkins](http://jenkins-ci.org)) accept JUnit XML as their de facto standard for reporting test results.You can output a JUnit XML file by simply using the `junitxml` argument: `testOnly org.acme.MySpec -- junitxml`The JUnit XML file corresponding to the specification will be produced by default in the `target/test-reports` directory. You can change this directory by passing the `junit.outdir` argument like so: `testOnly org.acme.MySpec -- junitxml junit.outdir custom_xml_folder`This will output the xml files in the `custom_xml_folder` in the top level project directory. that using `junitxml` by itself will turn off the console reporting. You need to add `console` to get it back. Output directory with `sbt test``sbt test` does not take parameters so the default behavior is to produce the JUnit XML files for all specifications in the default output directory.In order to change the default output directory of the junit xml files when running the tests with `test`, add the following to your sbt build file: `Test / testOptions += Tests.Argument("junitxml", "junit.outdir", "custom_xml_folder")`This will suppress the console output, which may be what you want if this is a configuration for a build machine. To re-enable console output, use instead:  Test / testOptions ++= Seq(    Tests.Argument("junitxml", "junit.outdir", "custom_xml_folder"),    Tests.Argument("console") ) ', 'tags':'', 'loc':'org.specs2.guide.JUnitXmlOutput.html'},
{'title':'Lightweight specs', 'text':'The default `Specification` class mixes in most of specs2 features in order to make it very easy to write your first specificationswithout worrying too much about where the feature resides.There at least 2 downsides to this approach:inside a `Specification` you get lots of inherited method names, encumbering the namespacemany of the traits mixed-in the `Specification` class define implicit methods and those methods can have some impact on compilation timesIt is thus possible to use another class, `org.specs2.Spec` (or `org.specs2.mutable.Spec`), which only provides the minimum number of implicits to create specifications.With the `Spec` class you can create examples and expectations with simple matchers. For example:class HelloWorldSpec extends Spec:  def is = s2"""  This is a specification to check the Hello world string  The Hello world string should    contain 11 characters $e1    start with Hello $e2    end with world $e3  """  def e1 = "Hello world" must haveSize(11)  def e2 = "Hello world" must startWith("Hello")  def e3 = "Hello world" must endWith("world")Or, for mutable specs:class HelloWorldSpec extends mutable.Spec:    addParagraph("This is a specification to check the Hello world string")    "The Hello world string should" >> {      "contain 11 characters" >> {        "Hello world" must haveSize(11)      }      "start with Hello" >> {        "Hello world" must startWith("Hello")      }      "end with world" >> {        "Hello world" must endWith("world")      }    }If you compare those 2 specifications with the "HelloWorldSpec" examples using `Specification` you will notice some differences: - you cannot write `"The Hello world string" should {` - you cannot write `"This is a specification to check the Hello world string".txt` to add some text to a mutable specBut not all is lost! For each functionality you might want to use there is a trait which you can mix-in to get it. Adding featuresWhen creating expectations: Feature                                          | Trait                                           | Comment ---------------------------                      | --------------------                            | ------------------- Use should for expectations                      | `org.specs2.matcher.ShouldMatchers`             | Describe expectations with `==>`                 | `org.specs2.matcher.ExpectationsDescription`    | Describe expectations with `aka` and must        | `org.specs2.matcher.MustExpectations`           | Use `list must have size(3)`                     | `org.specs2.matcher.TraversableMatchers`        | Use matchers in `contain` or `beSome` matchers   | `org.specs2.matcher.ValueChecks`                | Use `===`, `====` to check for equality          | `org.specs2.matcher.TypedEqual`                 | Create matchers from functions                   | `org.specs2.matcher.MatcherCreation`            | Set failed expectations as Pending               | `org.specs2.execute.PendingUntilFixed`          |When creating acceptance specifications: Feature                                                      | Trait                                                  | Comment ---------------------------                                  | --------------------                                   | ------------------- Interpolate anything else than a `Result` in a `s2` string   | `org.specs2.specification.create.S2StringContext`      | Use "bang" examples: `"example" ! ok`                        | `org.specs2.specification.dsl.ExampleDsl`              | Create and append `Fragments` with ``                       | `org.specs2.specification.dsl.FragmentsDsl`            | Add arguments and a title to `Fragments` with ``            | `org.specs2.specification.dsl.SpecStructureDsl`        | Create a title with `"A title".title"`                       | `org.specs2.specification.dsl.TitleDsl`                | Create references to other specifications                    | `org.specs2.specification.dsl.ReferenceDsl`            | Create steps and actions                                     | `org.specs2.specification.dsl.ActionDsl`               | Use tags                                                     | `org.specs2.specification.dsl.TagDsl`                  | To use all of the `Dsl` traits use `AcceptanceDsl`When creating mutable specifications: Feature                                   | Trait                                                  | Comment ---------------------------               | --------------------                                   | ------------------- Use "bang" examples: `"example" ! ok`     | `org.specs2.specification.dsl.mutable.ExampleDsl`      | Create a title with `"A title".title"`    | `org.specs2.specification.dsl.mutable.TitleDsl`        | Set arguments                             | `org.specs2.specification.dsl.mutable.ArgumentsDsl`    | Create references to other specifications | `org.specs2.specification.dsl.mutable.ReferenceDsl`    | Create steps and actions                  | `org.specs2.specification.dsl.mutable.ActionDsl`       | Add text and paragraphs                   | `org.specs2.specification.dsl.mutable.TextDsl`         | Use tags                                  | `org.specs2.specification.dsl.mutable.TagDsl`          | To use all of the `Dsl` traits use `MutableDsl`', 'tags':'', 'loc':'org.specs2.guide.LightweightSpecs.html'},
{'title':'Print execution data', 'text':' Print success dataIf an example returns returns a `Success` we just print the example name on the console but it can be interesting to alsoget some information about the data the example was executed with. In order to do that you can use the `updateExpected`method and pass a non-empty string with your message: "this is an obvious example" ! {  val i = 1  (i must ===(1)).updateExpected("executed with " + i)}This will print on the console:[info] + this is an obvious example[info] executed with 1Lets use this method now to display the execution time for each example of a specification. Print execution timeKnowing that an example succeeded is fine but sometimes you want to display more information,like the time spent executing the example for instance, or some other state before and after each example.This can be done by using the `AroundEach` trait and updating the `Result` of the example execution with whatever you want to display: ${snippet{import org.specs2.specification.*import org.specs2.execute.*import org.specs2.time.*trait Timed extends AroundEach:  def around[T : AsResult](t: =>T): Result =    // use `ResultExecution.execute` to catch possible exceptions    val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))    // update the result with a piece of text which will be displayed in the console    result.updateExpected("Execution time: "+timer.time)/** measure the execution time of a piece of code */def withTimer[T](t: =>T): (T, SimpleTimer) =  val timer = (new SimpleTimer).start  val result = t  (result, timer.stop)}}When you execute a specification mixing the `Timed` trait you should see the timing of each example displayed in the console:[info] TimedExecutionSpecification[info][info] + example 1[info] Execution time: 94 ms[info] + example 2[info] Execution time: 11 msThis is just an example to give you some inspiration. Since displaying execution times is quite often usefulthe same functionality is actually accessible with the [`showtimes` argument](). With the example descriptionMore generally, you can both use the example description and the example body to display custom messages.One way to do this is by taking the advantage of the fact that a `Specification` is just a stream of `Fragments`: import org.specs2.specification.core.*import org.specs2.execute.*import org.specs2.time.*object extras:  /** measure the execution time of a piece of code */  def withTimer[T](t: =>T): (T, SimpleTimer) =    val timer = (new SimpleTimer).start    val result = t    (result, timer.stop)  // extend each example in a Specification with a measured time message  extension (fs: Fragments)    def showTimes: Fragments =      fs.map {        case f if Fragment.isExample(f) =>          f.updateResult { r =>            val (result, timer) = withTimer(ResultExecution.execute(AsResult(r)))            result.updateExpected("Execution time for \"" + f.description.show + "\": " + timer.time)          }        case other => other      }// example of useimport extras.*class HelloWorldSpec extends Specification:  def is = s2"""    This is a specification to check the Hello world string    The Hello world string should      contain 11 characters $$e1      start with Hello $$e2      end with world $$e3  """.showTimes', 'tags':'', 'loc':'org.specs2.guide.PrintExecutionData.html'},
{'title':'Multiline descriptions', 'text':'In a `s2` string the description of an example is taken as all the text having the same indentation before the example body:s2"""This is the introduction paragraphWhich presents the examples  the first example has one line $ok  the second example has  more than one line $ok"""This printsThis is the introduction paragraphWhich presents the examples  + the first example has one line  + the second example has    more than one lineIf you want the example description to be unevenly aligned you can use a margin `|`:s2"""This is the introduction paragraphWhich presents the examples  |this example has a very  | very very  |   specific indentation $ok"""This printsThis is the introduction paragraphWhich presents the examples  + this example has a very     very very       specific indentation', 'tags':'', 'loc':'org.specs2.guide.MultilineDescriptions.html'},
{'title':'Example description', 'text':'["Dont repeat yourself"](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself) mandates that the same information is not repeated twice.However this situation happens when part of an example description is reused in the example body: s2"""  1971-01-01 is a correct date $correct"""def correct = { "1971-01-01" must beCorrect } Use the example descriptionYou can avoid this by creating the example body as a function using the description string: s2"""  1971-01-01 is a correct date $correct"""def correct = { (date: String) =>  date.split(" ")(0) must beCorrect} Parse the example description Delimited valuesWe can reuse the `StepParsers` to extract the values we wish to use: s2"""  {1971-01-01} is a correct date $correct  {1} plus {1} is {2} $addition"""import org.specs2.specification.script.StepParsers.*import org.specs2.specification.script.StepParsers.givendef correct = extract { (date: String) =>  date must beCorrect}def addition = extract { (a: String, b: String, c: String) =>  a.toInt + b.toInt must ===(c.toInt)}The values to be extracted are delimited by `{}` and those curly braces will not be displayed when the specification is reported. Standard delimited parsersWhen you parse values with `extract` you get only Strings which you have to transform into `Int` for example. specs2 comes up with a few predefined parsers to help you with that: s2"""  {1} plus {1} is {2} $addition"""import org.specs2.specification.script.StandardDelimitedStepParsers.*def addition = threeInts.map { case (a, b, c) =>  a + b must ===(c)}The other parsers are: parser        | description ------------- | ----------- `anInt`       | return a `Int` `twoInts`     | return a pair `(Int, Int)` `threeInts`   | return a triple `(Int, Int, Int)` `aDouble`     | return a `Double` `twoDoubles`  | return a pair `(Double, Double)` `threeDoubles`| return a triple `(Double, Double, Double)` `aString`     | return a `String` `twoStrings`  | return a pair `(String, String)` `threeStrings`| return a triple `(String, String, String)` Regular expressionsAnother way to extract values is to use regular expressions to extract similar groups of values. In that case no delimiters are required. For example: s2"""  1971-01-01 is a correct date $correct  1 plus 1 is 2 $addition"""import org.specs2.specification.script.StepParsers.*// groupAs is equivalent to running regexp findAllIn text// and getting one argument per match group founddef correct = groupAs("[ ]+").and { (date: String) =>  date must beCorrect}def addition = groupAs("\\d+").and { (a: String, b: String, c: String) =>  a.toInt + b.toInt must ===(c.toInt)} Standard regexp parsersSimilarly to delimited parsers, there are some predefined regexp parsers: s2"""  1 plus 1 is 2 $addition"""import org.specs2.specification.script.StandardRegexStepParsers.*def addition = threeInts.map { case (a, b, c) =>  a + b must ===(c)}', 'tags':'', 'loc':'org.specs2.guide.ExampleDescription.html'},
{'title':'Add keywords', 'text':'Mutable specifications offer a predefined "vocabulary" to define examples: import org.specs2.*class MySpecification extends mutable.Specification:  "the and function" should {    "return true when passed true, true" >> {      (true && true) === true    }    "return false when passed true, false" >> {      (true && false) === false    }  }This will print: the and function should   + return true when passed true, true   + return false when passed true, falseAnd you can see that the word "should" has been added to the first description.However one size does not fit all and you might want to add your own predefined words. Here is how to do it: import org.specs2.*import org.specs2.specification.core.{Fragment, Fragments}import org.specs2.specification.dsl.mutable.*trait ToKeyword extends ExtendedBlockDsl:  extension (description: String)    infix def to(f: =>Fragment): Fragment =      (description + " to") >> f    // this implementation of `to` uses an implicit parameter. This is used to overload    // the method for different arguments: Fragment and Fragments    @targetName("toFs")    infix def to(fs: =>Fragments): Fragments =      (description + " to") >> fsclass MySpecification extends org.specs2.mutable.Specification with ToKeyword:  "the and function is used" to {    "return true when passed true, true" >> {      (true && true) === true    }    "return false when passed true, false" >> {      (true && false) === false    }  }Now this will print the and function is used to   + return true when passed true, true   + return false when passed true, false', 'tags':'', 'loc':'org.specs2.guide.AddKeywords.html'},
{'title':'IO Integration', 'text':'Any IO-like data type which can be executed as a `Future` can be integrated in specifications.Here is such a data type:import scala.concurrent.*case class IO[T](run: ExecutionContext => Future[T])You can integrate it to any specification by providing an instance of the `AsExecution` typeclass:import org.specs2.execute.{AsResult}import org.specs2.specification.core.{AsExecution, Execution}object IO:  // this converts an IO value into a specs2 Execution with the  // withEnvAsync function which takes a Future  given [R : AsResult]: AsExecution[IO[R]] with    def execute(io: =>IO[R]): Execution =      Execution.withEnvAsync(env => io.run(env.executionContext))  // create a successful IO value (used in the example below)  def successful[T](t: =>T): IO[T] =    IO(_ => Future.successful(t))You can then use your IO type in a normal specification:class TestMutableSpec extends mutable.Specification:  "e1" >> {    IO.successful(ok)  }', 'tags':'', 'loc':'org.specs2.guide.IoIntegration.html'},
{'title':'`AsResult` typeclass', 'text':'There are many ways to define expectations in specs2:Boolean (`true, false`)Standard result (`success, failure`)Matcher result (`1 must ===(1`))Scalacheck propertyDataTableFormsAll of these types implement the `org.specs2.execute.AsResult` typeclass, meaning that they can be transformed into a `Result`:trait AsResult[T]:  def asResult(t: =>T): ResultThis gives some flexibility in integrating any kind of custom definition of a "result" into specs2 and this is why you find this typeclass as a requirement to build examples or to declare contexts.You can take advantage of this type class by defining your own kind of result and providing a typeclass instance for it:// A new type of results for cluster executiontrait ClusterExecution:  def succeeded: Boolean  def errorMessage: Stringobject ClusterExecution:  given AsResult[ClusterExecution] =    new AsResult[ClusterExecution]:      def asResult(t: =>ClusterExecution): Result =        try {          val result = t          if (result.succeeded) Success()          else Failure(t.errorMessage)        } catch { case e: Throwable => Error(e) } Decorated resultsYou can also embed custom data in a special kind of `Result`, with the `org.specs2.result.DecoratedResult` class:case class DecoratedResult[+T](decorator: T, result: Result) extends Result(result.message, result.expected)A `DecoratedResult[T]` decorates an ordinary result with an additional value of type `T`.If you want to take advantage of this custom value in your reports you will need to build a custom `org.specs2.reporter.Printer`, probably extending an existing one.<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - mark any object having an `AsResult` instance as </div>', 'tags':'', 'loc':'org.specs2.guide.AsResultTypeclass.html'},
{'title':'Arguments reference', 'text':'Arguments can be passed on the command line, or declared inside a specification, using the `args(name=value)` syntax:class MySpec extends Specification:  def is = args(xonly = true)  s2"""  Clever spec title  And some intro text  brilliant expectation $success  """They can also be passed as system properties: `-Dspecs2.name=value` (`-Dname=value` also works but you might have collisions with other properties).Note that boolean properties like `color` can be defined in several ways: - not defined => the default value, `true`, is used - `color`     => use colors - `color true` => use colors - `color false` => dont use colors (`nocolor` is an alias) - `-Dspecs2.color`     => use colors - `-Dspecs2.color=true` => use colors - `-Dspecs2.color=false` => dont use colors (`-Dspecs2.nocolor` is an alias)This reference guide for arguments is divided in several sections: - "path" arguments defining where specs2 should read or write files - "selection" arguments to select the examples to run - "execution" arguments for execution parameters - "storing" arguments to store statistics - "reporting" arguments to control the output - API for arguments when used in the code**Tip!** the `verbose` argument will report any unknown argument passed on the command line Paths Name                    | Default value                  | Description ----------------------- | ------------------------------ | ----------------------------------------------------------------- `stats.outdir`          | `target/specs2-reports/stats`  | output directory for run statistics (see ) `junit.outdir`          | `target/test-reports/`         | output directory for JUnit XML files (see ) `html.outdir`           | `target/specs2-reports`        | output directory for html files (see ) `filesrunner.basepath`  | `src/test/scala`      | source directory for test files (see ) `filesrunner.path`      | `**/*.scala`          | glob pattern for the file paths (see ) `filesrunner.pattern`   | `(.*Spec)\s*extends\s*.*`       | regular expression capturing the specification class/object name (see ) `filesrunner.verbose`   | `false`                        | logs of searched paths and potential classes to instantiate (see ) Selection Name                    | Default value                  | Description ----------------------- | ------------------------       | ------------------------------------------------------------------------------------------- `ex`                    | `.*`                           | regular expression specifying the examples to execute. Use `ex .*brilliant.*` on the command line `was`                   | `""`                           | select only some previously executed examples based on their status `include`               | `""`                           | execute only the fragments tagged with any of the comma-separated list of tags: `t1,t2,...` `exclude`               | `""`                           | do not execute the fragments tagged with any of the comma-separated list of tags: `t1,t2,...` `selector`              | `""`                           | implementation of the `org.specs2.specification.process.Selector` trait Execution Name                    | Default value                                    | Description ----------------------- | ------------------------------------------       | ------------------------------------------------------------------------------------------- `plan`                  | `false`                                          | only report the text of the specification without executing anything `skipAll`               | `false`                                          | skip all the examples `skipAllIf(condition)`  |                                                  | skip all the examples if a given condition is met `skipAllUnless(condition)` |                                               | skip all the examples unless a given condition is met `stopOnFail`            | `false`                                          | skip all examples after the first failure `stopOnError`           | `false`                                          | skip all examples after the first error `stopOnIssue`           | `false`                                          | skip all examples after the first failure or error `stopOnSkip`            | `false`                                          | skip all examples after the first skipped result `sequential`            | `false`                                          | dont execute examples concurrently `asap`                  | `false`                                          | execute all the examples before reporting them `useCustomClassLoader`  | `false`                                          | use a custom class loader set on the `Env` to execute each example. By default sbts classloader for running tests is attached to the `Env` `threadsNb`             | `min(Runtime.getRuntime.availableProcessors, 4)` | number of threads to use for concurrent execution inside the user examples (this cannot be set on a specification, it has to be set globally) `specs2ThreadsNb`       | `min(Runtime.getRuntime.availableProcessors, 4)` | number of threads to use for the concurrent execution of specs2 actions (this cannot be set on a specification, it has to be set globally) `scheduledThreadsNb`    | `1`                                              | number of threads to use for timing out execution `discardRejected`       | `true`                                           | do not print warning messages when non terminated future are discarded from the thread pool `batchSize`             | `min(Runtime.getRuntime.availableProcessors, 4)` | number of examples which start executing concurrently at the time `timeFactor`            | `1`                                              | multiply all durations by this factor when waiting for futures `executor`              | `""`                                             | implementation of the `org.specs2.specification.process.Executor` trait Storing Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------ `neverstore`            | `false`                        | never store statistics if true `resetstore`            | `false`                        | delete previous store statistics if true ReportingSee the  page for a more precise description of these options. Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------ `xonly`                 | `false`                        | only report failures and errors `showonly`              | `""`                           | only report some examples based on their status `failtrace`             | `false`                        | show a stack trace for failures `fullstacktrace`        | `false`                        | show a full stack trace `tracefilter`           | `""`                           | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`            | `""`                           | define the parameters for the `SmartDiffs` instance for differences `diffsclass`            | `""`                           | use a specific instance of the `Diffs` trait `color`                 | `true`                         | use colors `colors`                | `""`                           | use different colors `colorsclass`           | `""`                           | use a specific instance of the `Colors` trait `showtimes`             | `false`                        | show execution times for examples `all`                   | `false`                        | execute and report linked specifications `notifier`              | `""`                           | name of a class extending the `org.specs2.reporter.Notifier` trait `printer`               | `""`                           | name of a class extending the `org.specs2.reporter.Printer` traitFor  the following options can be used: Name                    | Default value                                 | Description ----------------------- | --------------------------------------------- | ------------------------------ `all`                   | `false`                                       | execute and report linked specifications `html.outdir`           | `target/specs2-reports/`                      | output directory for the html files `html.template`         | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`        | `Map[String, String]()`                       | passed to the template during the Pandoc evaluation `html.nostats`          | `false`                                       | if true no stats are displayed `html.search`           | `false`                                       | add a search box to the generated files `html.toc`              | `false`                                       | add a table of contents to the generated files `html.toc.entrymaxsize` | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs` | `true`                                        | report "see" references which do not correspond to any generated file Arguments APIFrom inside a specification, the `args` method provides the most frequent arguments as `args(argumentName = argumentValue)`. In the least frequent cases you will have to write:// for selection arguments    args.select(ex = "example \\d*")// for reporting arguments    args.execute(threadsNb = 4)// for storing arguments    args.store(reset = true)// for reporting arguments    args.report(xonly = true)There are also a few shortcuts: Name                                                                  | Equivalent --------------------------------------------------------------------- | ----------------------- `include(tags: String)`                                               | `args(include=tags)` `exclude(tags: String)`                                               | `args(exclude=tags)` `only(examples: String)`                                              | `args(ex=examples)` `was(status: String)`                                                 | `args(was=status)` `plan`                                                                | `args(plan=true)` `skipAll`                                                             | `args(skipAll=true)` `skipAllIf(condition)`                                                | `args(skipAll=condition)` `skipAllUnless(condition)`                                            | `args(skipAll=!condition)` `stopOnFail`                                                          | `args(stopOnFail=true)` `stopOnError`                                                         | `args(stopOnError=true)` `stopOnIssue`                                                         | `args(stopOnIssue=true)` `stopOnSkip`                                                          | `args(stopOnSkip=true)` `sequential`                                                          | `args(sequential=true)` `xonly`                                                               | `args(xonly=true)` `showOnly(status: String)`                                            | `args(showOnly=status)` `fullStackTrace`                                                      | `args.report(traceFilter=NoStackTraceFilter)` `diffs(show, separators, triggerSize, shortenSize, diffRatio, full)`  | `args.report(diffs=SmartDiffs(show, separators, triggerSize, shortenSize, diffRatio, full))`', 'tags':'', 'loc':'org.specs2.guide.ArgumentsReference.html'},
{'title':'Auto-examples', 'text':'When you want to specify an API, most of your examples are self-describing:class SeqSpecification extends mutable.Specification:  "updateLast modifies the last element of a Seq".p  "when the collection has 1 element" >> { Seq(1).updateLast(_ + 1) must ===(Seq(2)) }  "when the collection has 2 elements" >> { Seq(1, 2).updateLast(_ + 1) must ===(Seq(1, 3)) }  "when the collection is empty" >> { Seq[Int]().updateLast(_ + 1) must ===(Seq[Int]()) }It is a bit redundant to provide a textual description for these 3 examples because the code is pretty clear and simple.In this situation you can use the `eg` operator to create an example where the description will be the code itself:class SeqSpecification extends mutable.Specification:  "updateLast modifies the last element of a Seq".p  eg { Seq(1).updateLast(_ + 1) must ===(Seq(2)) }  eg { Seq(1, 2).updateLast(_ + 1) must ===(Seq(1, 3)) }  eg { Seq[Int]().updateLast(_ + 1) must ===(Seq[Int]()) }This prints:[info] updateLast modifies the last element of a Seq[info]  Seq(1).updateLast(_ + 1)     must ===(Seq(2))[info]  Seq(1, 2).updateLast(_ + 1)  must ===(Seq(1, 3))[info]  Seq[Int]().updateLast(_ + 1) must ===(Seq[Int]()) In an acceptance specificationAcceptance specifications are using interpolated strings so you can directly write:class SeqSpecification extends Specification:  def is = s2"""  updateLast modifies the last element of a Seq  ${Seq(1).updateLast(_ + 1) must ===(Seq(2))}  ${Seq(1, 2).updateLast(_ + 1) must ===(Seq(1, 3))}  ${Seq[Int]().updateLast(_ + 1) must ===(Seq[Int]())}  """There is a huge gotcha though! Each of these expressions needs an implicit conversion to be included in the interpolated spec. And in Scala, if you have a block of code returning a value of type `T`, ***only the last expression of the block is converted***. This means that if there is a statement in the block that throws an exception, this exception wont be caught and the whole specification will fail to be instantiated! So if you want to use blocks as auto-examples you should better wrap them with an `eg` call:class SeqSpecification extends Specification:  def is = s2"""  This is a problematic specification  ${ sys.error("ouch, this one is going to blow up the spec"); Seq(1).updateLast(_ + 1) must ===(Seq(2)) }  ${eg { sys.error("its ok, this one is well protected"); Seq(1).updateLast(_ + 1) must ===(Seq(2)) }}  """', 'tags':'', 'loc':'org.specs2.guide.AutoExamples.html'},
{'title':'Datatables', 'text':'DataTables are used to pack several expectations inside one example using a tabular format: class DataTableSpec extends Specification with org.specs2.specification.Tables:  def is = s2"""  adding integers should just work in scala ${// the header of the table, with `|` separated strings (`>` executes the table)    "a" | "b" | "c" |>      2 ! 2 ! 4 | // an example row      1 ! 1 ! 2 | // another example row      { (a, b, c) => a + b must ===(c) } // the expectation to check on each row)  }  """A `DataTable` which is used as a `Result` in the body of an Example will only be displayed when failing. If you also want to display the table when successful, to document your examples, you can omit the example description and inline the DataTable directly in the specification:class DataTableSpec extends Specification with Tables:  def is = s2"""  adding integers should just work in scala  ${"a" | "b" | "c" |>     2 ! 2 ! 4 |     1 ! 1 ! 2 | { (a, b, c) => a + b must ===(c) }}  """This specification will be rendered as:adding integers should just work in scala+  a | b | c |   2 | 2 | 4 |   1 | 1 | 2 | Format columnsThe display of elements can be modified by using an implicit `org.specs2.text.Showx` instance where `x` corresponds tothe number of columns in the table. For example: import org.specs2.text.*given Show3[Int, Double, String] =  Show3[Int, Double, String]().copy(show2 = (d: Double) => "x" * d.toInt)val table =  "a" | "b" | "c" |>    1 ! 2.0 ! "3" |    2 ! 4.0 ! "6" | { (a: Int, b: Double, c: String) => (a + b.toInt).toString === c }"table result\n" + table.message> table result  | a | b    | c | + | 1 | xx   | 3 | + | 2 | xxxx | 6 |  Implicit `!`The datatable DSL uses the `!` operator to define columns. However this operator is also used by the examples DSL to create the body of an example: `"my example is" ! ok`, so if the first column of the datatable contains strings you will not be able to use both at the same time to mean different things ("create a table header" and "create an example").You can solve this conflict by either: - using the `org.specs2.specification.Tables` and `org.specs2.mutable.Tables` traits which will deactivate the example DSL on acceptance and mutable specifications - using the `org.specs2.matcher.DataTables` trait and use `!!` instead of `!` if the first column is a string (for good visual balance you can use `||` in the header) Concurrent executionBy default the execution of a datatable is sequential, one row after another. This might not be very practical if you have long-running computations on each row.If this is the case you can use the `|*` operator (instead of just `|`) to define your execution function:given executionContext: ExecutionContext =  scala.concurrent.ExecutionContext.Implicits.global"a" | "b" | "c" |>  2 ! 2 ! 4 |  1 ! 1 ! 2 |* { (a, b, c) => (a + b) === c }This returns a function `ExecutorService => Result` which can be used directly as the body of an example. You can also pass it your own thread pool by creating, for example, `java.util.concurrent.Executors.newFixedThreadPool(4)`.More generally, you can use the "Applicative" operator `|@` to pass anything having a `org.specs2.fp.Applicative` instance, like a `scala.concurrent.Future`:// this table uses the global execution context implicitly to create futures// scala.concurrent.ExecutionContext.Implicits.globaldef result: scala.concurrent.Future[DecoratedResult[DataTable]] =  "a" | "b" | "c" |>    2 ! 2 ! 4 |    1 ! 1 ! 2 |@ { (a, b, c) => Future((a + b) must ===(c)) }              // then you need to get an implicit execution environment and// await on the Future resultgiven ExecutionEnv = ???result.await', 'tags':'', 'loc':'org.specs2.guide.UseDatatables.html'},
{'title':'Forms', 'text':'Forms are a way to represent domain objects or services, and declare expected values in a tabular format. Forms can be designed as reusable pieces of specification where complex forms can be built out of simple ones.Forms are built by creating `Fields` or `Props` and placing them on rows. The following examples show, by order of complexity, the creation of:  1. fields  1. effects  1. properties  1. a simple Form using properties  1. a simple Address entity encapsulating the above form  1. a composite Customer entity using the Address instance  1. a decision table having some related columns  1. a composite Order - OrderLine entity (1-n) relationshipFor all the code samples below you need to extend the `org.specs2.specification.Forms` trait. FieldsA `Field` is simply a label and a value. It is used in forms to display regular information. You can create a `Field` with these methods:`field(value)` creates a field for a value, where the label is empty`field(label, value)` creates a field with a label and a value`field(label, field1, field2, ...)` creates a field with a label and values coming from other fields, concatenated as stringsWhen the form is displayed, here is how the fields are displayed:  In terms of execution, the value is only evaluated when the `Field` is executed (when executing the parent Form for example). If an exception is thrown during that evaluation, the exception message will be displayed in place of the value. EffectsAn `Effect` is almost like a `Field` but it never shows its value. The value of an `Effect` is supposed to have some kind of side-effect, like clicking on a webpage, and only the effect label will be displayed (except when there is an exception, in that case the exception message is added). You can create an `Effect` with these methods: * `effect(value)` creates an effect with no label * `effect(label, value)` creates an effect with a label and a value that will be evaluated when the `Effect` is executed * `effect(effect1, effect2, ...)` creates an effect with all the effects labels and a side-effect sequencing all side-effects PropertiesA `Prop` is like a `Field`, it has a label. But you can give it 2 values, an "actual" one and an "expected" one. When executing the property, both values are compared to get a result. You can create a `Prop` with the following functions: Expression                                                               | Description ---------------------------------                                        | ------------------------------------------------------------ `prop(value)`                                                            | a property with no label `prop(label, actual)`                                                    | a property with a label and an actual value `prop(label, actual, expected)`                                          | a property with a label, an actual value and an expected one `prop(label, actual, constraint)`                                        | a property with a label, an actual value and a function taking the actual value, an expected one and returning a `Result` `prop("label", "actual", (a: String, b: String) => (a === b))`           | a property with a label, an actual value and a function taking the expected value, returning a Matcher that will be applied to the actual one `prop("label", "expected", (expected: String) => beEqualTo(expected))`   | a property with a label, an actual value and function applying a matcher to that value `prop(label, actual, matcher)`                                           | a property with a label, an actual value and a matcher to apply to that value    If the matcher is `mute`d then no message will be displayed in case of a failure.If the expected value is not provided when building the property, it can be given with the `apply` method:// apply "sets" the expected value    prop1.apply("expected")// or    prop1("expected")Lets look at a few examples: <form>    <table><tr><th colspan="7">Properties</th></tr><tr><td class="info" style="text-align:center"><b>code</b></td><td colspan="5" class="info" style="text-align:center"><b>is displayed as</b></td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;expected&quot;)(&quot;expected&quot;)</code></td><td colspan="5" class="success">expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;expected&quot;, &quot;expected&quot;)</code></td><td style="background-color:#EEEEEE">label</td><td colspan="5" class="success">expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;expected&quot;)(&quot;expected&quot;)</code></td><td style="background-color:#EEEEEE">label</td><td colspan="5" class="success">expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;actual&quot;)(&quot;expected&quot;)</code></td><td style="background-color:#EEEEEE">label</td><td class="failure">actual</td><td colspan="5" class="failure" onclick="showHide(215729790)">actual != expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, { error(&quot;but got an error&quot;); &quot;actual&quot; })(&quot;expected&quot;)</code></td><td style="background-color:#EEEEEE">label</td><td colspan="5" class="error" onclick="showHide(731134604)">java.lang.RuntimeException: but got an error</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;actual&quot;, (a: String, b: String) =&gt; (a === b))(&quot;expected&quot;)</code></td><td style="background-color:#EEEEEE">label</td><td colspan="5" class="success">expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;actual&quot;, (s: String) =&gt; beEqualTo(s))(&quot;expected&quot;)</code></td><td style="background-color:#EEEEEE">label</td><td colspan="5" class="success">expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;actual&quot;, beEqualTo(&quot;expected&quot;))</code></td><td style="background-color:#EEEEEE">label</td><td class="failure">actual</td><td colspan="5" class="failure" onclick="showHide(1504888719)">actual != expected</td></tr><tr><td class="info" style=""><code class="prettyprint">prop(&quot;label&quot;, &quot;actual&quot;, beEqualTo(&quot;expected&quot;).mute)</code></td><td style="background-color:#EEEEEE">label</td><td colspan="5" class="failure">actual</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class="formstacktrace details" id="215729790">      actual != expected (file:1)      <div>org.specs2.execute.Failure$.$lessinit$greater$default$3(Result.scala:382)</div><div>org.specs2.execute.Result$.result(Result.scala:181)</div><div>org.specs2.execute.Result$.result(Result.scala:185)</div><div>org.specs2.execute.Result$.result(Result.scala:189)</div><div>org.specs2.matcher.EqualityMatcher.apply(EqualityMatcher.scala:32)</div><div>org.specs2.form.Prop$.checkProp$$anonfun$1(Prop.scala:139)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>org.specs2.execute.ResultExecution.execute(ResultExecution.scala:27)</div><div>org.specs2.execute.ResultExecution.execute$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.execute(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>scala.Option.map(Option.scala:242)</div><div>org.specs2.form.Prop.$anonfun$1(Prop.scala:58)</div><div>scala.Option.flatMap(Option.scala:283)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:251)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$10(UseForms.scala:111)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div><div class="formstacktrace details" id="731134604">      java.lang.RuntimeException: but got an error (file:1)      <div>scala.sys.package$.error(package.scala:27)</div><div>org.specs2.guide.UseForms$.$anonfun$17(UseForms.scala:95)</div><div>org.specs2.control.Property$.apply$$anonfun$1(Property.scala:95)</div><div>org.specs2.control.Property.execute(Property.scala:76)</div><div>org.specs2.control.Property.optionalValue(Property.scala:26)</div><div>org.specs2.execute.ResultExecution.executeProperty$$anonfun$1(ResultExecution.scala:125)</div><div>org.specs2.execute.ResultExecution.$anonfun$1(ResultExecution.scala:98)</div><div>org.specs2.control.Exceptions.trye(Exceptions.scala:71)</div><div>org.specs2.control.Exceptions.trye$(Exceptions.scala:15)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:106)</div><div>org.specs2.execute.ResultExecution.executeEither(ResultExecution.scala:98)</div><div>org.specs2.execute.ResultExecution.executeEither$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:136)</div><div>org.specs2.execute.ResultExecution.executeProperty(ResultExecution.scala:125)</div><div>org.specs2.execute.ResultExecution.executeProperty$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.actualValue$lzyINIT1(Prop.scala:49)</div><div>org.specs2.form.Prop.actualValue(Prop.scala:49)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:251)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$10(UseForms.scala:111)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div><div class="formstacktrace details" id="1504888719">      actual != expected (file:1)      <div>org.specs2.execute.Failure$.$lessinit$greater$default$3(Result.scala:382)</div><div>org.specs2.execute.Result$.result(Result.scala:181)</div><div>org.specs2.execute.Result$.result(Result.scala:185)</div><div>org.specs2.execute.Result$.result(Result.scala:189)</div><div>org.specs2.matcher.EqualityMatcher.apply(EqualityMatcher.scala:32)</div><div>org.specs2.form.Prop$.apply$$anonfun$3(Prop.scala:127)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>org.specs2.execute.ResultExecution.execute(ResultExecution.scala:27)</div><div>org.specs2.execute.ResultExecution.execute$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.execute(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>scala.Option.map(Option.scala:242)</div><div>org.specs2.form.Prop.$anonfun$1(Prop.scala:58)</div><div>scala.Option.flatMap(Option.scala:283)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:251)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$10(UseForms.scala:111)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div><div class="formstacktrace details" id="519501721">       (file:1)      <div>org.specs2.execute.Failure$.$lessinit$greater$default$3(Result.scala:382)</div><div>org.specs2.execute.Result$.result(Result.scala:181)</div><div>org.specs2.execute.Result$.result(Result.scala:185)</div><div>org.specs2.execute.Result$.result(Result.scala:189)</div><div>org.specs2.matcher.EqualityMatcher.apply(EqualityMatcher.scala:32)</div><div>org.specs2.matcher.Matcher$$anon$12.apply(Matcher.scala:218)</div><div>org.specs2.form.Prop$.apply$$anonfun$3(Prop.scala:127)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>org.specs2.execute.ResultExecution.execute(ResultExecution.scala:27)</div><div>org.specs2.execute.ResultExecution.execute$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.execute(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>scala.Option.map(Option.scala:242)</div><div>org.specs2.form.Prop.$anonfun$1(Prop.scala:58)</div><div>scala.Option.flatMap(Option.scala:283)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:251)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$10(UseForms.scala:111)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div></pre></form> StylesMost of the time, the display of Fields and Properties can be left as it is but sometimes you want to style the output of labels and values. You can do this by using `decorateWith` and `styleWith` methods, or some equivalent shortcuts:  All the methods above, when named `xxx` are available as `xxxLabel` and `xxxValue` to do the formatting for the label or the value only. The available colors are:  Simple formNow that we know how to create Fields and Properties, creating a `Form` is as easy as putting them on separate lines: Form("Address").tr(prop("street", actualStreet(123), "Oxford St")).tr(prop("number", actualNumber(123), 20))The form has a title `"Address"` and 2 properties, each one on a distinct row. The `actualStreet()` and `actualNumber()`methods are supposed to retrieve the relevant values from a database.In some cases (see the Calculator example below) you can create a header row using the `th` method:`th(field("a"), field("b"))`or `th("a", "b")` using an implicit conversion of Any => Field[Any]Inserting the form in a Specification is also very simple: class SpecificationWithForms extends Specification with Forms:  def is = s2"""  The address must be retrieved from the database with the proper street and number    ${Form("Address").tr(prop("street", actualStreet(123), "Oxford St")).tr(prop("number", actualNumber(123), 20))}  """One way to encapsulate and reuse this Form across specifications is to define a case class:case class Address(street: String, number: Int):  def retrieve(addressId: Int) =    val address = actualAddress(addressId)    Form("Address").      tr(prop("street", address.street, street)).      tr(prop("number", address.number, number))And then you can use it like this: class AddressSpecification extends Specification with Forms:  def is = s2"""   The address must be retrieved from the database with the proper street and number    ${Address("Oxford St", 20)        .          /** expected values */        retrieve(123)      /** actual address id        */}  """ Adding several rows at onceA very practical way to add rows programmatically is to start from a list of values and have a function creating a Row object for each value: Form("a new Form").trs(addresses) { (a: ComponentsDefinitions.Address) => Row.tr(field(a.number), field(a.street)) } Nesting into another FormForms can be composed of other Forms to display composite information: val address = Form("Address").tr(field("street", "Rose Crescent")).tr(field("number", 3))val person = Form("Person").tr(field("name", "Eric")).tr(address)This will be displayed with the address as a nested table inside the main one on the last row. However in some case, its preferable to have the rows of that Form to be included directly in the outer table. This can be done by *inlining* thenesting Form: val person = Form("Person").tr(field("name", "Eric")).tr(address.inline) // address is inlinedAnd the result is: Nesting into an Effect or a PropWhen using Forms in specifications we can describe different levels of abstraction. If we consider the specification of a website for example, we want to be able to use a Form having 2 rows and describing the exact actions to do on the Login page: val loginForm = Form("login")  .tr(effect("click on login", clickOn("login")))  .tr(effect("enter name", enter("name", "me")))  .tr(effect("enter password", enter("password", "pw")))  .tr(effect("submit", submit()))However in a "purchase" scenario we want all the steps above to represent the login actions as just one step. One way todo this is to transform the login Form to an Effect or a Prop: Form("purchase")      .tr(loginForm.toEffect("login"))      .tr(selectForm.toEffect("select goods"))      .tr(checkTotalForm.toProp("the total must be computed ok").bkWhiteLabel)If everything goes fine, the detailed nested form is not shown:Otherwise: * if the Form is embedded into an Effect, Errors will be reported * if the Form is embedded into a Prop, Failures will be reported, like that<form>    <table><tr><th colspan="4">purchase</th></tr><tr><td colspan="3" style="" class="info">login</td></tr><tr><td colspan="3" style="" class="info">select goods</td></tr><tr><td style="background-color:#EEEEEE; background-color:#FFFFFF">the total must be computed ok</td><td class="failure">org.specs2.form.Form@193de710</td><td colspan="3" class="failure" onclick="showHide(1827268701)">failed</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class="formstacktrace details" id="1827268701">      failed (file:1)      <div>org.specs2.execute.Failure$.$lessinit$greater$default$3(Result.scala:382)</div><div>org.specs2.form.Form.executedResult$lzyINIT1$1(Form.scala:148)</div><div>org.specs2.form.Form.executedResult$1(Form.scala:150)</div><div>org.specs2.form.Form.toProp$$anonfun$3(Form.scala:153)</div><div>org.specs2.control.Property$.apply$$anonfun$1(Property.scala:95)</div><div>org.specs2.control.Property.execute(Property.scala:76)</div><div>org.specs2.control.Property.optionalValue(Property.scala:26)</div><div>org.specs2.execute.ResultExecution.executeProperty$$anonfun$1(ResultExecution.scala:125)</div><div>org.specs2.execute.ResultExecution.$anonfun$1(ResultExecution.scala:98)</div><div>org.specs2.control.Exceptions.trye(Exceptions.scala:71)</div><div>org.specs2.control.Exceptions.trye$(Exceptions.scala:15)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:106)</div><div>org.specs2.execute.ResultExecution.executeEither(ResultExecution.scala:98)</div><div>org.specs2.execute.ResultExecution.executeEither$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:136)</div><div>org.specs2.execute.ResultExecution.executeProperty(ResultExecution.scala:125)</div><div>org.specs2.execute.ResultExecution.executeProperty$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.expectedValue$lzyINIT1(Prop.scala:52)</div><div>org.specs2.form.Prop.expectedValue(Prop.scala:52)</div><div>org.specs2.form.Prop.$anonfun$1(Prop.scala:58)</div><div>scala.Option.flatMap(Option.scala:283)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:247)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$65(UseForms.scala:269)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div></pre></form> Using tabsIf there are too many fields to be displayed on a Form you can use tabs: s2"""A person can have 2 addresses ${Form("Addresses").tr {      tab("home", Address("Oxford St", 12).fill("Oxford St", 12))        .tab("work", Address("Rose Cr.", 3).fill("Rose Cr.", 3))}}"""The first `tab` call will create a `Tabs` object containing the a first tab with "home" as the title and an Address form as its content.Then every subsequent `tab` calls on the `Tabs` object will create new tabs:Tabs can also be created from a seq of values. Lets pretend we have a list of `Address` objects with a name and a Form displaying the `Address` values. You can write: Form("Addresses").tabs(addresses) { (address: Address) => tab(address.street, address.form) } Aggregating formsNow that weve defined a form for a simple entity, lets see how we can reuse it with a larger entity: * the Customer form defines a name attribute and embeds an instance of the Address form * it is defined by setting the name on one row and the Address form on the second row*[and for this example, we define a slightly different Address form]*case class Address(street: String, number: Int):  def actualIs(address: Address) =    Form("Address").      tr(prop("street", address.street, street)).      tr(prop("number", address.number, number))case class Customer(name: String, address: Address):  def retrieve(customerId: Int) =    val customer = actualCustomer(customerId)    Form("Customer").      tr(prop("name", customer.name)(name)).      tr(address.actualIs(customer.address))  def actualCustomer(customerId: Int): Customer = this // fetch from the databaseclass CustomerSpecification extends Specification with Forms:  def is = s2"""  The customer must be retrieved from the database with a proper name and address ${Customer(        name = "Eric",        address = Address(street = "Rose Crescent", number = 2)      ).retrieve(123)}  """As you also see above, named arguments can bring more readability to the expected values. Lazy cellsFields, Props and Forms are added right away to a row when building a Form with the `tr` method. If it is necessary to add them with a "call-by-name" behavior, the `lazify` method can be used: def address = Address() // build an Addressdef customer = Customer()Form("Customer")  .tr(prop("name", customer.name)("name"))  .  // the address Form will be built only when the Customer Form is rendered  tr(lazify(address.actualIs(customer.address))) Xml cellsAny xml can be "injected" on a row by using an `XmlCell`: def actualAddress(i: Int) = addresses(0)Form("Customer").tr(prop("name", Customer().name)("name")).tr(XmlCell(<div><b>this is a bold statement</b></div>)) 1-n relationshipsWhen there are 1 - n relationships between entities the situation gets bit more complex.For example you can have an "Order" entity, which has several "OrderLines". In that case there are several things that we might want to specify: * the expected rows are included in the actual rows, with no specific order (this is the usual case) * the expected rows are included in the actual rows, in the same order * the expected rows are exactly the actual rows, with no specific order * the expected rows are exactly the actual rows, in the same orderLets see how to declare this. The 2 classes were going to use are:import Form.*case class Order(orderId: Int):  lazy val actualLines = // those should be extracted from the actual order entity retrieved by id    OrderLine("PIS", 1) ::      OrderLine("PS", 2) ::      OrderLine("BS", 3) ::      OrderLine("SIS", 4) ::      Nil  def base = Forms.form("Order").th("name", "qty")  def hasSubset(ls: OrderLine*)      = base.subset(actualLines, ls)  def hasSubsequence(ls: OrderLine*) = base.subsequence(actualLines, ls)  def hasSet(ls: OrderLine*)         = base.set(actualLines, ls)  def hasSequence(ls: OrderLine*)    = base.sequence(actualLines, ls)case class OrderLine(name: String, quantity: Int):  def form: Form =    tr(field(name), field(quantity))The `OrderLine` class simply creates a form with 2 fields: name and quantity. The `Order` class is able to retrieve the actual order entity (say, from a database) and to extract `OrderLine` instances.It also has several methods to build Forms depending on the kind of comparison that we want to do. Subset`Form.subset` uses the `FormDiffs.subset(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are left untouched * lines existing in `a` and `b` are marked as success * lines existing in `b` and not `a` are marked as failuresOrder(123).hasSubset(OrderLine("BS", 3), OrderLine("PIS", 1), OrderLine("TDGL", 5))This form returns:<form>    <table><tr><th colspan="7">Order</th></tr><tr><td class="info" style="text-align:center; background-color:#EEEEEE"><b>name</b></td><td colspan="5" class="info" style="text-align:center; background-color:#EEEEEE"><b>qty</b></td></tr><tr><td class="success" style="">PIS</td><td colspan="5" class="success" style="">1</td></tr><tr><td class="info" style="">PS</td><td colspan="5" class="info" style="">2</td></tr><tr><td class="success" style="">BS</td><td colspan="5" class="success" style="">3</td></tr><tr><td class="info" style="">SIS</td><td colspan="5" class="info" style="">4</td></tr><tr><td class="failure" style="">TDGL</td><td colspan="5" class="failure" style="">5</td></tr></table></form> Subsequence`Form.subsequence` uses the `FormDiffs.subsequence(a, b)` method to calculate the differences and add them to the Form: * lines existing in `a` but not `b` are left untouched * lines existing in `a` and `b` in the same order are marked as success * lines existing in `b` and not `a` are marked as failures * lines existing in `b` and `a` but out of order are marked as failuresOrder(123).hasSubsequence(OrderLine("PS", 2), OrderLine("BS", 3), OrderLine("PIS", 1), OrderLine("TDGL", 5))This form returns:<form>    <table><tr><th colspan="7">Order</th></tr><tr><td class="info" style="text-align:center; background-color:#EEEEEE"><b>name</b></td><td colspan="5" class="info" style="text-align:center; background-color:#EEEEEE"><b>qty</b></td></tr><tr><td class="failure" style="">PIS</td><td colspan="5" class="failure" style="">1</td></tr><tr><td class="success" style="">PS</td><td colspan="5" class="success" style="">2</td></tr><tr><td class="success" style="">BS</td><td colspan="5" class="success" style="">3</td></tr><tr><td class="info" style="">SIS</td><td colspan="5" class="info" style="">4</td></tr><tr><td class="failure" style="">TDGL</td><td colspan="5" class="failure" style="">5</td></tr></table></form> Set`Form.set` uses the `FormDiffs.set(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are marked as failures * lines existing in `a` and `b` are marked as success * lines existing in `b` and not `a` are marked as failuresOrder(123).hasSet(OrderLine("BS", 3), OrderLine("PIS", 1), OrderLine("TDGL", 5))This form returns:<form>    <table><tr><th colspan="7">Order</th></tr><tr><td class="info" style="text-align:center; background-color:#EEEEEE"><b>name</b></td><td colspan="5" class="info" style="text-align:center; background-color:#EEEEEE"><b>qty</b></td></tr><tr><td class="success" style="">PIS</td><td colspan="5" class="success" style="">1</td></tr><tr><td class="failure" style="">PS</td><td colspan="5" class="failure" style="">2</td></tr><tr><td class="success" style="">BS</td><td colspan="5" class="success" style="">3</td></tr><tr><td class="failure" style="">SIS</td><td colspan="5" class="failure" style="">4</td></tr><tr><td class="failure" style="">TDGL</td><td colspan="5" class="failure" style="">5</td></tr></table></form> Sequence`Form.sequence` uses the `FormDiffs.sequence(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are marked as failures * lines existing in `a` and `b` in the right order are marked as success * lines existing in `b` and not `a` are marked as failuresOrder(123).hasSequence(OrderLine("PS", 2), OrderLine("BS", 3), OrderLine("PIS", 1), OrderLine("TDGL", 5))This form returns:<form>    <table><tr><th colspan="7">Order</th></tr><tr><td class="info" style="text-align:center; background-color:#EEEEEE"><b>name</b></td><td colspan="5" class="info" style="text-align:center; background-color:#EEEEEE"><b>qty</b></td></tr><tr><td class="failure" style="">PIS</td><td colspan="5" class="failure" style="">1</td></tr><tr><td class="success" style="">PS</td><td colspan="5" class="success" style="">2</td></tr><tr><td class="success" style="">BS</td><td colspan="5" class="success" style="">3</td></tr><tr><td class="failure" style="">SIS</td><td colspan="5" class="failure" style="">4</td></tr><tr><td class="failure" style="">TDGL</td><td colspan="5" class="failure" style="">5</td></tr></table></form> Decision tablesOne very popular type of Forms are *decision tables*. A decision table is a Form where, on each row, several values are used for a computation and the result must be equal to other values on the same row.A very simple example of this is a calculator: case class Calculator(form: Form = Form()):  def tr(a: Int, b: Int, a_plus_b: Int, a_minus_b: Int) = Calculator {    def plus = prop(a + b)(a_plus_b)    def minus = prop(a - b)(a_minus_b)    form.tr(a, b, plus, minus)  }def th(title1: String, titles: String*): Calculator =  Calculator(Form.th(title1, titles*))The `Calculator` object defines a `th` method to create the first `Calculator` Form, with the proper title. The `th` method: * takes the column titles (there must be at least one title) * creates a header row on the form * returns a new Calculator containing this form (note that everything is immutable here)The `Calculator` case class embeds a Form and defines a `tr` method which * takes actual and expected values * creates properties for the computations * creates a form with a new row containing those fields and properties * returns a new Calculator containing this formAnd you use the `Calculator` Form like this: class CalculatorSpecification extends Specification with Forms:  def is = s2"""  A calculator must add and subtract Ints ${Calculator.th("a", "b", "a + b", "a - b").tr(1, 2, 3, -1).tr(2, 2, 4, 0)}  """Here is the output:And if something goes wrong:<form>    <table><tr><td class="info" style="text-align:center; background-color:#EEEEEE"><b>a</b></td><td class="info" style="text-align:center; background-color:#EEEEEE"><b>b</b></td><td class="info" style="text-align:center; background-color:#EEEEEE"><b>a + b</b></td><td colspan="9" class="info" style="text-align:center; background-color:#EEEEEE"><b>a - b</b></td></tr><tr><td class="info" style="">1</td><td class="info" style="">2</td><td class="success">3</td><td colspan="9" class="success">-1</td></tr><tr><td class="info" style="">2</td><td class="info" style="">2</td><td class="success">4</td><td class="failure">0</td><td colspan="9" class="failure" onclick="showHide(1477601177)">0 != 2</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class="formstacktrace details" id="1477601177">      0 != 2 (file:1)      <div>org.specs2.execute.Failure$.$lessinit$greater$default$3(Result.scala:382)</div><div>org.specs2.execute.Result$.result(Result.scala:181)</div><div>org.specs2.execute.Result$.result(Result.scala:185)</div><div>org.specs2.execute.Result$.result(Result.scala:189)</div><div>org.specs2.matcher.EqualityMatcher.apply(EqualityMatcher.scala:32)</div><div>org.specs2.form.Prop$.checkProp$$anonfun$1(Prop.scala:139)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>org.specs2.execute.ResultExecution.execute(ResultExecution.scala:27)</div><div>org.specs2.execute.ResultExecution.execute$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.execute(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.$anonfun$1$$anonfun$1(Prop.scala:59)</div><div>scala.Option.map(Option.scala:242)</div><div>org.specs2.form.Prop.$anonfun$1(Prop.scala:58)</div><div>scala.Option.flatMap(Option.scala:283)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:251)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$78(UseForms.scala:542)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div></pre></form>And when it goes *very* wrong (like throwing an `error("very wrong")`), there will be red cells and stacktraces:<form>    <table><tr><td class="info" style="text-align:center; background-color:#EEEEEE"><b>a</b></td><td class="info" style="text-align:center; background-color:#EEEEEE"><b>b</b></td><td class="info" style="text-align:center; background-color:#EEEEEE"><b>a + b</b></td><td colspan="9" class="info" style="text-align:center; background-color:#EEEEEE"><b>a - b</b></td></tr><tr><td class="info" style="">1</td><td class="info" style="">2</td><td class="success">3</td><td colspan="9" class="success">-1</td></tr><tr><td class="info" style="">2</td><td class="info" style="">2</td><td class="success">4</td><td colspan="9" class="error" onclick="showHide(1099260976)">java.lang.RuntimeException: very wrong</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class="formstacktrace details" id="1099260976">      java.lang.RuntimeException: very wrong (file:1)      <div>scala.sys.package$.error(package.scala:27)</div><div>org.specs2.guide.UseForms$.org$specs2$guide$UseForms$WrongCalculator$$_$minus$3$$anonfun$3(UseForms.scala:590)</div><div>org.specs2.control.Property$.apply$$anonfun$1(Property.scala:95)</div><div>org.specs2.control.Property.execute(Property.scala:76)</div><div>org.specs2.control.Property.optionalValue(Property.scala:26)</div><div>org.specs2.execute.ResultExecution.executeProperty$$anonfun$1(ResultExecution.scala:125)</div><div>org.specs2.execute.ResultExecution.$anonfun$1(ResultExecution.scala:98)</div><div>org.specs2.control.Exceptions.trye(Exceptions.scala:71)</div><div>org.specs2.control.Exceptions.trye$(Exceptions.scala:15)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:106)</div><div>org.specs2.execute.ResultExecution.executeEither(ResultExecution.scala:98)</div><div>org.specs2.execute.ResultExecution.executeEither$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:136)</div><div>org.specs2.execute.ResultExecution.executeProperty(ResultExecution.scala:125)</div><div>org.specs2.execute.ResultExecution.executeProperty$(ResultExecution.scala:15)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:136)</div><div>org.specs2.form.Prop.actualValue$lzyINIT1(Prop.scala:49)</div><div>org.specs2.form.Prop.actualValue(Prop.scala:49)</div><div>org.specs2.form.Prop.execute(Prop.scala:57)</div><div>org.specs2.form.PropCell.executeCell$$anonfun$3(Cells.scala:155)</div><div>scala.Option.orElse(Option.scala:477)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:155)</div><div>org.specs2.form.Row.executeRow$$anonfun$1(Row.scala:43)</div><div>scala.collection.immutable.List.map(List.scala:251)</div><div>org.specs2.form.Row.executeRow(Row.scala:43)</div><div>org.specs2.form.Form.executeRows$$anonfun$1(Form.scala:87)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:2155)</div><div>scala.collection.immutable.Vector1.map(Vector.scala:386)</div><div>org.specs2.form.Form.executeRows(Form.scala:87)</div><div>org.specs2.form.Form.executeForm(Form.scala:96)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1$$anonfun$79(UseForms.scala:546)</div><div>org.specs2.specification.create.S2StringContext$$anon$4.prepend(S2StringContext.scala:58)</div><div>org.specs2.specification.create.S2StringContext$.$anonfun$1(S2StringContext.scala:132)</div><div>scala.collection.immutable.ArraySeq.foldLeft(ArraySeq.scala:222)</div><div>org.specs2.specification.core.Fragments$.reduce(Fragments.scala:139)</div><div>org.specs2.specification.create.S2StringContext$.s2(S2StringContext.scala:130)</div><div>org.specs2.guide.UseForms$.is$$anonfun$1(UseForms.scala:11)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.map$$anonfun$1(SpecStructure.scala:26)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzyINIT1(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:23)</div><div>org.specs2.specification.core.SpecStructure$.selected(SpecStructure.scala:168)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:157)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecifications$$anonfun$1(SpecStructure.scala:110)</div><div>org.specs2.specification.core.SpecStructure$.getRefs$1(SpecStructure.scala:129)</div><div>org.specs2.specification.core.SpecStructure$.$anonfun$3(SpecStructure.scala:144)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap(StrictOptimizedIterableOps.scala:118)</div><div>scala.collection.StrictOptimizedIterableOps.flatMap$(StrictOptimizedIterableOps.scala:105)</div><div>scala.collection.immutable.Vector.flatMap(Vector.scala:116)</div><div>org.specs2.specification.core.SpecStructure$.getAll$1(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$.specStructuresRefs$$anonfun$1(SpecStructure.scala:148)</div><div>org.specs2.control.Operation$.org$specs2$control$Operation$OperationMonad$$$_$point$$anonfun$1(Operation.scala:133)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.attempt$$anonfun$1(Operation.scala:87)</div><div>org.specs2.control.Operation.org$specs2$control$Operation$$run(Operation.scala:18)</div><div>org.specs2.control.Operation.$anonfun$1(Operation.scala:94)</div><div>org.specs2.control.Action$.either(Action.scala:120)</div><div>org.specs2.control.Operation.toAction(Operation.scala:94)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:43)</div><div>org.specs2.runner.DefaultClassRunner.run(ClassRunner.scala:37)</div><div>org.specs2.Website.createUserGuide$$anonfun$1(Website.scala:57)</div><div>org.specs2.control.Action.flatMap$$anonfun$1$$anonfun$1(Action.scala:30)</div><div>scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)</div><div>java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1395)</div><div>java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</div><div>java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</div><div>java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</div><div>java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</div><div>java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</div>    </div></pre></form>Note that the Calculator class is not, in itself an Example. But there is an implicit definition automatically transforming `Any { def form: Form }` to `Example`so that an explicit call to `.form` is not necessary in order to include the Form in the specification.', 'tags':'', 'loc':'org.specs2.guide.UseForms.html'},
{'title':'Create online specifications', 'text':' Most of the specifications we write are known up front because this is precisely what guides the construction of our systems. But sometimes data comes first and drives what we can do with the system. For example we want to check that:  1. all the Wikipedia pages mentioning the term "BDD" are referencing specs2  2. if there is a specs2 link on the page, the linked page must existMore precisely we want to create one example for `1.` and if it succeeds, create as many examples as there are links in `2.`.This can be done with the `org.specs2.specification.dsl.Online` trait and the `continueWith` method: // fill in the definitions belowobject Wikipedia:  def getPages(searchTerm: String): Seq[Page] = ???trait Page:  def getLinks: Seq[HtmlLink] = ???trait HtmlLink:  def contains(name: String): Boolean = ???  def getName: String = ???  def getLinkedPage: Page = ???class WikipediaBddSpec extends Specification with Online:  def is = s2"""    All the pages mentioning the term BDD must contain a reference to specs2 $e1  """  def e1 =    val pages = Wikipedia.getPages("BDD")    { pages must contain((_: Page) must mention("specs2")) } continueWith      pagesSpec(pages)  def pagesSpec(pages: Seq[Page]): Fragments =    val specs2Links = pages.flatMap(_.getLinks).filter(_.contains("specs2"))    s2"""    The specs2 links must all be active    ${Fragments.foreach(specs2Links)(isActive)}    """  def isActive(link: HtmlLink) =    s2"""    The page at ${link.getName}      must be active ${link must beActive}"""  // implement these matchers  def mention(name: String): Matcher[Page] = ???  def beActive: Matcher[HtmlLink] = ???In the specification above, if we succeed in checking each BDD page then we continue with the creation of individual examples for each encountered link.', 'tags':'', 'loc':'org.specs2.guide.CreateOnlineSpecifications.html'},
{'title':'Environment', 'text':'The execution of a Specification depends on various parts, among which: - the command line arguments - an `ExecutorService` for concurrent execution - a "StatisticsRepository" to access previous results - a "Logger" to log results to the console - an interface for the file system<p/>All of this is bundled into one object `org.specs2.specification.core.Env`. The `Env` is accessible to your Specification by either: - having it injected as a Specification member - extending a trait Dependency injectionThe following objects can be injected in your specification if you declare a 1-parameter constructor:  - the `Env` itself  - the `Arguments` object  - the `CommandLine` object  - the `ExecutionEnv` object (can be implicit)  - the `ExecutionContext` object (can be implicit)<p/>For example: class MySpec(env: Env) extends Specification:  def is = s2"""  Use the environment fileSystem  ${ env.fileSystem.mkdirs("tmp" / "test").runOption; ok }  """Or if you want to access an `ExecutionContext`:class MySpec(using ec: ExecutionContext) extends Specification:  def is = s2"""    Use a future    ${Await.result(Future(1), 1.seconds) must ===(1)})  """ Own Env / ExecutionEnvironmentThe `ExecutionEnv` which is injected in a specification will be shared with all specifications. If you want to providesome isolation between your specifications and get a specific thread pool being dedicated to your specification you usethe `org.specs2.specification.core.OwnEnv` or `org.specs2.specification.core.OwnExecutionEnv` traits:class MySpec extends Specification with OwnExecutionEnv:  def is = s2"""    Use a future    ${Await.result(Future(1), 1.seconds) must ===(1)})  """You need to inject a public `env` which will be duplicated to create an implicit `ExecutionEnv` for the sole use of yourspecification (and shutdown when your specification has been executed). Doing so ensures that command line argumentsinfluencing the execution of your specification, like `threadsnb` or `timefactor` will be used.<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - use specs2  in a Specification </div>', 'tags':'', 'loc':'org.specs2.guide.Environment.html'},
{'title':'Execution environment', 'text':'When you run a specification, a `java.util.concurrent.ExecutorService` is used to execute examples concurrently.You can access this `ExecutorService` to execute futures (from Scala, Scalaz etc...), by converting it to the kind of "Execution context" required by your Future implementation. Scala FutureA Scala `Future` needs an implicit `ExecutionContext` to be created. You can get an execution context, out of the box, shared across allspecifications by declaring it as a class member: class MyFutureSpec(using ec: ExecutionContext) extends Specification:  def is = s2"""    Lets check this scala future ${Await.result(Future(1), Duration.Inf) must ===(1)}  """// in a mutable specificationclass MyMutableFutureSpec(using ec: ExecutionContext) extends mutable.Specification:  "Lets check this scala future" >> {    Await.result(Future(1), Duration.Inf) must ===(1)  }You can also use an `ExecutionEnv` (from now on code examples are provided for immutable specifications only but are transposable to mutable ones): class MyFutureSpec(using ee: ExecutionEnv) extends Specification:  def is = s2"""    Lets check this scala future ${Await.result(Future(1), Duration.Inf) must ===(1)}  """This works thanks to an implicit conversion between `ExecutionEnv` and `ExecutionContext` provided by the`org.specs2.execute.ImplicitExecutionContextFromExecutionEnv` trait(this can be deactivated by mixing-in the `NoImplicitExecutionContextFromExecutionEnv` trait).It is actually better to use an `ExecutionEnv` anyway because it is required when you want to  (see the "Future" tab).Indeed an `ExecutionEnv` contains a `timeFactor` which can be used to modify the timeout from the command line andwait longer for Futures executing on a continuous integration server for example. With matchersFuture  (see the "Future" tab) require an implicit `ExecutionEnv`. This environment is used to access the `timeFactor` when awaiting for Scala Futures.The `terminate` matcher (see the "Termination" tab in the optional  section) also needs an `ExecutionEnv` to run a piece of code and periodicallycheck if it has terminated or not: s2"""  this code must be fast enough ${      given ExecutionEnv = ExecutionEnv.fromGlobalExecutionContext      Thread.sleep(100) must terminate(retries = 1, sleep = 60.millis)  }""" One per specificationIf you want to have exactly one `Env` or one `ExecutionEnv` per `Specification` you can mix-in the `org.specs2.specicication.core.OwnEnv`or the `org.specs2.specicication.core.OwnExecutionEnv` traits. You will then get a specific thread pool instantiated andshutdown just for the execution of one specification. See the  page for more information.<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - use specs2  in a Specification</div>', 'tags':'', 'loc':'org.specs2.guide.ExecutionEnvironments.html'},
{'title':'Fragments API', 'text':'In specs2 a specification can simply be viewed as a sequence of "Fragments". A `Fragment` is something which has: - a `Description` - an `Execution`All the elements encountered in this User Guide fall under this representation: - an `Example` is a `Fragment` with a `Text` description and an `Execution` returning a `Result` - a `Step` is a `Fragment` with no description and a special `Execution` declaring that everything before the step must be executed before the `Step` is executed - a `Text` is a `Fragment` with a `Text` description and no `Execution`The role of the various DSLs in acceptance and unit specifications is to create those fragments and assemble them into a bigger `Fragments` object. They do this using: - the `FragmentFactory` API to create individual fragments - the `Fragments` API to assemble them The `FragmentFactory` APIThe `org.specs2.specification.create.FragmentFactory` trait possesses different methods to create: - texts - examples - steps / actions - tags - references - "formatting" fragments (break, paragraph, tab...)Please have a look at the ScalaDoc to see the exact API for the factory and look at the source code for the default implementation in `org.specs2.specification.create.DefaultFragmentFactory`. The `Fragments` APIIf you know how to create examples, texts and steps you will need to append them together as `Fragments`. You can create a `Fragments` object by using `Fragments.apply`:val ff = fragmentFactoryFragments(ff.text("introduction"), ff.example("first example", success), ff.break)Then you can use the methods of the `org.specs2.specification.core.Fragments` class to add more fragments or to modify existing ones: Method                                          | Description --------------------------                      | -------------------------------- `append(f: Fragment)`                           | to append a single fragment `append(fs: Fragments)`                         | to append another `Fragments` object `prepend(...)`                                  | to do the same as above but prepending instead of appending `append(fs: Seq[Fragment])`                     | to append a sequence `filter(f: Fragment => Boolean)`                | to filter out some fragments `map(f: Fragment => Fragment)`                  | to modify each fragment `mapDescription(f: Description => Description)` | to just modify the descriptions The `Fragments` DSLThe `org.specs2.specification.dsl.FragmentsDsl` trait provides a very versatile `` operator to append fragments together, so you can write:val ff = fragmentFactoryval fs = Fragments(ff.text("introduction"), ff.example("first example", success), ff.break)val f1 = ff.text("f1")// all those combinations are possible and return a `Fragment` objectfs  f1f1  fsfs  fsf1  f1', 'tags':'', 'loc':'org.specs2.guide.FragmentsApi.html'},
{'title':'Get all expectations', 'text':'The 2 main modes of expectations in specs2 are:  - No thrown expectations  - thrown expectationsThey correspond to different style of declaring expectations and you will use one or the other depending on how many expectations you have per example.The `org.specs2.specification.AllExpectations` trait goes further and gives you the possibility to report _all_ the failures of an Example without stopping at the first failure.This enables a type of specification where it is possible to define lots of expectations inside the body of an example and get a maximum of information on what fails and what passes: import org.specs2.specification.AllExpectationsimport org.specs2.mutable.Specificationclass AllExpectationsSpec extends Specification with AllExpectations:  "In this example all the expectations are evaluated" >> {    1 === 2 // this fails    1 === 3 // this also fails    1 === 1  }  "There is no collision with this example" >> {    10 === 11 // this fails    12 === 12    13 === 31 // this also fails  }The second example above hints at a restriction for this kind of Specification. The failures are accumulated for each example by mutating a shared variable."Mutable" means that the concurrent execution of examples will be an issue if done blindly. To avoid this, the `AllExpectations` trait overrides the `Specification` arguments to make it  (unless it already is).', 'tags':'', 'loc':'org.specs2.guide.GetAllExpectations.html'},
{'title':'Other build tools', 'text':'The most straightforward way to run specs2 specifications is to use [sbt](http://scala-sbt.org).However other build tools such as Maven and Gradle can be used too (please refer to the  guide for instructions on how to set-up projects for those tools). MavenWith Maven you need to use the [Surefire](http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html) plugin and the `test` command.(make sure that both the `specs2-junit` and the `org.junit.platform.junit-platform-engine` jars on your classpath) GradleWith Gradle the [`test`](http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.testing.Test.html) task will run your specification as a JUnit test suite.', 'tags':'', 'loc':'org.specs2.guide.OtherBuildTools.html'},
{'title':'Outside specs2', 'text':'The specs2 matchers are a well-delimited piece of functionality that you should be able to reuse in your own test framework. You can reuse the following traits: * `org.specs2.matcher.MustMatchers` (or `org.specs2.matcher.ShouldMatchers`) to write anything like `1 must be_==(1)` and   get a `Result` back * **Important**: the `MustMatchers` *trait* will fill-in stacktraces on `MatchResults` to mark the location of a result while the `MustMatchers` object will not. This has some important consequences in terms of performances because creating stack traces is expensive * You can also use the side-effecting version of that trait called `org.specs2.matcher.MustThrownMatchers` (or `org.specs2.matcher.ShouldThrownMatchers`).   It throws a `FailureException` as soon as an expectation is failing * Finally, in a JUnit-like library you can use the `org.specs2.matcher.JUnitMustMatchers` trait which throws `AssertionFailureError`s Without any dependency on specs2It is possible to add testing features to your library without depending on a specific testing library, like specs2 or ScalaTest.You will let clients of your library decide which one they want with the following trait:trait TestInterface:  def fail(msg: String): Nothing  def skip(msg: String): Nothing// and use the trait in your librarytrait TestKit extends TestInterface:  def runTest(call: =>Unit) =    // run the code and if there is an error    fail("error!")When there is a failure or an error the library will call the `TestKit` methods. Then the library client can use both the library and specs2 by mixing in the`org.specs2.matcher.ThrownMessages` trait:trait ThrownMessages:  this: ThrownExpectations =>  def fail(m: String): Nothing = failure(m)  def skip(m: String): Nothing = skipped(m)class MySpec extends Specification with TestKit with ThrownMessages:  def is = s2"""  An example using the TestKit $e1  """  def e1 =    // do something with the library    runTest(...)', 'tags':'', 'loc':'org.specs2.guide.matchers.OutsideSpecs2.html'},
{'title':'Reference card', 'text':' EqualityThe most common type of matcher is `beEqualTo` to test the equality of 2 values with the underlying `==` operator where: - the compared types must be the same (as if the `language:strictEquality` option has been turned on) - the comparison of `Arrays` uses the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested)   Otherwise `==` on arrays uses the reference equality, so that `Array(1, 2, 3) === Array(1, 2, 3)`, despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`Several syntaxes can be used, according to your own taste Matcher                    |  Comment -------------------------- | -------------------------- `1 must beEqualTo(1)      `| the normal way `1 must be_==(1)          `| with a symbol `1 should be_==(1)        `| for should lovers `1 === 1                  `| the ultimate shortcutThere are also other notions of equality: Matcher            |  Comment ----------         | ----------------------------------------------------- `be_==~           `| check if `(a: A) === conversion(b: B)` when there is an implicit conversion `Conversion[B, A]` `beTheSameAs      `| reference equality: check if `a eq b` (`a must be(b)` also works) `be               `| `a must be(b)`: synonym for `beTheSameAs` `beTrue, beFalse  `| shortcuts for Boolean equality `beLike           `| partial equality, using a `PartialFunction[T, Result]`: `(1, 2) must beLike { case (1, _) => ok }` Out of the boxThese are the all the available matchers when you extend `Specification` OptionalThose matchers are optional. To use them, you need to add a new trait to your specification:', 'tags':'', 'loc':'org.specs2.guide.matchers.ReferenceCard.html'},
{'title':'Specification formatting', 'text':'Acceptance specifications are displayed in the console almost as they are in `.scala` files thanks to interpolated strings. However it is not obvious to know how to change the display of a unit specification. How do you add a new line after an example? After the specification title? How do you indent a group of examples a bit more?First of all, you can always add a piece text by using the `txt` method on a `String`:class UnitSpec extends mutable.Specification:  """  This is a long and important introduction to this specification.  The examples below show everything you can do with the system.  """.txtThen if you want to add new lines you can use: - `br` ("break") to add a newline after any fragment, text, example... - `p` ("paragraph") to make a new paragraph with a break before and 2 afterTexts, or blocks of examples can also get a special indentation by using the `tab` and `backtab` methods:class UnitSpec extends mutable.Specification:  """  This is a long and important introduction to this specification.  """.txt    """  The examples below show everything you can do with the system.  """.txt.tab(3) // indent the text with 3 tabs compared to the previous text', 'tags':'', 'loc':'org.specs2.guide.SpecificationFormatting.html'},
{'title':'Reference other specifications', 'text':'For some large projects, or to write documentation, you will need to structure your specifications so that some of them will reference others. Those references will be of 2 types: - "see" reference: a simple textual reference, with an html link to navigate to the other specification when you create an html report - "link" reference: an "executed" reference where the second specification will be executed and its status reported in the first oneHere is the DSL you will use for those 2 types of references:object FirstSpecification extends Specification:  def is = s2"""  We can consider one example  ${1 must ===(1)})  And all these examples are also important so we need to know if they all pass  ${"important specification" ~ SecondSpecification}  Finally it is worth having a look at ${"this specification" ~/ ThirdSpecification}.  """import org.specs2.specification.core.*object SecondSpecification extends Specification:  def is = s2"""   This spec contains lots of examples   ${Fragment.foreach(1 to 100) { i => "example " + i ! ok }}  """object ThirdSpecification extends Specification:  def is = s2"""    This is the third specification with a simple example    this should pass $ok  """The syntax shown above to create references is using a string for the link alias and uses two operators: Operator  | Description ---       | -------------------- `~`       | a *`link` reference*. The referenced specification gets executed when the first one is `~/`      | a *`see` reference*. The referenced specification doesnt get executed (`"$FirstSpecification"` creates a *see* link as well)Also, for better html rendering, you can add a tooltip:class s extends Specification:  def is = s2"""    ${"alias".~/(OtherSpec, "tooltip")}  """Finally Im also drawing your attention to the fact that you dont have to create your specifications as Scala classes but you can use simple objects as shown above. ReportingBy default specification links are reported with a status icon in HTML pages. You can change this by using the following methods: - `link(MySpec).hide` doesnt show the link at all. This is useful when you want a children specification to be executed from a parent one without having to mention it - `link(MySpec).mute` doesnt show the link status. This is useful when you want a children specification to be executed from a parent one but just display its html link ExecutionWhen you execute a given specification you can pass the `all` argument to execute all the referenced specifications.They will be collected and executed in (topological sort)[http://en.wikipedia.org/wiki/Topological_sorting] order and any cycle in the reference graph will be broken.Only the "link" references will be executed, not the "see" references.', 'tags':'', 'loc':'org.specs2.guide.ReferenceOtherSpecifications.html'},
{'title':'Quick Start', 'text':'Follow the  instructions and create the following specification in a file named `HelloWorldSpec.scala`: import org.specs2.*class HelloWorldSpec extends Specification:  def is = s2"""This is a specification to check the Hello world stringThe Hello world string should  contain 11 characters $e1  start with Hello $e2  end with world $e3  """  def e1 = "Hello world" must haveSize(11)  def e2 = "Hello world" must startWith("Hello")  def e3 = "Hello world" must endWith("world")A specs2 software specification is a Scala class extending `org.specs2.Specification` and declaring an `is` method.That method defines a `s2` interpolated string with some plain text describing what the system should doand some code with executable examples. Unit specificationsThe style of writing specifications above, with most of the text first, then executable examples, is unconventional.You can, if you prefer, use an alternative style: // note the different import hereimport org.specs2.mutable.*class HelloWorldSpec extends Specification:  "This is a specification to check the Hello world string".br  "The Hello world string should" >> {    "contain 11 characters" >> {      "Hello world" must haveSize(11)    }    "start with Hello" >> {      "Hello world" must startWith("Hello")    }    "end with world" >> {      "Hello world" must endWith("world")    }  }Both specifications will produce the same output. ExecutionAnd this is it! Now you can execute your specification with a [*runner*](org.specs2.guide.Runners.html#Presentation) and observe the results:sbt> testOnly *HelloWorldSpec[info] HelloWorldSpec[info][info] This is a specification to check the Hello world string[info][info] The Hello world string should[info]   + contain 11 characters[info]   + start with Hello[info]   + end with world[info][info] Total for specification HelloWorldSpec[info] Finished in 0 second, 58 ms[info] 3 examples, 0 failure, 0 error<h3 id="Learn more!" class="ribbon both-ribbon">Learn more!</h3><div class="ribbon-content">    The rest of this  will show you how to: *  your specification using one of the 2 major "styles" of specifications presented here: "Acceptance" and "Unit" * use the many specs2  to specify precisely the expected behavior of your application *  your specification and output results in various formats * check out the  page to find an answer to a specific question</div>', 'tags':'', 'loc':'org.specs2.guide.QuickStart.html'},
{'title':'Structure', 'text':' StylesIn a Specification you generally want to include 2 things: - some informal text describing what the system/application/function should do - some Scala code specifying exactly inputs and expected outputs<p/>With specs2 you have 2 main ways to do this: - you can create an **Acceptance** specification where all the informal text is written in one place and the code is written somewhere else.   The name "acceptance" comes from the fact that it might be easier for a non-developer to just read some text to validate your specification - you can create a **Unit** specification where the code is interleaved with the text.   The name "unit" comes from the fact that unit specifications have a structure which is close to unit tests in classical frameworks such as JUnitBoth ways of writing specifications have advantages and drawbacks: - Acceptance specifications are easier to read as a narrative but require navigation between the text and the code. You also need to define an `is`   method holding the body of the specification - Unit specifications are easier to navigate but the text tends to be lost in a sea of code Acceptance specificationAn acceptance specification extends `org.specs2.Specification` and defines the `is` method. You can implement this methodwith an interpolated **`s2`** string: class MySpecification extends org.specs2.Specification:  def is = s2"""  this is my specification    where example 1 must be true $e1    where example 2 must be true $e2  """  def e1 = 1 === 1  def e2 = 2 === 2The `s2` string contains the text of your specification as well as some references to methods (`e1` and `e2`)defining some code eventually evaluating to a `Result` (this can take many forms, from a simple Boolean, to a `Future[Result]`, or some valuewith an `AsExecution` instance).When the Specification is executed, the `s2` string is analysed and 2 `Examples` are created then executed: - one `Example` with the description "where example 1 must be true" and the code `1 === 1` - another `Example` with the description "where example 2 must be true" and the code `2 === 2`<p/>All the rest, `"this is my specification"`, is parsed as `Text` and is not executed. Unit specificationA unit specification extends `org.specs2.mutable.Specification` and uses the `>>` operator to create "blocks" containing `Texts` and `Examples`: class MySpecification extends org.specs2.mutable.Specification:  "this is my specification" >> {    "where example 1 must be true" >> {      1 must ===(1)    }    "where example 2 must be true" >> {      2 must ===(2)    }  }This specification creates one piece of `Text` and 2 `Examples` as before but: - there is no need to define an `is` method (this means that a mutable variable is used to collect the `Texts` and `Examples` hence the `mutable` package name) - the code is close to each piece of text it specifies<p/>However once a specification is created with all its `Texts` and `Examples`, the execution will be the same, whether it is an Acceptance one or a Unit one.The `>>` blocks can be nested and this allows you to structure your specification so that the outermost blocks describe a general contextwhile the innermost ones describe more specific contexts. A similar effect can be achieved by simply indenting text in an acceptance specification. ExpectationsThere is another major difference between the acceptance specifications and unit specifications.The first style encourages you to write [one expectation per example](http://bit.ly/one_assertion_per_test) while the second allows to use several.One expectation per example is useful because when a specification fails, you know immediately what is wrong.However it is sometimes expensive to setup data for an example. In that case, having several expectations sharing the same setup might be preferable.The good news is that for each of the 2 main styles, acceptance and unit, you can choose exactly which "Expectation mode" you prefer if the default mode is not convenient. Functional expectationsIn an acceptance specification, by default, the `Result` of an `Example` is always given by the last statement of its body.For instance, this example will never fail because the first expectation is lost:// this will never fail!s2"""  my example on strings $e1"""def e1 =  // because this expectation will not be returned,...  "hello" must haveSize(10000)  "hello" must startWith("hell")If you want to get both expectations you will need to use `and` between them: s2"""  my example on strings $e1"""def e1 =  ("hello" must haveSize(10000)) and  ("hello" must startWith("hell"))This is a bit tedious and not very pleasing to read so you can see why this mode encourages one expectation per example only!If you want to declare several expectations per example, you can mix-in the `org.specs2.matcher.ThrownExpectations` trait to the specification. Thrown expectationsWith a unit specification you get "thrown expectations" by default. When an expectation fails, it throws an exception and the rest of the example is not executed: class MySpecification extends org.specs2.mutable.Specification:  "This is my example" >> {    1 === 2 // this fails    1 === 1 // this is not executed  }It is also possible to use the "functional" expectation mode with a unit specification by mixing in the `org.specs2.matcher.NoThrownExpectations` trait.<h3 id="Now learn how to..." class="ribbon both-ribbon">Now learn how to...</h3><div class="ribbon-content">     - use  to specify the body of your examples - set up  for the examples - control the  of a specification -  a specification</div><h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     -  examples - use a  for mutable specifications - collect  - mark examples as  - add  - create example descriptions spanning  - add  in unit specifications - create a trait which will  when mixed-in - create  where the code *is* the description of the `Example` - integrate  to your specification - use  to reduce the number of implicits in scope - use  to create executable HTML tables in your specification - use the  to define the body of an example - add  - print  - extend the specification by creating examples </div>', 'tags':'', 'loc':'org.specs2.guide.Structure.html'},
{'title':'Matchers', 'text':'The most frequent way to specify some expected behaviour with specs2 is to use _matchers_. You generally execute an action, a command or a function and then check if the actual value you get is equal to an expected one (the ["arrange-act-assert"](http://bit.ly/arrange_act_assert) paradigm).For example, if you create a specification for an object manipulating paths:// describe the functionalitys2"the directoryPath method should return well-formed paths $e1"// give an example with some codedef e1 = Paths.directoryPath("/tmp/path/to/dir") must beEqualTo("/tmp/path/to/dir/")The `must` operator takes the actual value returned by `directoryPath` and applies it to a `Matcher` built with the expected value. `beEqualTo` is one of the many matchers defined by specs2, it just checks if 2 values are equal.In the following sections you will learn: - the different ways of checking the [equality](#equality) of values - how to use the matchers for the most [common data types](#out-of-the-box) in Scala, and most notably collections - how to use [other types of matchers](#optional) in less common situations: json, xml, files,... - how to [derive](#derive-matchers) a new matcher from an existing one - how to create [your own matchers](#create-your-own) EqualityThe most common type of matcher is `beEqualTo` to test the equality of 2 values with the underlying `==` operator where: - the compared types must be the same (as if the `language:strictEquality` option has been turned on) - the comparison of `Arrays` uses the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested)   Otherwise `==` on arrays uses the reference equality, so that `Array(1, 2, 3) === Array(1, 2, 3)`, despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`Several syntaxes can be used, according to your own taste Matcher                    |  Comment -------------------------- | -------------------------- `1 must beEqualTo(1)      `| the normal way `1 must be_==(1)          `| with a symbol `1 should be_==(1)        `| for should lovers `1 === 1                  `| the ultimate shortcutThere are also other notions of equality: Matcher            |  Comment ----------         | ----------------------------------------------------- `be_==~           `| check if `(a: A) === conversion(b: B)` when there is an implicit conversion `Conversion[B, A]` `beTheSameAs      `| reference equality: check if `a eq b` (`a must be(b)` also works) `be               `| `a must be(b)`: synonym for `beTheSameAs` `beTrue, beFalse  `| shortcuts for Boolean equality `beLike           `| partial equality, using a `PartialFunction[T, Result]`: `(1, 2) must beLike { case (1, _) => ok }`Now lets check out the other matchers. Out of the boxThese are the all the available matchers when you extend `Specification`: OptionalThose matchers are optional. To use them, you need to add a new trait to your specification.Those are additional "data" matchers:Those matchers can be used to check "content":And finally those matchers are Scala / Language related Derive matchersThe easiest way to create a new matcher is to derive it from an existing one. You can: * use logical operators def beBetween(i: Int, j: Int) = be_>=(i) and be_<=(j) * "adapt" the actual value // This matcher adapts the existing `be_<=` matcher to a matcher applicable to `Any`def beShort1 = be_<=(5)  { (t: Any) => t.toString.length }// you can use aka to provide some information about the original value, before adaptationdef beShort2 = be_<=(5)  { (t: Any) => t.toString.length aka "the string size" }// The adaptation can also be done the other way around when its more readabledef haveExtension(extension: =>String) = ((_: File).getPath)  endWith(extension) * adapt the actual and expected values. This matcher compares 2 `Human` objects but set their `wealth` field to 0   so that the equals method will not fail on that field: def beMostlyEqualTo(h: Human) = be_==(h)  ((_: Human).copy(wealth = 0))// thenHuman(age = 20, wealth = 1000) must beMostlyEqualTo(Human(age = 20, wealth = 1)) // success * use `eventually` to try a matcher a number of times until it succeeds: val iterator = List(1, 2, 3).iterator// Use eventually(retries, n.millis) to specify the number of tries and waiting timeiterator.next must be_==(3).eventually * use `await` to create a matcher that will match on `Matcher[Future[T]]` (this requires an ): Future(1) must be_>(0).awaitFuture { Thread.sleep(100); 1 } must be_>(0).await(retries = 2, timeout = 100.millis) * use `when` or `unless` to apply a matcher only if a condition is satisfied: 1 must be_==(2).when(false) // will return a success1 must be_==(2).unless(true) // same thing1 must be_==(2).when(false, "dont check this") // will return a success1 must be_==(2).unless(true, "dont check this") // same thing * use `iff` to say that a matcher must succeed if and only if a condition is satisfied: 1 must be_==(1).iff(true) // will return a success1 must be_==(2).iff(true) // will return a failure1 must be_==(2).iff(false) // will return a success1 must be_==(1).iff(false) // will return a failure * use `orSkip` to return a `Skipped` result instead of a Failure if the condition is not satisfied 1 must be_==(2).orSkip1 must be_==(2).orSkip("Precondition failed") // prints "Precondition failed: 1 is not equal to 2"1 must be_==(2).orSkip((ko: String) => "BAD " + ko) // prints "BAD 1 is not equal to 2" * use `orPending` to return a `Pending` result instead of a Failure if the condition is not satisfied 1 must be_==(2).orPending1 must be_==(2).orPending("Precondition failed") // prints "Precondition failed: 1 is not equal to 2"1 must be_==(2).orPending((ko: String) => "BAD " + ko) // prints "BAD 1 is not equal to 2" Create your ownThe easiest way to create a new matcher is to create it from a function returning a tuple with a boolean and one or more messages: // import the necessary implicit conversions if you are outside of a Specification// import org.specs2.matcher.Matcher.{given}// annotate the return type so that implicit conversions can transform your function into a Matcher object// here just return a boolean and a failure messagedef startWithHello: Matcher[String] = { (s: String) =>  (s.startsWith("hello"), s + " doesnt start with hello")}If you want absolute power over matching, you can define your own matcher extending `Matcher`: import org.specs2.execute.Result.*case class BeMyOwnEmpty() extends Matcher[String] {  def apply[S <: String](s: Expectable[S]) = {    result(s.value.isEmpty, s.description + " is not empty")  }}"" must BeMyOwnEmpty()In the code above you have to: * define the `apply` method (and its somewhat complex signature) * use the protected `result` method to return a `Boolean` condition and a failure message * you can use the `description` method on the `Expectable` class to return the full description of the expectable including   the optional description you setup using the `aka` method<h3 id="Now learn how to..." class="ribbon both-ribbon">Now learn how to...</h3><div class="ribbon-content">     - use  (`failure`, `success`, `skipped`, `todo`...) instead of matchers - add  to your expectations to create even better failure messages - use  to conveniently group several examples into one - use  to generate and verify data for your examples - use  to display actual and expected values in html tables</div><h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">     - read the  on all of specs2 matchers - implement the  to go beyond matchers - use specs2 matchers </div>', 'tags':'', 'loc':'org.specs2.guide.Matchers.html'},
{'title':'Runners', 'text':'In this section we present the most important options for running specifications. Via sbtThe most common way to run specs2 specifications is to use [sbt](http://scala-sbt.org).[Sbt](www.scala-sbt.org) recognizes specs2 as a ["test framework"](http://www.scala-sbt.org/release/docs/Testing.html).This means that any class or object extending the `Specification` class can be executed by sbt.The `test` command will run all the specifications in your project provided you put them in the `src/test/scala` directory:sbt> testMost of the time however you will use the `testOnly` command, either because you want to run one specification only or because you want to pass arguments:sbt> testOnly org.acme.secret.KillerAppSpecOnly show failed tests:sbt> testOnly org.acme.secret.KillerAppSpec -- xonly sbt optionsVarious sbt options can apply to [the execution of tests in sbt](http://www.scala-sbt.org/release/docs/Testing.html) but here are the ones which you are most likely to use: - exclude some specifications:   `testOptions := Seq(Tests.Filter(s => Seq("Spec", "Unit").exists(s.endsWith)))` - execute specifications one after the other   `Test / parallelExecution := false` - pass specs2 arguments to all specifications   `Test / testOptions += Tests.Argument("exclude", "integration")` - display results as soon as theyve been executed   `logBuffered := false` - restrict the parallel execution of specifications with [custom tags](https://www.scala-sbt.org/1.x/docs/Parallel-Execution.html#Tagging+Tasks).     ***if you want to use sbt tags you will also need to pass the `sbt.tags` argument on the command-line*** In a shellA specification can be executed directly with the `scala` interpreter in a shell, provided that you can produce a classpath containing all the dependencies for your project.One way to do this is to use sbt:sbt> export runtime:fullClasspathThen, if you store the output of this command in an environment variable, `$SCALA_PATH`, you can run a specification with:sh> scala -classpath $SCALA_PATH specs2.run org.acme.secret.KillerAppSpec OutputWhen you run a specification, whatever environment you are in: sbt, shell, IDE,... you can specify different outputs for the results. For example, when you execute a specification with sbt, the results appear in the console. If you want JUnit XML files to be produced instead you need to pass the `junitxml` argument. Adding any "output" argument will deactivate the console (you will see no output in the console) but you can enable it again by passing the `console` argument. You can of course specify several outputs like `html junitxml console`.Here is a list of all the existing `Printers` in specs2 with links to the corresponding section in the User Guide for more information.<div markdown=1> Argument   | Section ---------- | ----------------------- `console`  |  `junitxml` |  `html`     |  `markdown` |  `notifier` |  `printer`  | </div> ArgumentsWith the `testOnly` command arguments can be passed on the command line for selecting, executing or reporting a specification. Please consult the following sections for more information: -  to select only some example to run -  to modify the execution parameters - , , ... for "reporting" arguments - the  for a list of all arguments<h3 id="Now learn how to..." class="ribbon both-ribbon">Now learn how to...</h3><div class="ribbon-content">   run specifications : [IntelliJ IDEA](http://www.jetbrains.com/idea/features/scala.html), [ScalaIDE](http://scala-ide.org) * output  to run in a continuous integration server like [Jenkins](http://jenkins-ci.org) * </div><h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">   run specifications with : maven, gradle * run specificationsoutputuse your  by implementing the `Notifier` interface (simple) or the `Printer` interface * execute  with the `all` argument</div>', 'tags':'', 'loc':'org.specs2.guide.Runners.html'},
{'title':'Contexts', 'text':'In a specification some examples are very straightforward. They just check that a function is returning expected values when given some inputs.However other examples can be more complex and require to execute in a specific context: * with some state being setup before the example executes * with some state being cleaned up after the example is executed * inside a database context, with or without the possibility to access the transaction context * with state being setup before *all* examples * with state being cleaned up after *all* the examples<p/>For all those situations, there is a specs2 trait which you can mix in your specification. BeforeEach / AfterEachThe `org.specs2.specification.BeforeEach` trait defines an action that will be executed before each example:class BeforeSpecification extends org.specs2.mutable.Specification with BeforeEach:  // you need to define the "before" action  def before = step(println("before"))  "example 1" >> {    println("example1"); ok  }  "example 2" >> {    println("example2"); ok  }If you execute this specification you may see something like (note that examples and before actions are executed concurrently):console[info] before[info] before[info] example2[info] example1As you can guess, defining a behaviour "after" is very similar:class AfterSpecification extends org.specs2.mutable.Specification with AfterEach:  // you need to define the "after" action  def after = step(println("after"))  "example 1" >> {    println("example1"); ok  }  "example 2" >> {    println("example2"); ok  }You might also want to mix the two:class BeforeAfterSpecification extends org.specs2.mutable.Specification with BeforeAfterEach:  def before = step(println("before"))  def after = step(println("after"))  "example 1" >> {    println("example1"); ok  }  "example 2" >> {    println("example2"); ok  }_IMPORTANT_: Mixing traits like `BeforeEach` and `BeforeAfterEach` can lead to surprising behaviour where the `before` action is executed twice.You should rather have both traits extends `BeforeAfterEach` to avoid that:import org.specs2.specification.dsl.ActionDsltrait B1 extends BeforeAfterEach with ActionDsl:  def before = step(println("before 1"))  def after = step(()) // do nothingtrait B2 extends BeforeAfterEach with ActionDsl:  def before = step(println("before 2"))  def after = step(println("after 2")) AroundEachAnother very common situation is when you need to execute in the context of a database transaction or a web request.In this case you can use the `AroundEach` trait to execute each example in the proper context:trait DatabaseContext extends AroundEach:  // you need to define the "around" method  def around[R: AsResult](r: =>R): Result =    openDatabaseTransaction    try AsResult(r)    finally closeDatabaseTransaction  // do what you need to do with the database  def openDatabaseTransaction = ???  def closeDatabaseTransaction = ???class AroundSpecification extends org.specs2.mutable.Specification with DatabaseContext:  "example 1" >> {    println("using the database"); ok  }  "example 2" >> {    println("using the database too"); ok  }The specification above shows a trait `DatabaseContext` extending `AroundEach` (so that trait can be reused for other specifications). It defines a method named `around` taking the body of the example, anything with an  typeclass, and returns a result. Because `r` is a byname parameter, you are free to do whatever you want before or after evaluating it, like opening and closing a database transaction.The `AroundEach` trait can be used for lots of different purposes: - to re-execute examples a number of times - to time them out if they run for too long - to run them in different contexts, with different parameters <p/>There is however one thing you cannot do with `AroundExample`. You cant pass a specific context to the example. The `ForEach` trait solves this problem. ForEachSometimes you need to manage a specific context for each example but you also want to make it accessible to the examples themselves.Here is a specification having examples using an active database transaction:// a transaction with the databasetrait Transactiontrait DatabaseContext extends ForEach[Transaction]:  // you need to define the "foreach" method  def foreach[R: AsExecution](f: Transaction => R): R =    val transaction = openDatabaseTransaction    try f(transaction)    finally closeDatabaseTransaction(transaction)  // create and close a transaction  def openDatabaseTransaction: Transaction = ???  def closeDatabaseTransaction(t: Transaction) = ???class FixtureSpecification extends org.specs2.mutable.Specification with DatabaseContext:  "example 1" >> { (t: Transaction) =>    println("use the transaction")    ok  }  "example 2" >> { (t: Transaction) =>    println("use it here as well")    ok  } BeforeSpec / AfterSpecSome setups are very expensive and can be shared across all examples. For example you might want to start an application serverjust at the beginning of the specification and then close it at the end.You can use 3 traits to do this: * `BeforeSpec` inserts any `Fragments`, for example a `Step`, before all the examples * `AfterSpec` inserts any `Fragments`, for example a `Step`,` after all the examples * `BeforeAfterSpec` inserts `Fragments` before all the examples and after all of themFragments are the pieces making a `Specification: examples, text, steps, etc.... You can learn more about the Fragments API in . ResourcesA very common use case for a `BeforeSpec/AfterSpec` behaviour is to acquire an expensive resource and release it at the end of the specification.You can do this with the `Resource` trait:import org.specs2.Specificationimport org.specs2.specification.Resourceimport org.specs2.specification.core.Executionimport org.specs2.control.Refimport scala.collection.mutable.ArrayBufferimport scala.concurrent.*trait LocalRef(using ec: ExecutionContext) extends Resource[Ref[Int]]:  def acquire: Future[Ref[Int]] =    Future.successful(Ref(0))  def release(ref: Ref[Int]): Execution =    Future { true }class ResourceExample(using ec: ExecutionContext) extends Specification, LocalRef:  val messages: ArrayBuffer[String] = ArrayBuffer()  def is = sequential  s2"""    e1 $e1    e2 $e2    """  def e1 = { (ref: Ref[Int]) =>    messages.append("e1 "+ref.get)    ref.update(v => v + 1)    // the resource will be released even if there is an exception here    throw Exception("boom")    ok  }  def e2 = { (ref: Ref[Int]) =>    messages.append("e2 "+ref.get)    ref.update(v => v + 1)    ok  }In this example we use a mutable reference as our "expensive" resource. It is created with the `acquire` method which returnsa `Future` so that we dont need to block on the acquisition. Then the resource is made available to any example in thespecification by using it as a parameter as in `e1` for example. And finally the resource is released (the database is shut down,some files are closed, ...) with the `release` method. You will need to return anything that canbe converted to a specs2 `Execution`: a `Result`, a `Future[Result]` or even a simple `Boolean`.Sometimes it is necessary to keep a resource open across several specifications invocations. In order to do this you need tooverride the `resourceKey` function to provide a unique key for the resource: trait GlobalRef(using ec: ExecutionContext) extends Resource[Ref[Int]]:  override def resourceKey: Option[String] =    Some("global reference")  def acquire: Future[Ref[Int]] =    Future.successful(Ref(0))  def release(ref: Ref[Int]): Execution =    Future { true }Then `specs2` will release all global resources at the end of a run.</p><h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3><div class="ribbon-content">   read about specs2  to understand how `Examples` and `Steps` are being executed</div>', 'tags':'', 'loc':'org.specs2.guide.Contexts.html'},
{'title':'ScalaCheck', 'text':'A clever way of creating expectations in specs2 is to use the [ScalaCheck](https://github.com/rickynils/scalacheck) library.To declare ScalaCheck properties you first need to extend the `org.specs2.ScalaCheck` trait. Then you can pass functions returning any kind of `Result` (`Boolean`, `Result`, or a ScalaCheck `Prop`) to the `prop` method and use the resulting `Prop` as your example body: s2"addition and multiplication are related ${prop { (a: Int) => a + a == 2 * a }}"The function that is checked can either return: // a Booleans2"addition and multiplication are related ${prop { (a: Int) => a + a == 2 * a }}"// a Results2"addition and multiplication are related ${prop { (a: Int) => a + a must ===(2 * a) }}"// a Props2"addition and multiplication are related ${prop { (a: Int) => (a > 0) ==> (a + a must ===(2 * a)) }}"Note that if you pass functions using `Result`s you will get better failure messages than just using boolean expressions.By default the properties created with `prop` will be shrinking counter-examples.But as you will see below there lots of different ways to parameterize ScalaCheck properties in specs2, including declaring if shrinking must be done. Prop and PropertiesYou can also directly use the property types defined by ScalaCheck: `Prop` and `Properties`(a `Properties` object is a just a collection of named `Prop`s)val p1: Prop = Prop.forAll { (a: Int) => a + a == 2 * a }s2"addition and multiplication are related $p1"val p2: Properties = new Properties("addition/multiplication") {  property("addition1") = Prop.forAll { (a: Int) => a + a == 2 * a }  property("addition2") = Prop.forAll { (a: Int) => a + a + a == 3 * a }}s2"addition and multiplication are related $p2"When using `Properties` only one example is created. This example will run each included property in turnand label the result with the property name if there is a failure. If, however, you want to create one example per included property you need to use the `properties` method: val p2: Properties = new Properties("addition/multiplication") {  property("addition1") = Prop.forAll { (a: Int) => a + a == 2 * a }  property("addition2") = Prop.forAll { (a: Int) => a + a + a == 3 * a }}s2"addition and multiplication are related ${properties(p2)}"*Note*: in a mutable specification the `properties` block of examples need to be added with `addFragments`:"addition and multiplication are related" >> addFragments(properties(p2))If you dont do that there will be no examples executed at all (the beauty of side-effects!). Arbitrary instancesScalaCheck requires an implicit `Arbitrary[T]` instance for each parameter of type `T` used in a property.If you rather want to pick up a specific `Arbitrary[T]` for a given property argumentyou can modify the `prop` with to use another `Arbitrary` instance: s2"""  a simple property       $ex1  a more complex property $ex2"""def abStringGen = (Gen.oneOf("a", "b") |@| Gen.oneOf("a", "b"))(_ + _)given abStrings: Arbitrary[String] =  Arbitrary(abStringGen)def ex1 = prop((s: String) => s must (contain("a") or contain("b"))).setArbitrary(abStrings)// use the setArbitrary<n> method for the nth argumentdef ex2 = prop((s1: String, s2: String) => (s1 + s2) must (contain("a") or contain("b")))  .setArbitrary1(abStrings)  Arbitrary2(abStrings)It is also possible to pass a `Gen[T]` instance instead of an `Arbitrary[T]`: val abStringGen = (Gen.oneOf("a", "b") |@| Gen.oneOf("a", "b"))(_ + _)def ex1 = prop((s: String) => s must (contain("a") or contain("b")))Gen(abStringGen) With Shrink / PrettySpecific `Shrink` and `Pretty` instances can also be specified at the property level: val shrinkString: Shrink[String] = ???// set a specific shrink instance on the second parameterprop((s1: String, s2: String) => s1.nonEmpty or s2.nonEmpty).setShrink2(shrinkString)// set a specific pretty instanceprop((s: String) => s must (contain("a") or contain("b")))Pretty((s: String) =>  Pretty((prms: Pretty.Params) => if (prms.verbosity >= 1) s.toUpperCase else s))// or simply if you dont use the Pretty parametersprop((s: String) => s must (contain("a") or contain("b"))).pretty((_: String).toUpperCase)Note that it is also possible to _remove_ shrinking by appending `noShrink` to your property: prop((s1: String, s2: String) => s1.nonEmpty or s2.nonEmpty).noShrink Test properties Default valuesScalaCheck test generation can be tuned with a few properties. If you want to change the default settings, you have to use implicit values: given Parameters = Parameters(minTestsOk = 20) // add ".verbose" to get additional console printingThe parameters you can modify are: Parameter         | Default                | Description ----------------- | -----------            | ---------------------------------------- `minTestsOk`      | `100`                  | minimum of tests which must be ok before the property is ok `maxDiscardRatio` | `5.0f`                 | if the data generation discards too many values, then the property cant be proven `minSize`         | `0`                    | minimum size for the "sized" data generators, like list generators `maxSize`         | `100`                  | maximum size for the "sized" data generators `workers`         | `1`                    | number of threads checking the property `rng`             | `new java.util.Random` | the random number generator `callback`        |                        | a ScalaCheck TestCallback (see the [ScalaCheck documentation](http://www.scalacheck.org)) `loader`          |                        | a custom classloader (see the [ScalaCheck documentation](http://www.scalacheck.org)) `prettyParams`    |                        | a `Pretty.Params` instance to set the verbosity level when displaying `Pretty` instances `seed`            | `None`                 | a Base64 encoded string which you can get from a previous failed run. You can set the seed on the property directly with `setSeed(string)`Note that `minTestsOk` in `specs2` corresponds to the `minSuccessfulTests` parameter in `ScalaCheck`. Property levelIt is also possible to specifically set the execution parameters on a given property: class ScalaCheckSpec extends org.specs2.mutable.Specification with ScalaCheck:  "this is a specific property" >> prop { (a: Int, b: Int) =>    (a + b) must ===((b + a))  } // use "display" instead of "set" for additional console printing Command-lineSome properties can be overridden from the command line: Parameter         | Command line ----------------- | ------------ `minTestsOk`      | `scalacheck.mintestsok` `maxDiscardRatio` | `scalacheck.maxdiscardratio` `minSize`         | `scalacheck.minsize` `maxSize`         | `scalacheck.maxsize` `workers`         | `scalacheck.workers` `verbose`         | `scalacheck.verbose` `seed`            | `scalacheck.seed` ExpectationsBy default, a successful example using a `Prop` will be reported as 1 success and 100 (or `minTestsOk`) expectations. If you dont want the number of expectations to appear in the specification statistics just mix-in your specification the `org.specs2.scalacheck.OneExpectationPerProp` trait. Collect valuesIt is important to validate that generated values are meaningful. In order to do this you can use `collect` to collect values: // for a property with just one argumentprop((i: Int) => i % 2 == 0).collect// for a property with just 2 arguments// collect the second value onlyprop((i: Int, j: Int) => i > 0 && j % 2 == 0).collect2// collect the second value but map it to something elseprop((i: Int, j: Int) => i > 0 && j % 2 == 0).collectArg2((n: Int) => "the value " + n)// collect all values and displayprop((i: Int, j: Int) => i > 0 && j % 2 == 0).collectAll.verboseNote that, by default, nothing will be printed on screen unless you set the reporting to `verbose` by either: - changing the default `Parameters` - setting `.verbose` at the property level - passing `scalacheck.verbose` on the command-line EquivalenceThe `==>` operator in ScalaCheck helps you specify under which conditions a given property is applicable. However it only works one way, you cannot declare that a property must be true "if and only if" some conditions are respected.With specs2 and the `org.specs2.execute.ResultImplicits` trait you can use the `<==>` operator to declare the equivalence of 2 `Results`,whether they are properties or booleans or `MatchResults`. So you can write: // replace 55 with whatever you think "old" is...prop((i: Int) => (i >= 18 && i <= 55) <==> isYoung(i)) Working with SeedsBy default when a property fails the seed will be displayed (unless you `setVerbosity` to a negative number).If you want to "replay" a property with a that specific seed you can copy and set it on the property: prop((i: Int) => i % 2 == 0)Seed("f7ZhfyfeJz5eRysok6qBmtvt4SOxHjCIBNgn3Yhs5SD")You can also pass it on the command-linesbt> testOnly *MySpec -- ex myTest scalacheck.seed f7ZhfyfeJz5eRysok6qBmtvt4SOxHjCIBNgn3Yhs5SD', 'tags':'', 'loc':'org.specs2.guide.UseScalaCheck.html'},
{'title':'Installation', 'text':'The recommended way to install specs2 is via [sbt](http://scala-sbt.org). SBTFirst you need to [install sbt itself](https://www.scala-sbt.org/release/docs/Setup.html) then you need to add the specs2 dependency:libraryDependencies += "org.specs2" %% "specs2-core" % "5.6.2" % "test"// if you want to use ScalaJS you need to use %%%libraryDependencies += "org.specs2" %%% "specs2-core" % "5.6.2" % "test"// ScalaJS also requires the following setting which supports// the regular expressions used in many specs2 matchers using stringsscalaJSLinkerConfig ~= { _.withESFeatures(_.withESVersion(ESVersion.ES2018)) }See [here](https://www.scala-sbt.org/release/docs/Library-Dependencies.html) to learn more about sbt dependencies. Other dependenciesDepending on the specs2 features you want to use you will need to add more dependencies to your build: Name                    | Functionality ----------------------- | ---------------------------- `specs2-matcher-extra`  | for the optional specs2 matchers `specs2-html`           | to export specifications as html `specs2-form`           | to create html form-like specifications (experimental) `specs2-junit`          | to run specifications as JUnit tests `scalamock`             | to use mocks in specifications (see the [ScalaMock project](https://scalamock.org)) `specs2-scalacheck`     | to use ScalaCheck properties in specifications (see the [ScalaCheck project](https://github.com/typelevel/scalacheck)) `specs2-cats`           | for the [cats](https://github.com/typelevel/cats) matchers (see [specs2-cats](https://github.com/etorreborre/specs2-cats)) `specs2-scalaz`         | for the [scalaz](https://github.com/scalaz/scalaz) matchers (see [specs2-scalaz](https://github.com/etorreborre/specs2-scalaz))Note: the `specs2-core` jar depends on 3 other specs2 jars: Name                    | Functionality ----------------------- | ---------------------------- `specs2-fp`             | utility classes for functional programming `specs2-common`         | utility classes for text, collections, xml,... `specs2-matcher`        | common specs2 matchers. They can be used as a stand-alone library with [JUnit](http://junit.org)', 'tags':'', 'loc':'org.specs2.guide.Installation.html'},
{'title':'Detailed topics', 'text':' Topic                                                               | See------------------------------------------------------               | ---------------Create an example with just some code as the description             | Gather all expectations in an example                                | Reference another specification                                      | Add formatting to a specification                                    | Create HTML tables to specify examples                               | Create examples "on the fly" as the specification executes           | Create an example with different data displayed in a table           | Fragments API                                                        | Create an example with different data displayed in a table           | Use specs2 environment (command-line args, file system...)          | Execution environment for Futures                                    | Create a new type of Result                                          | Other build tools                                                    | Use specs2 matchers outside of specs2                              | Matchers reference card                                              | Arguments reference card                                             | ', 'tags':'', 'loc':'org.specs2.guide.DetailedTopics.html'},
{'title':'Troubleshooting', 'text':'This section presents some of the common pitfalls you might face when using specs2 and Scala vals vs lazy valsThe common symptom here is a `NullPointerException` for some attributes of your specification. You can refer to this [link](http://engineering.tapad.com/blog/2012/11/here-there-be-dragons-dangers-of-initialization-order-in-scala/) for an explanation of variable initialization in Scala. In the meantime the basic fix is to use a `lazy val` instead of a `val`. Lost expectationsYou might expect the following specification to fail:class ShouldItFail extends Specification:  def is = s2"""  Should this example fail? $e1  """  def e1 =    1 must ===(100000) // do you expect this to fail    10 must ===(10)However, as explained in  - Thrown expectations, the first expectation is lost because, by default, no exceptions are thrown in an acceptance specification.In that case you can either: - create 2 examples having one expectation each - mix-in the `ThrownExpectations` trait Custom outputYou created a custom `Notifier` or another class for reporting and when you use it nothing happens.In that case add the `verbose` argument to the command line and you will get more messages including exceptions and stacktraces about what is going on.', 'tags':'', 'loc':'org.specs2.guide.Troubleshooting.html'},
{'title':'How to', 'text':' Question                                              | See------------------------------------------------------ | ---------------How to execute an action before all the examples?                                        | How to execute an action before each example?                                            | Can I create and reuse a Specification "template"?                                       | How can I pass some data to each example?                                                | Can I add more information to my results for easier diagnostic?                          | Is it possible to execute a Specification sequentially?                                  | How to mark an example as `pending` until it is fixed?                                   | Can I simply mark a block of code as `pending`?                                          | Is there a way to run only one example?                                                  | I would like to display the execution time of each example                               | Can I use a for loop to create examples or results?                                      | How can I tag examples?                                                                  | Can I skip examples?                                                                     | Is it possible to modify the behaviour of a Specification with command-line arguments?   | How to capture snippets of code and add them to my Specification?                        | Can I create an HTML index of all the specifications?                                    | Is it possible to execute a Specification in a random order?                             | How can I easily print expressions to the console?                                       | Can specs2 create a JUnit xml file for a continuous integration server?                 | Is it possible to reduce the number of implicits in scope and improve compilation times? | How can I collect execution data?                                                        | Can I display some data when an example succeeds?                                        | Can I create an example description spanning several lines?                              | How to timeout examples?                                                                 | Can I use parts of an example description in the example itself?                         | Add my own keywords (other than >>, should, can) to a mutable specification        | Help, I need to troubleshoot my issues!                                                  | How can I integrate my own IO type to specifications?                                    | ', 'tags':'', 'loc':'org.specs2.guide.HowTo.html'},
{'title':'User Guide', 'text':' specs2 is a library for writing executable software specifications in Scala. With specs2 you can write: * specifications for simple classes (*unit* specifications) * specifications for full features (*acceptance* specifications)<p/>  In this user guide, you will find: <li class="example success"/>a  <li class="example success"/>how to  <li class="example success"/>how to use  <li class="example success"/>how to <p/> And much more!          ', 'tags':'', 'loc':'org.specs2.guide.UserGuide.html'}]};
     
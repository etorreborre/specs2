
### Equality


The most common type of matcher is `beEqualTo` to test the equality of 2 values with the underlying `==` operator where:

 - the compared types must be the same (as if the `language:strictEquality` option has been turned on)

 - the comparison of `Arrays` uses the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested)
   Otherwise `==` on arrays uses the reference equality, so that `Array(1, 2, 3) === Array(1, 2, 3)`, despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`

Several syntaxes can be used, according to your own taste

 Matcher                    |  Comment
 -------------------------- | --------------------------
 `1 must beEqualTo(1)      `| the normal way
 `1 must be_==(1)          `| with a symbol
 `1 should be_==(1)        `| for should lovers
 `1 === 1                  `| the ultimate shortcut

There are also other notions of equality:

 Matcher            |  Comment
 ----------         | -----------------------------------------------------
 `be_==~           `| check if `(a: A) === conversion(b: B)` when there is an implicit conversion `Conversion[B, A]`
 `beTheSameAs      `| reference equality: check if `a eq b` (`a must be(b)` also works)
 `be               `| `a must be(b)`: synonym for `beTheSameAs`
 `beTrue, beFalse  `| shortcuts for Boolean equality
 `beLike           `| partial equality, using a `PartialFunction[T, Result]`: `(1, 2) must beLike { case (1, _) => ok }`

### Out of the box

These are the all the available matchers when you extend `Specification`

<td class="info"><form>
    <table><tr><th colspan="101">Specification matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="String"><form>
    <table><tr><td class="none" style="info"><p>Matching on strings is very common. Here are the matchers which can help you:</p>
<table>
  <thead>
    <tr><th>Matcher                               </th><th> Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code class="prettyprint">beMatching</code>                          </td><td> check if a string matches a regular expression</td></tr>
    <tr><td><code class="prettyprint">beMatchingWithPart(s)</code>               </td><td> shortcut for <code class="prettyprint">beMatching(&quot;(.|\\s)*&quot;+s+&quot;(.|\\s)*&quot;)</code> (alias: <code class="prettyprint">=~</code>)</td></tr>
    <tr><td><code class="prettyprint">find(exp).withGroups(a, b, c)</code>       </td><td> check if some groups are found in a string</td></tr>
    <tr><td><code class="prettyprint">haveSize</code>                            </td><td> check the size of a string (alias <code class="prettyprint">haveLength</code>)</td></tr>
    <tr><td><code class="prettyprint">beEmpty</code>                             </td><td> check if a string is empty</td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).ignoreCase</code>             </td><td> check if 2 strings are equal regardless of casing</td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).ignoreSpace</code>            </td><td> check if 2 strings are equal when you <code class="prettyprint">replaceAll(&quot;\\s&quot;, &quot;&quot;)</code></td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).trimmed</code>                </td><td> check if 2 strings are equal when trimmed</td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).ignoreSpace.ignoreCase</code> </td><td> you can compose them</td></tr>
    <tr><td><code class="prettyprint">contain(b)</code>                          </td><td> check if a string contains another one</td></tr>
    <tr><td><code class="prettyprint">startWith(b)</code>                        </td><td> check if a string starts with another one</td></tr>
    <tr><td><code class="prettyprint">endWith(b)</code>                          </td><td> check if a string ends with another one</td></tr>
  </tbody>
</table>
</td></tr></table></form></div><div class="tabbertab" title="Traversable"><form>
    <table><tr><td class="none" style="info"><p>Traversables can be checked with several matchers. If you want to check the size of a <code class="prettyprint">Traversable</code></p>
<ul>
  <li>
    <p>check if it is empty<br/>
    <code class="prettyprint">Seq() must beEmpty</code><br/>
    <code class="prettyprint">Seq(1, 2, 3) must not(beEmpty)</code></p>
  </li>
  <li>
    <p>check its size<br/>
    <code class="prettyprint">Seq(1, 2) must haveSize(2)</code><br/>
    <code class="prettyprint">Seq(1, 2) must haveLength(2)</code> // equivalent to size<br/>
    <code class="prettyprint">Seq(1, 2) must haveSize(be_&gt;=(1))</code> // with a matcher</p>
  </li>
  <li>
    <p>check its ordering (works with any type <code class="prettyprint">T</code> which has an <code class="prettyprint">Ordering</code>)<br/>
    <code class="prettyprint">Seq(1, 2, 3) must beSorted</code></p>
  </li>
</ul>
<h4><a href="#check-each-element-individually" id="check-each-element-individually">Check each element individually</a></h4>
<p>Then you can check the elements which are contained in the Traversable</p>
<ul>
  <li>
    <p>if a simple value is contained<br/>
    <code class="prettyprint">Seq(1, 2, 3) must contain(2)</code></p>
  </li>
  <li>
    <p>if a value matching a specific matcher is contained<br/>
    <code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;=(2))</code></p>
  </li>
  <li>
    <p>if a value passing a function returning a <code class="prettyprint">Result</code> is contained<br/>
    <code class="prettyprint">Seq(1, 2, 3) must contain((i: Int) =&gt; i must be_&gt;=(2))</code></p>
  </li>
  <li>
    <p>note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in another you need to use a matcher<br/>
    <code class="prettyprint">Seq(Seq(1)) must contain(===(Seq(1)))</code></p>
  </li>
  <li>
    <p>there are also 2 specialized matchers to check the string representation of the elements<br/>
    <code class="prettyprint">Seq(1234, 6237) must containMatch(&quot;23&quot;)</code>   <code class="prettyprint">// matches with &quot;.*23.*&quot;</code><br/>
    <code class="prettyprint">Seq(1234, 6234) must containPattern(&quot;.*234&quot;)</code>   <code class="prettyprint">// matches with &quot;.*234&quot;</code></p>
  </li>
</ul>
<p>For each of the check above you can indicate how many times the check should be satisfied:</p>
<ul>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).forall</code>  // this will stop after the first failure</li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).foreach</code> // this will report all failures</li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).atLeastOnce</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).atMostOnce</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).exactly(1.times)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).exactly(1)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(1)).between(1.times, 2.times)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(1)).between(1, 2)</code></li>
</ul>
<h4><a href="#check-all-elements" id="check-all-elements">Check all elements</a></h4>
<p>The other types of checks involve comparing the Traversable elements to other elements (values, matchers, function returning a <code class="prettyprint">Result</code>)</p>
<ul>
  <li>
    <p>with a set of values<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(2, 4)</code><br/>
    which is the same thing as<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(2, 4))</code></p>
  </li>
  <li>
    <p>with a set of matchers<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(be_&gt;(0), be_&gt;(1)))</code></p>
  </li>
  <li>
    <p>checking that the order is satisfied<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(be_&gt;(0), be_&gt;(1)).inOrder)</code></p>
  </li>
</ul>
<p>Note that <code class="prettyprint">allOf</code> tries to make each check be successful at least once, even if it is on the same value. On the other hand, if you want to specify that each check must succeed on a <em>different</em> value you should use <code class="prettyprint">onDistinctValues</code>. For example this will fail:<br/>
<code class="prettyprint">Seq(1) must contain(allOf(1, 1)).onDistinctValues</code></p>
<p>The <code class="prettyprint">eachOf</code> method does the same thing (and this example will fail as well):<br/>
<code class="prettyprint">Seq(1) must contain(eachOf(1, 1))</code></p>
<p>Another frequent use of Traversable matchers is to check if the Traversable have the right number of elements. For this you can use:</p>
<ul>
  <li>
    <p><code class="prettyprint">atLeast</code>, which is actually another name for <code class="prettyprint">allOf</code>, where the traversable can contain more elements than required<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(atLeast(2, 4))</code></p>
  </li>
  <li>
    <p><code class="prettyprint">atMost</code> where the traversable can not contain more elements than required<br/>
    <code class="prettyprint">Seq(2, 3) must contain(atMost(2, 3, 4))</code></p>
  </li>
  <li>
    <p><code class="prettyprint">exactly</code> where the traversable must contain exactly the specified number of elements<br/>
    <code class="prettyprint">Seq(1, 2) must contain(exactly(2, 1))</code></p>
  </li>
</ul>
<p>The <code class="prettyprint">atLeast/atMost/exactly</code> operators work on distinct values by default (because this is easier for counting the correspondence between actual values and expected ones). However you can use <code class="prettyprint">onDistinctValues(false)</code> if you don't care.</p>
<p>Finally, if you want to get the differences between 2 traversables:</p>
<p><code class="prettyprint">Seq(2, 4, 1) must containTheSameElementsAs(Seq(1, 4, 2))</code></p>
</td></tr></table></form></div><div class="tabbertab" title="Numeric"><form>
    <table><tr><td class="none" style="info"><p>Numerical values can be compared with the following matchers</p>
<ul>
  <li>
    <p><code class="prettyprint">beLessThanOrEqualTo</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&lt;=</code><br/>
    <code class="prettyprint">1 must be_&lt;=(2)</code><br/>
    <code class="prettyprint">1 must beLessThanOrEqualTo(2)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beLessThan</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&lt;</code><br/>
    <code class="prettyprint">1 must be_&lt;(2)</code><br/>
    <code class="prettyprint">1 must beLessThan(2)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beGreaterThanOrEqualTo</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&gt;=</code><br/>
    <code class="prettyprint">2 must be_&gt;=(1)</code><br/>
    <code class="prettyprint">2 must beGreaterThanOrEqualTo(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beGreaterThan</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&gt;</code><br/>
    <code class="prettyprint">2 must be_&gt;(1)</code><br/>
    <code class="prettyprint">2 must beGreaterThan(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beCloseTo</code> check if 2 Numerics are close to each other<br/>
    <code class="prettyprint">1.0 must beCloseTo(1, 0.5)</code><br/>
    <code class="prettyprint">4 must be ~(5 +/- 2)</code><br/>
    <code class="prettyprint">4.994 must beCloseTo(5.0 within 2.significantFigures)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beBetween</code> check if a value is between 2 others<br/>
    <code class="prettyprint">5 must beBetween(3, 6)</code><br/>
    <code class="prettyprint">5 must beBetween(3, 6).excludingEnd</code><br/>
    <code class="prettyprint">5 must beBetween(4, 6).excludingStart</code><br/>
    <code class="prettyprint">5 must beBetween(4, 6).excludingBounds</code><br/>
    .</p>
  </li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Option/Either"><form>
    <table><tr><td class="none" style="info"><p>There are several matchers to check <code class="prettyprint">Option</code> and <code class="prettyprint">Either</code> instances:</p>
<ul>
  <li><code class="prettyprint">beSome</code> checks if an element is <code class="prettyprint">Some(_)</code></li>
  <li><code class="prettyprint">beSome(exp)</code> checks if an element is <code class="prettyprint">Some(exp)</code></li>
  <li><code class="prettyprint">beSome(matcher)</code> checks if an element is <code class="prettyprint">Some(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beSome(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Some(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Some</code> you need to use a matcher: <code class="prettyprint">beSome(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beSome.which(function)</code> checks if an element is <code class="prettyprint">Some(_</code>) and satisfies a function returning a boolean</li>
  <li><code class="prettyprint">beSome.like(partial function)</code> checks if an element is <code class="prettyprint">Some(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
  <li><code class="prettyprint">beNone</code> checks if an element is <code class="prettyprint">None</code></li>
  <li><code class="prettyprint">beAsNoneAs</code> checks if 2 values are equal to <code class="prettyprint">None</code> at the same time</li>
  <li>
    <p><code class="prettyprint">beRight</code> checks if an element is <code class="prettyprint">Right(_)</code></p>
  </li>
  <li><code class="prettyprint">beRight(exp)</code> checks if an element is `Right(exp)</li>
  <li><code class="prettyprint">beRight(matcher)</code> checks if an element is <code class="prettyprint">Right(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beRight(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Right(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Right</code> you need to use a matcher: <code class="prettyprint">beRight(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beRight.like(partial function)</code> checks if an element is <code class="prettyprint">Right(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
  <li>
    <p><code class="prettyprint">beLeft</code> checks if an element is <code class="prettyprint">Left(_)</code></p>
  </li>
  <li><code class="prettyprint">beLeft(exp)</code> checks if an element is <code class="prettyprint">Left(exp)</code></li>
  <li><code class="prettyprint">beLeft(matcher)</code> checks if an element is <code class="prettyprint">Left(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beLeft(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Left(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Left</code> you need to use a matcher: <code class="prettyprint">beLeft(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beLeft.like(partial function)</code> checks if an element is <code class="prettyprint">Left(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Try"><form>
    <table><tr><td class="none" style="info"><p>There are several matchers to check <code class="prettyprint">Try</code> instances:</p>
<ul>
  <li><code class="prettyprint">beSuccessfulTry</code> checks if an element is <code class="prettyprint">Success(_)</code></li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(exp)</code> checks if an element is <code class="prettyprint">Success(exp)</code></li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(matcher)</code> checks if an element is <code class="prettyprint">Success(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Success(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Success</code> you need to use a matcher: <code class="prettyprint">beSuccessfulTry.withValue(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beSuccessfulTry.which(function)</code> checks if an element is <code class="prettyprint">Success(_)</code> and satisfies a function returning a boolean</li>
  <li><code class="prettyprint">beSuccessfulTry.like(partial function)</code> checks if an element is <code class="prettyprint">Success(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
  <li><code class="prettyprint">beFailedTry</code> checks if an element is <code class="prettyprint">Failure(_)</code></li>
  <li><code class="prettyprint">beFailedTry.withThrowable[T]</code> checks if an element is <code class="prettyprint">Failure(t: T)</code></li>
  <li><code class="prettyprint">beFailedTry.withThrowable[T](pattern)</code> checks if an element is <code class="prettyprint">Failure(t: T)</code> and <code class="prettyprint">t.getMessage</code> matches <code class="prettyprint">pattern</code></li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Future"><form>
    <table><tr><td class="none" style="info"><p>Testing <code class="prettyprint">Futures</code> is quite easy with specs2. You can simply return a value that is <code class="prettyprint">Future[R]</code> where <code class="prettyprint">R</code> has an <code class="prettyprint">AsResult</code><br/>
instance (meaning that <code class="prettyprint">R</code> is some kind of result like: <code class="prettyprint">Boolean</code>, <code class="prettyprint">Result</code>,...).<br/>
Then your future will be executed when specs2 executes your example and the result will be collected.</p>
<p>However you will not get the possibility to specify retries or timeouts. For retries and timeouts<br/>
you can use the <code class="prettyprint">await</code> method on matchers:</p>
<pre><code>Future(1) must be_&gt;(0).await
</code></pre>
<p>You can specify a timeout value and a number of retries</p>
<pre><code>Future { Thread.sleep(100); 1 } must be_&gt;(0).await(retries = 2, timeout = 100.millis)

// only retries, timeout is 1.second
Future { Thread.sleep(100); 1 } must be_&gt;(0).retryAwait(retries = 2)

// only timeout, retries = 0
Future { Thread.sleep(100); 1 } must be_&gt;(0).awaitFor(100.millis)
</code></pre>
<p>Another possibility is for you to obtain a <code class="prettyprint">Future[Result]</code> (or any <code class="prettyprint">Future[R]</code> where <code class="prettyprint">R</code> has an <code class="prettyprint">AsResult</code> typeclass instance).<br/>
In that case you can use <code class="prettyprint">await</code> directly on the <code class="prettyprint">Future</code> to get a <code class="prettyprint">Result</code></p>
<pre><code>Future(1 === 1).await
Future(1 === 1).await(retries = 2, timeout = 100.millis)
</code></pre>
<h4><a href="#execution" id="execution">Execution</a></h4>
<p>The <code class="prettyprint">await</code> method require an implicit <code class="prettyprint">org.specs2.concurrent.ExecutionEnv</code> (see <a href="org.specs2.guide.ExecutionEnvironments.html">here</a> for more details). You can pass one in the body of your examples:</p>
<pre><code>class MyFutureSpec(using ee: ExecutionEnv) extends Specification:
  def is = s2&quot;&quot;&quot;

  Let's check this scala future ${Future(1) must be_&gt;(0).await}

  &quot;&quot;&quot;

// in a mutable specification
class MyMutableFutureSpec(using ee: ExecutionEnv) extends mutable.Specification:
  &quot;Let's check this scala future&quot; &gt;&gt; {
    Future(1) must be_&gt;(0).await
  }
</code></pre>
<h4><a href="#time-factor" id="time-factor">Time factor</a></h4>
<p>Some actions can be a lot slower when executed on a continuous integration server rather than a developer machine and some timeouts will fail.<br/>
You can avoid this by setting the <code class="prettyprint">timeFactor</code> argument which will multiply the durations used when <code class="prettyprint">awaiting / attempting</code> by a constant factor.</p>
<pre><code>sbt&gt; testOnly *MyFuturesSpec* -- timeFactor 3
</code></pre>
<ul>
  <li>use the <a href="org.specs2.guide.ExecutionEnvironment.html">execution environment</a></li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Exception"><form>
    <table><tr><td class="none" style="info"><p>specs2 offers very compact ways of checking that some exceptions are thrown:</p>
<h3><a href="#for-expressions-throwing-an-exception" id="for-expressions-throwing-an-exception">for expressions throwing an exception</a></h3>
<ul>
  <li><code class="prettyprint">throwA[ExceptionType]</code> checks if a block of code throws an exception of the given type</li>
  <li><code class="prettyprint">throwA[ExceptionType](message = &quot;boom&quot;)</code> additionally checks if the exception message is as expected (<code class="prettyprint">message</code> is<br/>
    being interpreted as a regular expression)</li>
  <li><code class="prettyprint">throwA(exception)</code> or <code class="prettyprint">throwAn(exception)</code> checks if a block of code throws an exception of the same type, with the<br/>
    same message</li>
  <li><code class="prettyprint">throwA[ExceptionType].like { case e =&gt; e must matchSomething }</code> or<br/>
    <code class="prettyprint">throwA(exception).like { case e =&gt; e must matchSomething }</code> checks that the thrown exception satisfies a property</li>
</ul>
<h3><a href="#for-expressions-that-shouldnt-throw-an-exception" id="for-expressions-that-shouldnt-throw-an-exception">for expressions that shouldn't throw an exception</a></h3>
<ul>
  <li><code class="prettyprint">not(throwAn[Exception])</code> checks that an expression doesn't throw any exceptions</li>
  <li><code class="prettyprint">not(throwAn[Exception].like { case e =&gt; e.message must startWith(&quot;FAIL&quot;) })</code> checks that an expression doesn't an exception with the specified message (another message is allowed)</li>
  <li><code class="prettyprint">not(throwAn[IllegalArgumentException])</code> checks that an expression doesn't throw any <code class="prettyprint">IllegalArgumentException</code> (but exceptions of other types are permitted)</li>
</ul>
<h3><a href="#for-exception-values" id="for-exception-values">for exception values</a></h3>
<ul>
  <li><code class="prettyprint">beException[ExceptionType](&quot;message&quot;)</code> checks that a <code class="prettyprint">Throwable</code> has an expected type and that its message satisfies<br/>
    a regular expression</li>
</ul>
<hr/>
<p>For all the above matchers you can use <code class="prettyprint">throwAn</code> instead of <code class="prettyprint">throwA</code> if the exception name starts with a vowel for better<br/>
readability.</p>
</td></tr></table></form></div><div class="tabbertab" title="Map"><form>
    <table><tr><td class="none" style="info"><p>Maps have their own matchers as well, to check keys and values:</p>
<ul>
  <li>
    <p><code class="prettyprint">haveKey</code> checks if a Map has a given key<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must haveKey(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">haveKeys</code> checks if a Map has several keys<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;, 2 -&gt; &quot;2&quot;) must haveKeys(1, 2)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">haveValue</code> checks if a Map has a given value<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must haveValue(&quot;1&quot;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">haveValues</code> checks if a Map has several values<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;, 2 -&gt; &quot;2&quot;) must haveValues(&quot;1&quot;, &quot;2&quot;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">havePair</code> checks if a Map has a given pair of values<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must havePair(1 -&gt; &quot;1&quot;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">havePairs</code> checks if a Map has some pairs of values<br/>
    <code class="prettyprint">Map(1-&gt;&quot;1&quot;, 2-&gt;&quot;2&quot;, 3-&gt;&quot;3&quot;) must havePairs(1-&gt;&quot;1&quot;, 2-&gt;&quot;2&quot;)</code></p>
  </li>
</ul>
<p>But Maps are also PartialFunctions, so:</p>
<ul>
  <li>
    <p><code class="prettyprint">beDefinedAt</code> checks if a PartialFunction is defined for a given value<br/>
    <code class="prettyprint">partial must beDefinedAt(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beDefinedBy</code> checks if a PartialFunction is defined for a given value<br/>
    and returns another one<br/>
    <code class="prettyprint">partial must beDefinedBy(1 -&gt; true)</code></p>
  </li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Any"><form>
    <table><tr><td class="none" style="info"><p>These matchers can be used with any object, regardless of its type:</p>
<ul>
  <li><code class="prettyprint">beLike { case exp =&gt; result }</code> checks if an object is like a given pattern. <code class="prettyprint">result</code> can be any expression using a matcher</li>
  <li><code class="prettyprint">beLike { case exp =&gt; exp must beXXX }</code> checks if an object is like a given pattern, and verifies a condition</li>
  <li><code class="prettyprint">beNull</code> checks if an object is null</li>
  <li><code class="prettyprint">beAsNullAs</code> when 2 objects must be null at the same time if one of them is null</li>
  <li><code class="prettyprint">beOneOf(a, b, c)</code> checks if an object is one of a given list</li>
  <li><code class="prettyprint">haveClass</code> checks the class of an object</li>
  <li><code class="prettyprint">haveSuperclass</code> checks if the class of an object as another class as one of its ancestors</li>
  <li><code class="prettyprint">haveInterface</code> checks if an object is implementing a given interface</li>
  <li><code class="prettyprint">beAssignableFrom</code> checks if a class is assignable from another</li>
  <li><code class="prettyprint">beAnInstanceOf[T]</code> checks if an object is an instance of type <code class="prettyprint">T</code></li>
</ul>
<h4><a href="#with-a-typeclass" id="with-a-typeclass">With a typeclass</a></h4>
<p>These matchers can be used with types having a specific typeclass instance:</p>
<table>
  <thead>
    <tr><th>Matcher    </th><th> Typeclass                       </th><th> Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code class="prettyprint">beEmpty</code>  </td><td> <code class="prettyprint">org.specs2.collection.IsEmpty</code> </td><td> matches values which can be described as &quot;empty&quot;: string, list, option,...</td></tr>
    <tr><td><code class="prettyprint">haveSize</code> </td><td> <code class="prettyprint">org.specs2.collection.Sized</code>   </td><td> matches values which can have a &quot;size&quot;: string, list, JSON,...</td></tr>
  </tbody>
</table>
</td></tr></table></form></div></div></td></tr></table></form></td>

### Optional

Those matchers are optional. To use them, you need to add a new trait to your specification:

<td class="info"><form>
    <table><tr><th colspan="101">Optional data matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="Result"><form>
    <table><tr><td class="none" style="info"><p>That's only if you want to check the result of other matchers!</p>
<pre><code>// you need to extend the ResultMatchers trait
class MatchersSpec extends Specification with matcher.ResultMatchers:
  def is =
    &quot;beMatching is using a regexp&quot; ! {
      (&quot;Hello&quot; must beMatching(&quot;h.*&quot;)) must beSuccessful
    }
</code></pre>
</td></tr></table></form></div><div class="tabbertab" title="Termination"><form>
    <table><tr><td class="none" style="info"><p>Sometimes you just want to specify that a block of code is going to terminate.<br/>
The <code class="prettyprint">org.specs2.matcher.TerminationMatchers</code> trait is here to help. If you mix in that trait, you can write:</p>
<pre><code>Thread.sleep(100) must terminate

// the default is retries = 0, sleep = 100.millis
Thread.sleep(100) must terminate(retries = 1, sleep = 60.millis)
</code></pre>
<p>Note that the behaviour of this matcher is a bit different from the <code class="prettyprint">eventually</code> operator. In this case, we let the current Thread sleep during the given <code class="prettyprint">sleep</code> time and then we check if the computation is finished, then, we retry for the given number of <code class="prettyprint">retries</code>.</p>
<p>In a further scenario, we might want to check that triggering another action is able to unblock the first one:</p>
<pre><code>action must terminate.when(action2)
action must terminate.when(&quot;starting the second action&quot;, action2)
action must terminate(retries = 3, sleep = 100.millis).when(action2)
</code></pre>
<p>When a second action is specified like that, <code class="prettyprint">Action</code> will be started and <code class="prettyprint">action2</code> will be started on the first retry. Otherwise, if you want to specify that <code class="prettyprint">Action</code> can <em>only</em> terminate when <code class="prettyprint">action2</code> is started, you write:</p>
<pre><code>action must terminate.onlyWhen(action2)
</code></pre>
<h4><a href="#executionenv" id="executionenv">ExecutionEnv</a></h4>
<p>The <code class="prettyprint">terminate</code> matcher needs an implicit <code class="prettyprint">ExecutionEnv</code> to be used. See the  page to learn how to get one.</p>
</td></tr></table></form></div></div></td></tr></table></form></td>
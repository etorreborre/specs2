
var tipuesearch = {"pages": [{"title":"User Guide", "text":" specs2 is a library for writing executable software specifications in Scala. With specs2 you can write: * specifications for simple classes (*unit* specifications) * specifications for full features (*acceptance* specifications)  In this user guide, you will find: <li class=\"example success\"/>a  <li class=\"example success\"/>how to  <li class=\"example success\"/>how to use  <li class=\"example success\"/>how to  And much more!           ", "tags":"", "loc":"org.specs2.guide.UserGuide.html"},
{"title":"How to", "text":" Question                                                                                | See---------------------------------------------------------------------------------------- | ------How to execute an action before all the examples?                                        | How to execute an action before each example?                                            | Can I create and reuse a Specification \"template\"?                                       | How can I pass some data to each example?                                                | Can I add more information to my results for easier diagnostic?                          | Is it possible to execute a Specification sequentially?                                  | How to mark an example as `pending` until it is fixed?                                   | Can I simply mark a block of code as `pending`?                                          | Is there a way to run only one example?                                                  | I would like to display the execution time of each example                               | Can I use a for loop to create examples or results?                                      | How can I tag examples?                                                                  | Can I skip examples?                                                                     | Is it possible to modify the behaviour of a Specification with command-line arguments?   | How to capture snippets of code and add them to my Specification?                        | Can I create an HTML index of all the specifications?                                    | Is it possible to execute a Specification in a random order?                             | How can I easily print expressions to the console?                                       | Can specs2 create a JUnit xml file for a continuous integration server?                 | Is it possible to reduce the number of implicits in scope and improve compilation times? | How can I collect execution data?                                                        | Can I display some data when an example succeeds?                                        | Can I create an example description spanning several lines?                              | How to isolate each example from another so that they don't share variables              | How to timeout examples?                                                                 | Can I use parts of an example description in the example itself?                         | Help, I need to troubleshoot my issues!                                                  | ", "tags":"", "loc":"org.specs2.guide.HowTo.html"},
{"title":"Troubleshooting", "text":"This section presents some of the common pitfalls you might face when using specs2 and Scala vals vs lazy valsThe common symptom here is a `NullPointerException` for some attributes of your specification. You can refer to this [link](http://engineering.tapad.com/blog/2012/11/here-there-be-dragons-dangers-of-initialization-order-in-scala/) for an explanation of variable initialization in Scala. In the meantime the basic fix is to use a `lazy val` instead of a `val`. Lost expectationsYou might expect the following specification to fail:class ShouldItFail extends Specification { def is = s2\"\"\"  Should this example fail? $e1\"\"\"  def e1 = {    1 must_== 100000 // do you expect this to fail    10 must_== 10  }}However, as explained in  - Thrown expectations, the first expectation is lost because, by default, no exceptions are thrown in an acceptance specification.In that case you can either: - create 2 examples having one expectation each - mix-in the `ThrownExpectations` trait No evidence parameter for AsResultHere is a mysterious `AsResult` messageclass MysteriousAsResult extends mutable.Specification {  \"Try this\" in {    1 must_== 1    println(\"this is ok, right?\")  }}[error] could not find implicit value for evidence parameter of type org.specs2.execute.AsResult[Unit]What's happening? Each example must return a value of type `T` where `T` has an `AsResult` instance. This is the case if `T` is a `Boolean`, a `MatchResult`, a ScalaCheck `Prop` etc... (see ). In the class above the return value is `Unit` which doesn't have an `AsResult` instance.To fix this you can either: - either return `ok` after `println` - create your own matcher (see ) and make sure you have a proper expectation for your example - add an `AsResult[Unit]` instance like thisimplicit def unitAsResult: AsResult[Unit] = new AsResult[Unit] {  def asResult(r: =>Unit) =    ResultExecution.execute(r)(_ => Success())} Type mismatchThis is also a tricky one, showing the limitations of embedding a pseudo-natural language into a programming language:class Inference extends mutable.Specification {  \"It doesn't mean what you think it does\" >> {    List(1, 2, 3) must not beNull    List(1, 2) must have size(2)  }}[error] type mismatch;[error]  found   : List[Int][error]  required: org.specs2.matcher.Matcher[List[Int]][error]     List(1, 2) must have size(2)[error]         The first statement is parsed as `issue.must(not).beNull` as if `beNull` was a method expecting an argument on the next line (this is well explained in this [StackOverflow question](http://stackoverflow.com/questions/14336699/specs2-multiple-matcher-expressions-unit-specification)).The possible fixes are: - use parentheses around `beNull`, like this: `not(beNull)` - use a semi-column after the first line YrangeposThe `Yrangepos` scalac option (see ) is necessary to get proper Fragment locations when using `s2` interpolated strings. However this option sometimes breaks some macros with messages like [`[info] Unpositioned tree #931`](https://github.com/non/kind-projector/issues/7). In that case you should remove that option from your build. You will still be able to use `s2` interpolation strings but fragment locations will be less precise. Custom outputYou created a custom `Notifier` or another class for reporting and when you use it nothing happens. In that case add the `verbose` argument to the command line and you will get more messages including exceptions and stacktraces about what is going on.", "tags":"", "loc":"org.specs2.guide.Troubleshooting.html"},
{"title":"Detailed topics", "text":" Topic                                                                                   | See---------------------------------------------------------------------------------------- | ------Create an example with just some code as the description                                 | Use the Given/When/Then style                                                            | Gather all expectations in an example                                                    | Reference another specification                                                          | Add formatting to a specification                                                        | Create example names automatically in an acceptance specification                        | Infer example descriptions from text in an acceptance specification                      | Create HTML tables to specify examples                                                   | Create examples \"on the fly\" as the specification executes                               | Create an example with different data displayed in a table                               | Fragments API                                                                            | Create an example with different data displayed in a table                               | Use specs2 environment (command-line args, file system...)                              | Execution environment for Futures                                                        | Create a new type of Result                                                              | Other build tools                                                                        | Syntax variations with matchers                                                          | Matchers for case classes                                                                | Matchers for packages dependencies                                                       | Use specs2 matchers outside of specs2                                                  | Matchers reference card                                                                  | Arguments reference card                                                                 | ", "tags":"", "loc":"org.specs2.guide.DetailedTopics.html"},
{"title":"Installation", "text":"There are 3 preferred ways to install specs2: - [sbt](http://scala-sbt.org) - [maven](http://maven.apache.org) - [gradle](http://gradle.org) SBTFirst you need to [install sbt itself](http://www.scala-sbt.org/release/tutorial/Setup.html) then you need to add the following dependency:libraryDependencies += \"org.specs2\" %% \"specs2-core\" % \"3.6.4-20151016053644-0ca99ef\" % \"test\"scalacOptions in Test ++= Seq(\"-Yrangepos\")See [here](http://www.scala-sbt.org/release/tutorial/Library-Dependencies.html) to learn more about sbt dependencies. MavenYou can install Maven from [there](http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html). Once installed, you need to create a `pom.xml` file with the [`maven-scala-plugin`](http://davidb.github.io/scala-maven-plugin/plugin-info.html). In the `pom.xml` file you can add the following dependency:<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  ...<dependencies>  <dependency>    <groupId>org.specs2</groupId>    <artifactId>specs2-core_2.11</artifactId>    <version>3.6.4-20151016053644-0ca99ef</version>    <scope>test</scope>  </dependency></dependencies>  ...</project> GradleGo to this [page](http://www.gradle.org/installation) to install Gradle. You then need to install the [Scala plugin](http://www.gradle.org/docs/current/userguide/scala_plugin.html) and add the following to your `build.gradle` file:repositories {  maven {     url \"https://oss.sonatype.org/content/repositories/releases\"  }}dependencies {  testCompile \"org.specs2:specs2-core_2.11:3.6.4-20151016053644-0ca99ef\"} Other dependenciesDepending on the specs2 features you want to use you will need to add more dependencies to your build: Name                    | Functionality ----------------------- | -------------- `specs2-matcher-extra`  | for the optional specs2 matchers `specs2-scalacheck`     | to use ScalaCheck properties in specifications `specs2-mock`           | to use Mockito matchers `specs2-analysis`       | to use the package dependencies matcher `specs2-gwt`            | to write given/when/then specifications `specs2-html`           | to export specifications as html `specs2-form`           | to create html form-like specifications `specs2-junit`          | to run specifications as JUnit testsNote: the `specs2-core` jar depends on 2 other specs2 jars: Name                    | Functionality ----------------------- | -------------- `specs2-common`         | utility classes for text, collections, xml,... `specs2-matcher`        | common specs2 matchers. They can be used as a stand-alone library with [JUnit](http://junit.org)", "tags":"", "loc":"org.specs2.guide.Installation.html"},
{"title":"Mockito", "text":"[Mockito](https://code.google.com/p/mockito) allows to specify stubbed values and to verify that some calls have been made to your objects. In order to use those features, you need to extend the `org.specs2.mock.Mockito` trait:class MockitoSpec extends Specification with Mockito { def is = s2\"\"\"A java list can be mocked  You can make it return a stubbed value        ${c().stub}  You can verify that a method was called       ${c().verify}  You can verify that a method was not called   ${c().verify2}\"\"\"  case class c() {    val m = mock[java.util.List[String]] // a concrete class would be mocked with: mock[new java.util.LinkedList[String]]    def stub = {      m.get(0) returns \"one\"             // stub a method call with a return value      m.get(0) must_== \"one\"             // call the method    }    def verify = {      m.get(0) returns \"one\"             // stub a method call with a return value      m.get(0)                           // call the method      there was one(m).get(0)            // verify that the call happened    }    def verify2 = there was no(m).get(0) // verify that the call never happened  }} Creation and settingsMockito offers the possibility to provide specific settings for the mock being created: * a name`val m = mock[List[String]].as(\"list1\")` * [\"smart\" return values](https://code.google.com/p/specs/wiki/UsingMockito#Smart_mocks)`val m = mock[List[String]].smart` * `verbose` to enable Mockito's verbose logging`val m = mock[List[String]].verbose` * specific return values`val m = mock[List[String]].defaultReturn(10)` * specific answers // a function InvocationOnMock => V is used in place of the org.mockito.stubbing.Answer type for better concisenessval helloObject = (p1: InvocationOnMock) => \"hello \"+p1.toStringval m = mock[List[String]].defaultAnswer(helloObject) * extra interfaces val m1 = mock[List[String]].extraInterface[Cloneable]val m2 = mock[List[String]].extraInterfaces[Cloneable, Serializable]Now, if you want to combine several of those settings together you need to call the `settings` method: val m1 = mock[List[String]].settings(name = \"list1\",  defaultReturn = 10,  extraInterfaces = classesOf[Cloneable, Serializable])// orval m2 = mock[List[String]].settings(smart = true,  extraInterface = classOf[Cloneable])Finally, you can pass a `org.mockito.MockSettings` object directly to the `mock` method: val settings = org.mockito.Mockito.withSettingsval m = mock[List[String]](settings) StubbingStubbing values is as simple as calling a method on the mock and declaring what should be returned or thrown: m.get(1) returns \"one\"m.get(2) throws new RuntimeException(\"forbidden\")You can specify different consecutive returned values by appending `thenReturns` or `thenThrows`: m.get(1) returns \"one\" thenReturns \"two\"m.get(2) throws new RuntimeException(\"forbidden\") thenReturns \"999\" Mocking and Stubbing at the same timeIt is also possible to create a mock while stubbing one of its methods, provided that you declare the type of the expected mock: val mocked: java.util.List[String] = mock[java.util.List[String]].contains(\"o\") returns truemocked.contains(\"o\") must beTrue With matchersThe built-in Mockito argument matchers can be used to specify the method arguments for stubbing: m.get(org.mockito.Matchers.anyInt()) returns \"element\"m.get(999) must_== \"element\"specs2 matchers can also be passed directly as arguments: m.get(===(123)) returns \"one\"*Note*: the call above works because there is an implicit method `argThat` which transforms a specs2 `Matcher[T]` into a Hamcrest one and in turn call Mockito's `org.mockito.Matchers.argThat` method to register the Hamcrest matcher. However [sometimes](https://groups.google.com/forum/#!msg/specs2-users/_slOZQoICzU/DF-ZQCq_GmkJ) the implicit conversion is not called and you have to explicitly call the `argThat` method like so: m.get(argThat(===(123))) returns \"one\" CallbacksIn some rare cases, it is necessary to have the return value depend on the parameters passed to the mocked method: m.get(anyInt) answers { i => \"The parameter is \" + i.toString }The function passed to `answers` will be called with each parameter passed to the stubbed method: m.get(0)    // returns \"The parameter is 0\"m.get(1)    // the second call returns a different value: \"The parameter is 1\"To use specific a type of argument: m.get(anyInt) answers { _ match { case i: Int => (i + 1).toString } }Or more concisely: m.get(anyInt) responds { case i: Int => (i + 1).toString } Parameters for the `answers` functionBecause of the use of reflection the function passed to answers will receive only instances of the `java.lang.Object` type.More precisely, it will: * pass the mock object if both the method has no parameters and the function has one parameter:`mock.size answers { mock => mock.hashCode }` * pass the parameter if both the method and the function have one parameter:`mock.get(0) answers { i => i.toString }` * pass the parameter and the mock object if the method has 1 parameter and the function has 2:`mock.get(0) answers { (i, mock) => i.toString + \" for mock \" + mock.toString }`In any other cases, if `f` is a function of 1 parameter, the array of the method parameters will be passed and if the function has 2 parameters, the second one will be the mock. VerificationBy default Mockito doesn't expect any method to be called. However if you are writing interaction-based specifications you want to specify that some methods are indeed called: there was one(m).get(0)              // one call only to get(0)there was no(m).get(0)               // no calls to get(0)// were can also be usedthere were two(m).get(0)             // 2 calls exactly to get(0)there were three(m).get(0)           // 3 calls exactly to get(0)there were 4.times(m).get(0)         // 4 calls exactly to get(0)there was atLeastOne(m).get(0)       // at least one call to get(0)there was atLeastTwo(m).get(0)       // at least two calls to get(0)there was atLeastThree(m).get(0)     // at least three calls to get(0)there was atLeast(4)(m).get(0)       // at least four calls to get(0)there was atMostOne(m).get(0)        // at most one call to get(0)there was atMostTwo(m).get(0)        // at most two calls to get(0)there was atMostThree(m).get(0)      // at most three calls to get(0)there was atMost(4)(m).get(0)        // at most four calls to get(0)// the combinators above, except `atMost`, can also be used with a timeoutthere was after(10.millis).one(m).get(0)there was after(2.seconds).two(m).get(0)It is also possible to add all verifications inside a block, when several mocks are involved: got {  one(m).get(0)  two(m).get(1)} Order of callsThe order of method calls can be checked by creating calls and chaining them with `andThen`: val m1 = mock[java.util.List[String]]m1.get(0)m1.get(1)there was one(m1).get(0) andThen one(m1).get(1)when several mocks are involved, the expected order must be specified as an implicit value: val m1 = mock[java.util.List[String]]val m2 = mock[java.util.List[String]]val m3 = mock[java.util.List[String]]// the order of mock objects doesn't matter hereimplicit val order = inOrder(m1, m3, m2)m1.get(1); m2.get(2); m3.get(3)there was one(m1).get(1) andThen one(m2).get(2) andThen one(m3).get(3) Ignoring stubsWhen specifying the behavior of an object in relation to others you may want to verify that some mocks have been called as collaborators and you don't really want to specify what happens to other mocks because they are just playing the role of stubs.In this case the `ignoreStubs` method can be used: val (stub1, stub2) = (mock[AStub], mock[AStub])there were noMoreCallsTo(ignoreStubs(stub1, stub2))This method is also available with the `inOrder` method: implicit val order = inOrder(ignoreStubs(list1, list2))For more documentation about this Mockito functionality, please read [here](http://docs.mockito.googlecode.com/hg/1.9.0/org/mockito/Mockito.html#25). SpiesSpies can be used to do \"partial mocking\" of real objects: val spiedList = spy(new LinkedList[String])// methods can be stubbed on a spyspiedList.size returns 100// other methods can also be usedspiedList.add(\"one\")spiedList.add(\"two\")// and verification can happen on a spythere was one(spiedList).add(\"one\")However, working with spies can be tricky: // if the list is empty, this will throws an IndexOutOfBoundsExceptionspiedList.get(0) returns \"one\"As advised in the Mockito documentation, `doReturn` must be used in that case: org.mockito.Mockito.doReturn(\"one\").when(spiedList).get(0) Functions / PartialFunctionsIt is possible to verify method calls where parameters are functions by specifying how the passed function will react to a given set of arguments. Given the following mock:trait Amount {  // a method showing an amount precision  def show(display: (Double, Int) => String) = ???}val amount = mock[Amount]If the mock is called with this function: amount.show((amount: Double, precision: Int) => \"%2.\"+precision+\"f\" format amount)Then it is possible to verify how the mock was called: // with sample arguments for the function and the expected resultthere was one(amount).show((32.4456, 2) -> \"32.45\")// with a matcher for the resultthere was one(amount).show((32.4456, 2) -> endWith(\"45\"))// with any Function2[A, B, R]there was one(amount).show(anyFunction2) Auto-boxingAuto-boxing might interfere with the mocking of PartialFunctions. Please have a look at [this](https://groups.google.com/d/topic/specs2-users/_bK8lCCjZ4c/discussion) for a discussion. BynameByname parameters can be verified but this will not work if the specs2 jar is not put first on the classpath, before the mockito jar. Indeed specs2 redefines a Mockito class for intercepting method calls so that byname parameters are properly handled.", "tags":"", "loc":"org.specs2.guide.UseMockito.html"},
{"title":"ScalaCheck", "text":"A clever way of creating expectations in specs2 is to use the [ScalaCheck](https://github.com/rickynils/scalacheck) library.To declare ScalaCheck properties you first need to extend the `org.specs2.ScalaCheck` trait. Then you can pass functions returning any kind of `Result` (`Boolean`, `Result`, `MatchResult` or a ScalaCheck `Prop`) to the `prop` method and use the resulting `Prop` as your example body: s2\"addition and multiplication are related ${ prop { (a: Int) => a + a == 2 * a } }\"The function that is checked can either return: // a Booleans2\"addition and multiplication are related ${ prop { (a: Int) => a + a == 2 * a } }\"// a MatchResults2\"addition and multiplication are related ${ prop { (a: Int) => a + a must_== 2 * a } }\"// a Props2\"addition and multiplication are related ${ prop { (a: Int) => (a > 0) ==> (a + a must_== 2 * a) } }\"Note that if you pass functions using `MatchResult`s you will get better failure messages than just using boolean expressions.By default the properties created with `prop` will be shrinking counter-examples. But as you will see below there lots of different ways to parameterize ScalaCheck properties in specs2, including declaring if shrinking must be done. Arbitrary instancesScalaCheck requires an implicit `Arbitrary[T]` instance for each parameter of type `T` used in a property. If you rather want to pick up a specific `Arbitrary[T]` for a given property argument you can modify the `prop` with to use another `Arbitrary` instance: s2\"\"\"  a simple property       $ex1  a more complex property $ex2\"\"\"def abStringGen = (Gen.oneOf(\"a\", \"b\") |@| Gen.oneOf(\"a\", \"b\"))(_+_)implicit def abStrings: Arbitrary[String] =  Arbitrary(abStringGen)def ex1 = prop((s: String) => s must contain(\"a\") or contain(\"b\")).setArbitrary(abStrings)// use the setArbitrary<n> method for the nth argumentdef ex2 = prop((s1: String, s2: String) => (s1+s2) must contain(\"a\") or contain(\"b\")).            setArbitrary1(abStrings).setArbitrary2(abStrings)It is also possible to pass a `Gen[T]` instance instead of an `Arbitrary[T]`: val abStringGen = (Gen.oneOf(\"a\", \"b\") |@| Gen.oneOf(\"a\", \"b\"))(_+_)def ex1 = prop((s: String) => s must contain(\"a\") or contain(\"b\")).setGen(abStringGen) With Shrink / PrettySpecific Shrink and Pretty instances can also be specified at the property level: val shrinkString: Shrink[String] = ???// set a specific shrink instance on the second parameterprop((s1: String, s2: String) => s1.nonEmpty or s2.nonEmpty).setShrink2(shrinkString)// set a specific pretty instanceprop((s: String) => s must contain(\"a\") or contain(\"b\")).setPretty((s: String) =>  Pretty((prms: Pretty.Params) => if (prms.verbosity >= 1) s.toUpperCase else s))// or simply if you don't use the Pretty parametersprop((s: String) => s must contain(\"a\") or contain(\"b\")).pretty((_: String).toUpperCase) ContextsScalaCheck properties are sometimes used to test stateful applications rather than pure functions. For example you want to test that a function is writing files somewhere and you would like those files to be deleted after each property execution: def createFile(f: File): Unit = ???def deleteTmpDir(): Unit = ???prop { f: File =>  createFile(f)  f.exists}.after(deleteTmpDir) // before and beforeAfter can also be used thereYou can also \"prepare\" the property to be tested based on the generated arguments: def createFile(directory: File, f: File): Unit = ???// this method will keep the arguments intact but can// have a side-effect to prepare the systemdef setupDirectoryAndFile = (directory: File, file: File) => (directory, file)prop { (directory: File, f: File) =>  createFile(directory, f)  f.exists}.prepare(setupDirectoryAndFile)Note that there is a way to [model stateful systems](https://github.com/rickynils/scalacheck/wiki/User-Guide#stateful-testing) with ScalaCheck which goes beyond the simple setup/teardown testing done here. Test properties Default valuesScalaCheck test generation can be tuned with a few properties. If you want to change the default settings, you have to use implicit values: implicit val params = Parameters(minTestsOk = 20) // add \".verbose\" to get additional console printingThe parameters you can modify are: Parameter         | Default                | Description ----------------- | ---------------------- | ------------ `minTestsOk`      | `100`                  | minimum of tests which must be ok before the property is ok `maxDiscardRatio` | `5.0f`                 | if the data generation discards too many values, then the property can't be proven `minSize`         | `0`                    | minimum size for the \"sized\" data generators, like list generators `maxSize`         | `100`                  | maximum size for the \"sized\" data generators `workers`         | `1`                    | number of threads checking the property `rng`             | `new java.util.Random` | the random number generator `callback`        |                        | a ScalaCheck TestCallback (see the [ScalaCheck documentation](http://www.scalacheck.org)) `loader`          |                        | a custom classloader (see the [ScalaCheck documentation](http://www.scalacheck.org)) `prettyParams`    |                        | a `Pretty.Params` instance to set the verbosity level when displaying `Pretty` instances Property levelIt is also possible to specifically set the execution parameters on a given property: class ScalaCheckSpec extends mutable.Specification with ScalaCheck {  \"this is a specific property\" >> prop { (a: Int, b: Int) =>    (a + b) must_== (b + a)  }.set(minTestsOk = 200, workers = 3) // use \"display\" instead of \"set\" for additional console printing}You can also set the random generator that is used in all the ScalaCheck generators: case class MyRandomGenerator() extends java.util.Random {  // implement a deterministic generator for example}\"this is a specific property\" ! prop { (a: Int, b: Int) =>  (a + b) must_== (b + a)}.set(rng = MyRandomGenerator(), minTestsOk = 200, workers = 3) Command-lineSome properties can be overridden from the command line Parameter         | Command line ----------------- | ------------ `minTestsOk`      | `scalacheck.mintestsok` `maxDiscardRatio` | `scalacheck.maxdiscardratio` `minSize`         | `scalacheck.minsize` `maxSize`         | `scalacheck.maxsize` `workers`         | `scalacheck.workers` `verbose`         | `scalacheck.verbose` ExpectationsBy default, a successful example using a `Prop` will be reported as 1 success and 100 (or `minTestsOk`) expectations. If you don't want the number of expectations to appear in the specification statistics just mix-in your specification the `org.specs2.scalacheck.OneExpectationPerProp` trait. Collect valuesIt is important to validate that generated values are meaningful. In order to do this you can use `collect` to collect values: // for a property with just one argumentprop((i: Int) => i % 2 == 0).collect// for a property with just 2 arguments// collect the second value onlyprop((i: Int, j: Int) => i > 0 && j % 2 == 0).collect2// collect the second value but map it to something elseprop((i: Int, j: Int) => i > 0 && j % 2 == 0).collectArg2((n: Int) => \"the value \"+n)// collect all values and displayprop((i: Int, j: Int) => i > 0 && j % 2 == 0).collectAll.verboseNote that, by default, nothing will be printed on screen unless you set the reporting to `verbose` by either: - changing the default `Parameters` - setting `.verbose` at the property level - passing `scalacheck.verbose` on the command-line EquivalenceThe `==>` operator in ScalaCheck helps you specify under which conditions a given property is applicable. However it only works one way, you cannot declare that a property must be true \"if and only if\" some conditions are respected.With specs2 and the `org.specs2.execute.ResultImplicits` trait you can use the `<==>` operator to declare the equivalence of 2 `Results`, whether they are properties or booleans or `MatchResults`. So you can write: // replace 55 with whatever you think \"old\" is...prop((i: Int) => (i >= 18 && i <= 55) <==> isYoung(i))", "tags":"", "loc":"org.specs2.guide.UseScalaCheck.html"},
{"title":"Contexts", "text":"In a specification some examples are very straightforward. They just check that a function is returning expected values when given some inputs. However other examples can be more complex and require to execute in a specific context: * with some state being setup before the example executes * with some state being cleaned up after the example is executed * inside a database context, with or without the possibility to access the transaction context * with state being setup before *all* examples * with state being cleaned up after *all* the examplesFor all those situations, there is a specs2 trait which you can mix in your specification. BeforeEach / AfterEachThe `org.specs2.specification.BeforeEach` trait defines an action that will be executed before each example:class BeforeSpecification extends mutable.Specification with BeforeEach {  // you need to define the \"before\" action  def before = println(\"before\")  \"example 1\" >> {    println(\"example1\"); ok  }  \"example 2\" >> {    println(\"example2\"); ok  }}If you execute this specification you may see something like:console[info] before[info] before[info] example2[info] example1As you can guess, defining a behaviour \"after\" is very similar:class AfterSpecification extends mutable.Specification with AfterEach {  // you need to define the \"after\" action  def after = println(\"after\")  \"example 1\" >> {    println(\"example1\"); ok  }  \"example 2\" >> {    println(\"example2\"); ok  }}You might also want to mix the two:class BeforeAfterSpecification extends mutable.Specification with BeforeAfterEach {  def before = println(\"before\")  def after  = println(\"after\")  \"example 1\" >> {    println(\"example1\"); ok  }  \"example 2\" >> {    println(\"example2\"); ok  }} AroundEachAnother very common situation is when you need to execute in the context of a database transaction or a web request. In this case you can use the `AroundEach` trait to execute each example in the proper context:trait DatabaseContext extends AroundEach {  // you need to define the \"around\" method  def around[R: AsResult](r: => R): Result = {    openDatabaseTransaction    try AsResult(r)    finally closeDatabaseTransaction  }  // do what you need to do with the database  def openDatabaseTransaction = ???  def closeDatabaseTransaction = ???}class AroundSpecification extends mutable.Specification with DatabaseContext {  \"example 1\" >> {    println(\"using the database\"); ok  }  \"example 2\" >> {    println(\"using the database too\"); ok  }}The specification above shows a trait `DatabaseContext` extending `AroundEach` (so that trait can be reused for other specifications). It defines a method named `around` taking the body of the example, anything with an  typeclass, and returns a result. Because `r` is a byname parameter, you are free to do whatever you want before or after evaluating it, like opening and closing a database transaction.The `AroundEach` trait can be used for lots of different purposes: - to re-execute examples a number of times - to time them out if they run for too long - to run them in different contexts, with different parametersThere is however one thing you cannot do with `AroundExample`. You can't pass the context to the example if it needs it. The `ForEach` trait solves this problem. ForEachSometimes you need to create a specific context for each example but you also want to make it accessible to each example. Here is a specification having examples using an active database transaction:// a transaction with the databasetrait Transactiontrait DatabaseContext extends ForEach[Transaction] {  // you need to define the \"foreach\" method  def foreach[R: AsResult](f: Transaction => R): Result = {    val transaction = openDatabaseTransaction    try AsResult(f(transaction))    finally closeDatabaseTransaction(transaction)  }  // create and close a transaction  def openDatabaseTransaction: Transaction = ???  def closeDatabaseTransaction(t: Transaction) = ???}class FixtureSpecification extends mutable.Specification with DatabaseContext {  \"example 1\" >> { t: Transaction =>    println(\"use the transaction\")    ok  }  \"example 2\" >> { t: Transaction =>    println(\"use it here as well\")    ok  }} BeforeAll / AfterAllSome setups are very expensive and can be shared across all examples. For example you might want to start an application server just at the beginning of the specification and then close it at the end. You can use 3 traits to do this: * `BeforeAll` inserts a `Step` before all the examples * `AfterAll` inserts a `Step` after all the examples * `BeforeAfterAll` inserts one `Step` before all the examples and one `Step` after all of them And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">   read about specs2  to understand how `Examples` and `Steps` are being executed * use  to create contexts for just a few examples in the specification * use  to create contexts in unit specifications where you can access state directly on variables</div>", "tags":"", "loc":"org.specs2.guide.Contexts.html"},
{"title":"Runners", "text":"The most common way to run specs2 specifications is to use [sbt](http://scala-sbt.org). In this section we will present the most important options for running specifications Via sbt[Sbt](www.scala-sbt.org) recognizes specs2 as a [\"test framework\"](http://www.scala-sbt.org/release/docs/Testing.html). This means that any class or object extending the `Specification` abstract class can be executed by sbt. The `test` command will run all the specifications in your project provided you put them in the `src/test/scala` directory:sbt> testMost of the time however you will use the `testOnly` command, either because you want to run one specification only or because you want to pass arguments:sbt> testOnly org.acme.secret.KillerAppSpecOnly show failed tests:sbt> testOnly org.acme.secret.KillerAppSpec -- xonly sbt optionsVarious sbt options can apply to [test execution in sbt](http://www.scala-sbt.org/release/docs/Testing.html) but here are the ones which you are most likely to use: - exclude some specifications:   `testOptions := Seq(Tests.Filter(s => Seq(\"Spec\", \"Unit\").exists(s.endsWith)))` - don't execute the specifications in parallel   `parallelExecution in Test := false` - pass specs2 arguments to all specifications   `testOptions in Test += Tests.Argument(\"exclude\", \"integration\")` - display results as soon as they've been executed   `logBuffered := false` OutputWhen you run a specification, whatever environment you are in: sbt, shell, IDE,... you can specify different outputs for the results. For example, when you execute a specification with sbt, the results appear in the console. If you want JUnit XML files to be produced instead you need to pass the `junitxml` argument. Adding any \"output\" argument will deactivate the console (you will see no output in the console) but you can enable it again by passing the `console` argument. You can of course specify several outputs like `html junitxml console`.Here is a list of all the existing `Printers` in specs2 with links to the corresponding section in the User Guide for more information.<div markdown='1'> Argument   | Section ---------- | ----------------------- `console`  |  `junitxml` |  `html`     |  `markdown` |  `notifier` |  `printer`  | </div> ArgumentsWith the `testOnly` command arguments can be passed on the command line for selecting, executing or reporting a specification. Please consult the following sections for more information: -  to select only some example to run -  to modify the execution parameters - , , ... for \"reporting\" arguments - the  for a list of all arguments Now learn how to... {.ribbon .both-ribbon}<div class=\"ribbon-content\">   run specifications : [IntelliJ IDEA](http://www.jetbrains.com/idea/features/scala.html), [ScalaIDE](http://scala-ide.org) * output  to run in a continuous integration server like [Jenkins](http://jenkins-ci.org) * </div> And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">   run specifications with : maven, gradle * run specificationsoutputuse your  by implementing the `Notifier` interface (simple) or the `Printer` interface * execute  with the `all` argument</div>", "tags":"", "loc":"org.specs2.guide.Runners.html"},
{"title":"Matchers", "text":"The most frequent way to specify some expected behaviour with specs2 is to use _matchers_. You generally execute an action, a command or a function and then check if the actual value you get is equal to an expected one (the [\"arrange-act-assert\"](http://bit.ly/arrange_act_assert) paradigm).For example, if you create a specification for an object manipulating paths:// describe the functionalitys2\"the directoryPath method should return well-formed paths $e1\"// give an example with some codedef e1 = Paths.directoryPath(\"/tmp/path/to/dir\") must beEqualTo(\"/tmp/path/to/dir/\")The `must`{.scala} operator takes the actual value returned by `directoryPath` and applies it to a `Matcher` built with the expected value. `beEqualTo` is one of the many matchers defined by specs2, it just checks if 2 values are equal.In the following sections you will learn: - the different ways of checking the [equality](#equality) of values - to use the matchers for the most [common data types](#out-of-the-box) in Scala, and most notably `Traversable`s - to use [other types of matchers](#optional) in less common situations: json, xml, files, parsers combinators... - how to [derive](#derive-matchers) a new matcher from an existing one - how to create [your own matchers](#create-your-own) EqualityThe most common type of matcher is `beEqualTo` to test the equality of 2 values. Several syntaxes can be used, according to your own taste Matcher                    |  Comment -------------------------- | -------------------------- `1 must beEqualTo(1)      `| the normal way `1 must be_==(1)          `| with a symbol `1 must_== 1              `| my favorite! `1 mustEqual 1            `| if you dislike underscores `1 should_== 1            `| for `should` lovers `1 === 1                  `| the ultimate shortcut `1 must be equalTo(1)     `| with a literate styleThere are also other notions of equality Matcher                    |  Comment -------------------------- | -------------------------- `beTypedEqualTo           `| typed equality. `a must beTypedEqualTo(b)` will not work if `a` and `b` don't have compatible types `be_===                   `| synonym for `beTypedEqualTo` `a ==== b                 `| synonym for `a must beTypedEqualTo(b)` `a must_=== b             `| similar to `a must_== b` but will not typecheck if `a` and `b` don't have the same type `be_==~                   `| check if `(a: A) == conv(b: B)` when there is an implicit conversion `conv` from `B` to `A` `beTheSameAs              `| reference equality: check if `a eq b` (`a must be(b)` also works) `be                       `| `a must be(b)`: synonym for `beTheSameAs` `beTrue, beFalse          `| shortcuts for Boolean equality_Note_: the `beEqualTo` matcher is using the regular `==` Scala equality. However in the case of `Arrays`, Scala `==` is just using reference equality, `eq`. So the `beEqualTo` matcher has been adapted to use the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested), before checking for equality, so that `Array(1, 2, 3) === Array(1, 2, 3)` (despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`).Now let's check the other matchers. Out of the boxThese are the all the available matchers when you extend `Specification` OptionalThose matchers are optional. To use them, you need to add a new trait to your specification: Derive matchersThe easiest way to create a new matcher is to derive it from an existing one. You can: * use logical operators def beBetween(i: Int, j: Int) = be_>=(i) and be_<=(j) * \"adapt\" the actual value // This matcher adapts the existing `be_<=` matcher to a matcher applicable to `Any`def beShort1 = be_<=(5)  { (t: Any) => t.toString.size }// you can use aka to provide some information about the original value, before adaptationdef beShort2 = be_<=(5)  { (t: Any) => t.toString.size aka \"the string size\" }// !!! note: use a BeTypedEqualTo matcher when using aka and equality, otherwise you will be matching against Expectable[T] !!!def beFive = be_===(5)  { (t: Any) => t.toString.size aka \"the string size\" }// The adaptation can also be done the other way around when it's more readabledef haveExtension(extension: =>String) = ((_:File).getPath)  endWith(extension) * adapt the actual and expected values. This matcher compares 2 `Human` objects but set their `wealth` field to 0   so that the equals method will not fail on that field: def beMostlyEqualTo = (be_==(_:Human))  ((_:Human).copy(wealth = 0))// thenHuman(age = 20, wealth=1000) must beMostlyEqualTo(Human(age = 20, wealth=1)) // success * use `eventually` to try a match a number of times until it succeeds: val iterator = List(1, 2, 3).iterator// Use eventually(retries, n.millis) to use another number of tries and waiting timeiterator.next must be_==(3).eventually * use `await` to create a matcher that will match on `Matcher[Future[T]]` (this requires an ): Future(1) must be_>(0).awaitFuture { Thread.sleep(100); 1 } must be_>(0).await(retries = 2, timeout = 100.millis) * use `attempt` to create a matcher that will match on `Matcher[scalaz.concurrent.Future[T]]` (this requires an ): // see the Matchers-Futures reference card on how to get an ExecutionEnvimplicit val ee: ExecutionEnv = ???  scalaz.concurrent.Future(1) must be_>(0).attemptscalaz.concurrent.Future { Thread.sleep(100); 1 } must be_>(0).attempt(retries = 2, timeout = 100.millis) * use `when` or `unless` to apply a matcher only if a condition is satisfied: 1 must be_==(2).when(false)                        // will return a success1 must be_==(2).unless(true)                       // same thing1 must be_==(2).when(false, \"don't check this\")    // will return a success1 must be_==(2).unless(true, \"don't check this\")   // same thing * use `iff` to say that a matcher must succeed if and only if a condition is satisfied: 1 must be_==(1).iff(true)                        // will return a success1 must be_==(2).iff(true)                        // will return a failure1 must be_==(2).iff(false)                       // will return a success1 must be_==(1).iff(false)                       // will return a failure * use `orSkip` to return a `Skipped` result instead of a Failure if the condition is not satisfied 1 must be_==(2).orSkip1 must be_==(2).orSkip(\"Precondition failed\")    // prints \"Precondition failed: '1' is not equal to '2'\"1 must be_==(2).orSkip((ko:String) => \"BAD \"+ko) // prints \"BAD '1' is not equal to '2'\" * use `orPending` to return a `Pending` result instead of a Failure if the condition is not satisfied 1 must be_==(2).orPending1 must be_==(2).orPending(\"Precondition failed\")    // prints \"Precondition failed: '1' is not equal to '2'\"1 must be_==(2).orPending((ko:String) => \"BAD \"+ko) // prints \"BAD '1' is not equal to '2'\" * use `zip` operators to match each value of a tuple type MyTuple = (String, String, String, Seq[(String, Double)])val t1: MyTuple = (\"a\", \"b\", \"c\", Seq((\"d\", 1.01), (\"e\", 2.02)))val t2: MyTuple = (\"a\", \"b\", \"c\", Seq((\"d\", 1.00), (\"e\", 2.00)))// create a matcher by zipping matchers to the expected valuedef beMatching(expected: MyTuple) = expected.zip(startWith, ===, ===, matchSequence)// match the elements of a sequence with a zipped matcher using string equality for the first field and// approximate Double equality for the second fielddef matchSequence(expected: =>Seq[(String, Double)]) = expected.contain(_.zip(===, ==~)).inOrder/** type inference doesn't work if this matcher, specialised to Double, is not defined */def ==~(d: =>Double) = beCloseTo(d +/- 0.1)t1 must beMatching(t2) Create your ownThe easiest way to create a new matcher is to create it from a function returning a tuple with a boolean and one or more messages: // annotate the return type so that implicit conversions can transform your function into a Matcher object// here just return a boolean and a failure messagedef m1: Matcher[String] = { s: String =>  (s.startsWith(\"hello\"), s+\" doesn't start with hello\")}// with a success message and a failure messagedef m2: Matcher[String] = { s: String =>  (s.startsWith(\"hello\"), s+\" starts with hello\", s+\" doesn't start with hello\")}// with a function taking the actual value for the failure messagedef m3: Matcher[String] =  ((_: String).startsWith(\"hello\"), (_:String)+\" doesn't start with hello\")// with 2 functions for the success and failure messagesdef m4: Matcher[String] =  ((_: String).startsWith(\"hello\"), (s:String) => s+ \" starts with hello\", (s:String) => s+ \" doesn't start with hello\")If you want absolute power over matching, you can define your own matcher extending `Matcher`: class MyOwn extends Matcher[String] {  def apply[S <: String](s: Expectable[S]) = {    result(s.value.isEmpty,      s.description + \" is empty\",      s.description + \" is not empty\",      s)  }}In the code above you have to: * define the `apply` method (and its somewhat complex signature) * use the protected `result` method to return: a Boolean condition, a message when the match is ok, a message when the   match is not ok, the \"expectable\" value. Note that if you change the expectable value you need to use the `map` method   on the `s` expectable (`s.map(other)`). This way you preserve the ability of the Expectable to throw an Exception if   a subsequent match fails * you can use the `description` method on the `Expectable` class to return the full description of the expectable including   the optional description you setup using the `aka` method Now learn how to... {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use  (`failure`, `success`, `skipped`, `todo`...) instead of matchers - add  to your expectations to create even better failure messages - use  to conveniently group several examples into one - use  to generate and verify data for your examples - use  to mock the interactions with another system - use  to display actual and expected values in html tables</div> And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - read the  on all of specs2 matchers - use  on the `value must matcher` form - implement the  to go beyond matchers - use the  matcher to automatically create matchers for case classes - use the  to specify dependencies between packages - use specs2 matchers </div>", "tags":"", "loc":"org.specs2.guide.Matchers.html"},
{"title":"Structure", "text":" StylesIn a Specification you generally want to include 2 things: - some informal text describing what the system/application/function should do - some Scala code specifying exactly inputs and expected outputsWith specs2 you have 2 main ways to do this: - you can create an *\"Acceptance\"* specification where all the informal text is written in one place and the code is written somewhere else. The name \"acceptance\" comes from the fact that it might be easier for a non-developer to just read some text to validate your specification - you can create a *\"Unit\"* specification where the code is interleaved with the text. The name \"unit\" comes from the fact that Unit specifications have a structure which is close to unit tests in \"classical\" frameworks such as JUnitBoth ways of writing specifications have advantages and drawbacks: - Acceptance specifications are easier to read as a narrative but require navigation between the text and the code. You also need to define an `is` method holding the body of the specification - Unit specifications are easier to navigate but the text tends to be lost in a sea of code Acceptance specificationAn acceptance specification extends `org.specs2.Specification` and defines the `is` method. You can implement this method with an interpolated **`s2`** string: class MySpecification extends org.specs2.Specification { def is = s2\"\"\" this is my specification   where example 1 must be true           $e1   where example 2 must be true           $e2                                          \"\"\"  def e1 = 1 must_== 1  def e2 = 2 must_== 2}The `s2` string contains the text of your specification as well as some references to methods (`e1` and `e2`) defining *`Results`*. When the Specification is executed, the `s2` string is analysed and 2 `Examples` are created then executed: - one `Example` with the description \"where example 1 must be true\" and the code `1 must_== 1` - another `Example` with the description \"where example 2 must be true\" and the code `2 must_== 2`All the rest, `\"this is my specification\"`, is parsed as `Text` and is not executed. Unit specificationA unit specification extends `org.specs2.mutable.Specification` and uses the `>>` operator to create \"blocks\" containing `Texts` and `Examples`: class MySpecification extends org.specs2.mutable.Specification {  \"this is my specification\" >> {    \"where example 1 must be true\" >> {      1 must_== 1    }    \"where example 2 must be true\" >> {      2 must_== 2    }  }}This specification creates one piece of `Text` and 2 `Examples` as before but: - there is no need to define an `is` method (this means that a mutable variable is used to collect the `Texts` and `Examples` hence the `mutable` package name) - the code is close to each piece of text it specifiesHowever once a specification is created with all its `Texts` and `Examples`, the execution will be the same, whether it is an Acceptance one or a Unit one.The `>>` blocks can be nested and this allows you to structure your specification so that the outermost blocks describe a general context while the innermost ones describe more specific contexts. A similar effect can be achieved by simply indenting text in an acceptance specification. ExpectationsThere is another major difference between the acceptance specifications and unit specifications. The first style encourages you to write [one expectation per example](http://bit.ly/one_assertion_per_test) while the second allows to use several. One expectation per example is useful because when a specification fails, you know immediately what is wrong. However it is sometimes expensive to setup data for an example. In that case, having several expectations sharing the same setup might be preferable.The good news is that for each of the 2 main styles, acceptance and unit, you can choose exactly which \"Expectation mode\" you prefer if the default mode is not convenient. Functional expectationsIn an acceptance specification, by default, the `Result` of an `Example` is always given by the last statement of its body. For instance, this example will never fail because the first expectation is \"lost\":// this will never fail!s2\"\"\"  my example on strings $e1\"\"\"  def e1 = {    // because this expectation will not be returned,...    \"hello\" must have size (10000)    \"hello\" must startWith(\"hell\")  }If you want to get both expectations you will need to use `and` between them: s2\"\"\"  my example on strings $e1\"\"\"  def e1 = (\"hello\" must have size (10000)) and           (\"hello\" must startWith(\"hell\"))This is a bit tedious and not very pleasing to read so you can see why this mode encourages one expectation per example only! If you want to declare several expectations per example, you can mix-in the `org.specs2.execute.ThrownExpectations` trait to the specification. Thrown expectationsWith a unit specification you get \"thrown expectations\" by default. When an expectation fails, it throws an exception and the rest of the example is not executed: class MySpecification extends org.specs2.mutable.Specification {  \"This is my example\" >> {    1 must_== 2 // this fails    1 must_== 1 // this is not executed  }}It is also possible to use the \"functional\" expectation mode with a unit specification by mixing in the `org.specs2.execute.NoThrownExpectations` trait. Now learn how to... {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use  to specify the body of your examples - set up  for the examples - control the  of a specification -  a specification</div> And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     -  examples - use a  for mutable specifications - collect  - mark examples as  - add  - create example descriptions spanning  - add  in unit specifications - create a trait which will  when mixed-in - create  where the code *is* the description of the `Example` - integrate  to your specification - use  in acceptance specifications to get default example names - use  to completely separate the specification text from the code - use  to reduce the number of implicits in scope - use the  to structure specifications - use  to create executable HTML tables in your specification - use the  to define the body of an example - add  - print  - extend the specification by creating examples </div>", "tags":"", "loc":"org.specs2.guide.Structure.html"},
{"title":"Quick Start", "text":"Follow the  instructions and create the following specification in a file named `HelloWorldSpec.scala`: class HelloWorldSpec extends Specification { def is = s2\"\"\" This is a specification to check the 'Hello world' string The 'Hello world' string should   contain 11 characters                                         $e1   start with 'Hello'                                            $e2   end with 'world'                                              $e3                                                                 \"\"\"  def e1 = \"Hello world\" must have size(11)  def e2 = \"Hello world\" must startWith(\"Hello\")  def e3 = \"Hello world\" must endWith(\"world\")}A specs2 software specification is nothing more than a Scala class extending `org.specs2.Specification` and declaring a special `is` method. This method contains both plain text describing what the application should do but also some method calls containing a more formal specification of the expected behaviour. ExecutionAnd this is it! Now you can execute your specification with a [*runner*](org.specs2.guide.Runners.html#Presentation) and observe the results:> scala -cp ... specs2.run HelloWorldSpecHelloWorldSpecThis is a specification to check the 'Hello world' stringThe 'Hello world' string should  + contain 11 characters  + start with 'Hello'  + end with 'world'Total for specification HelloWorldSpecFinished in 0 second, 58 ms3 examples, 0 failure, 0 error Learn more! {.ribbon .both-ribbon}<div class=\"ribbon-content\">    The rest of this  will show you how to: *  your specification using one of the 2 major \"styles\" of specifications: \"Acceptance\" and \"Unit\" * use the many specs2  to specify precisely the expected behavior of your application *  your specification and output results in various formats * check out the  page to find an answer to a specific question</div>", "tags":"", "loc":"org.specs2.guide.QuickStart.html"},
{"title":"Arguments reference", "text":"Arguments can be passed on the command line, or declared inside a specification, using the `args(name=value)` syntax:class MySpec extends Specification { def is = args(xonly=true)  s2\"\"\"  Clever spec title  And some intro text  brilliant expectation $success                                   \"\"\"}They can also be passed as system properties: `-Dspecs2.name=value` (`-Dname=value` also works but you might have collisions with other properties).Note that boolean properties like `color` can be defined in several ways: - not defined => the default value, `true`, is used - `color`     => use colors - `color true` => use colors - `color false` => don't use colors (`nocolor` is an alias) - `-Dspecs2.color`     => use colors - `-Dspecs2.color=true` => use colors - `-Dspecs2.color=false` => don't use colors (`-Dspecs2.nocolor` is an alias)This reference guide for arguments is divided in several sections: - \"path\" arguments defining where specs2 should read or write files - \"selection\" arguments to select the examples to run - \"execution\" arguments for execution parameters - \"storing\" arguments to store statistics - \"reporting\" arguments to control the output - API for arguments when used in the code Paths Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------------------------------------------------------------------- `stats.outdir`          | `target/specs2-reports/stats`  | output directory for run statistics (see ) `junit.outdir`          | `target/test-reports/`         | output directory for JUnit XML files (see ) `filesrunner.basepath`  | `src/test/scala`               | source directory for test files (see ) `filesrunner.path`      | `**/*.scala`                   | glob pattern for the file paths (see ) `filesrunner.pattern`   | `.*Spec`                       | regular expression for the specification class/object name (see ) `html.outdir`           | `target/specs2-reports`        | output directory for html files (see ) Selection Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------------------------------------------------------------------- `ex`                    | `.*`                           | regular expression specifying the examples to execute. Use `ex .*brilliant.*` on the command line `include`               | `\"\"`                           | execute only the fragments tagged with any of the comma-separated list of tags: `t1,t2,...` `exclude`               | `\"\"`                           | do not execute the fragments tagged with any of the comma-separated list of tags: `t1,t2,...` `was`                   | `\"\"`                           | select only some previously executed examples based on their status `selector`              | `\"\"`                           | implementation of the `org.specs2.specification.process.Selector` trait Execution Name                    | Default value                            | Description ----------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------- `plan`                  | `false`                                  | only report the text of the specification without executing anything `skipAll`               | `false`                                  | skip all the examples `stopOnFail`            | `false`                                  | skip all examples after the first failure or error `stopOnSkip`            | `false`                                  | skip all examples after the first skipped result `sequential`            | `false`                                  | don't execute examples concurrently `asap`                  | `false`                                  | execute all the examples before reporting them `isolated`              | `false`                                  | execute each example in its own specification to get \"fresh\" local variables `threadsNb`             | `Runtime.getRuntime.availableProcessors` | number of threads to use for concurrent execution `scheduledThreadsNb`    | `1`                                      | number of threads to use for timed out execution on Scalaz Futures `timeFactor`            | `1`                                      | multiply all durations by this factor when waiting for futures `executor`              | `\"\"`                                     | implementation of the `org.specs2.specification.process.Executor` trait Storing Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------ `neverstore`            | `false`                        | never store statistics if true `resetstore`            | `false`                        | delete previous store statistics if true ReportingSee the  page for a more precise description of these options. Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------ `all`                   | `false`                        | execute and report linked specifications `xonly`                 | `false`                        | only report failures and errors `showonly`              | `\"\"`                           | only report some examples based on their status `failtrace`             | `false`                        | show a stack trace for failures `fullstacktrace`        | `false`                        | show a full stack trace `tracefilter`           | `\"\"`                           | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`            | `\"\"`                           | define the parameters for the `SmartDiffs` instance for differences `diffsclass`            | `\"\"`                           | use a specific instance of the `Diffs` trait `color`                 | `true`                         | use colors `colors`                | `\"\"`                           | use different colors `colorsclass`           | `\"\"`                           | use a specific instance of the `Colors` trait `showtimes`             | `false`                        | show execution times for examples `notifier`              | `\"\"`                           | name of a class extending the `org.specs2.reporter.Notifier` trait `printer`               | `\"\"`                           | name of a class extending the `org.specs2.reporter.Printer` trait `reporter`              | `\"\"`                           | name of a class extending the `org.specs2.reporter.Reporter` traitFor  the following options can be used: Name                    | Default value                                 | Description ----------------------- | --------------------------------------------- | ------------------------------ `all`                   | `false`                                       | execute and report linked specifications `html.outdir`           | `target/specs2-reports/`                      | output directory for the html files `html.template`         | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`        | `Map[String, String]()`                       | passed to the template during the Pandoc evaluation `html.nostats`          | `false`                                       | if true no stats are displayed `html.search`           | `true`                                        | add a search box to the generated files `html.toc`              | `true`                                        | add a table of contents to the generated files `html.toc.entrymaxsize` | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs` | `true`                                        | report \"see\" references which do not correspond to any generated file Arguments APIFrom inside a specification, the `args` method provides the most frequent arguments as `args(argumentName = argumentValue)`. In the least frequent cases you will have to write:// for selection argumentsargs.select(ex = \"example \\d*\")// for reporting argumentsargs.execute(threadsNb = 4)// for storing argumentsargs.store(reset = true)// for reporting argumentsargs.report(xonly = true)There are also a few shortcuts: Name                                                                  | Equivalent --------------------------------------------------------------------- | ----------------------- `include(tags: String)`                                               | `args(include=tags)` `exclude(tags: String)`                                               | `args(exclude=tags)` `only(examples: String)`                                              | `args(ex=examples)` `was(status: String)`                                                 | `args(was=status)` `plan`                                                                | `args(plan=true)` `skipAll`                                                             | `args(skipAll=true)` `stopOnFail`                                                          | `args(stopOnFail=true)` `stopOnSkip`                                                          | `args(stopOnSkip=true)` `sequential`                                                          | `args(sequential=true)` `isolated`                                                            | `args(isolated=true)` `xonly`                                                               | `args(xonly=true)` `showOnly(status: String)`                                            | `args(showOnly=status)` `fullStackTrace`                                                      | `args.report(traceFilter=NoStackTraceFilter)` `diffs(show, separators, triggerSize, shortenSize, diffRatio, full)`  | `args.report(diffs=SmartDiffs(show, separators, triggerSize, shortenSize, diffRatio, full))`", "tags":"", "loc":"org.specs2.guide.ArgumentsReference.html"},
{"title":"Reference card", "text":" EqualityThe most common type of matcher is `beEqualTo` to test the equality of 2 values. Several syntaxes can be used, according to your own taste Matcher                    |  Comment -------------------------- | -------------------------- `1 must beEqualTo(1)      `| the normal way `1 must be_==(1)          `| with a symbol `1 must_== 1              `| my favorite! `1 mustEqual 1            `| if you dislike underscores `1 should_== 1            `| for `should` lovers `1 === 1                  `| the ultimate shortcut `1 must be equalTo(1)     `| with a literate styleThere are also other notions of equality Matcher                    |  Comment -------------------------- | -------------------------- `beTypedEqualTo           `| typed equality. `a must beTypedEqualTo(b)` will not work if `a` and `b` don't have compatible types `be_===                   `| synonym for `beTypedEqualTo` `a ==== b                 `| synonym for `a must beTypedEqualTo(b)` `a must_=== b             `| similar to `a must_== b` but will not typecheck if `a` and `b` don't have the same type `be_==~                   `| check if `(a: A) == conv(b: B)` when there is an implicit conversion `conv` from `B` to `A` `beTheSameAs              `| reference equality: check if `a eq b` (`a must be(b)` also works) `be                       `| `a must be(b)`: synonym for `beTheSameAs` `beTrue, beFalse          `| shortcuts for Boolean equality_Note_: the `beEqualTo` matcher is using the regular `==` Scala equality. However in the case of `Arrays`, Scala `==` is just using reference equality, `eq`. So the `beEqualTo` matcher has been adapted to use the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested), before checking for equality, so that `Array(1, 2, 3) === Array(1, 2, 3)` (despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`). Out of the boxThese are the all the available matchers when you extend `Specification` OptionalThose matchers are optional. To use them, you need to add a new trait to your specification:", "tags":"", "loc":"org.specs2.guide.matchers.ReferenceCard.html"},
{"title":"Outside specs2", "text":"The specs2 matchers are a well-delimited piece of functionality that you should be able to reuse in your own test framework. You can reuse the following traits: * `org.specs2.matcher.MustMatchers` (or `org.specs2.matcher.ShouldMatchers`) to write anything like `1 must be_==(1)` and   get a `Result` back * **Important**: the `MustMatchers` *trait* will fill-in stacktraces on `MatchResults` to mark the location of a result while the `MustMatchers` object will not. This has some important consequences in terms of performances because creating stack traces is expensive * You can also use the side-effecting version of that trait called `org.specs2.matcher.MustThrownMatchers` (or `org.specs2.matcher.ShouldThrownMatchers`).   It throws a `FailureException` as soon as an expectation is failing * Finally, in a JUnit-like library you can use the `org.specs2.matcher.JUnitMustMatchers` trait which throws `AssertionFailureError`s Without any dependency on specs2It is possible to add testing features to your library without depending on a specific testing library, like specs2 or ScalaTest. You will let clients of your library decide which one they want with the following trait:trait TestInterface {  def fail(msg: String): Nothing  def skip(msg: String): Nothing}// and use the trait in your librarytrait TestKit extends TestInterface {  def runTest(call: =>Unit) = {    // run the code and if there is an error    fail(\"error!\")  }}When there is a failure or an error the library will call the `TestKit` methods. Then the library client can use both the library and specs2 by mixing in the `org.specs2.matcher.ThrownMessages` trait:trait ThrownMessages { this: ThrownExpectations =>  def fail(m: String): Nothing = failure(m)  def skip(m: String): Nothing = skipped(m)}class MySpec extends Specification with TestKit with ThrownMessages { def is = s2\"\"\"  An example using the TestKit $e1\"\"\"  def e1 = {    // do something with the library    runTest(...)  }}", "tags":"", "loc":"org.specs2.guide.matchers.OutsideSpecs2.html"},
{"title":"Dependency matchers", "text":"It is highly desirable to have acyclic dependencies between the packages of a project. This often leads to describing the packages structure as \"layered\": each package on a layer can only depend on a package on a lower layer. specs2 helps you enforce this design property with specific matchers. Layers definitionFirst you need to define the packages and their expected dependencies. Mix-in the `org.specs2.specification.Analysis` trait and define layers (taking specs2 as an example): layers (  \"runner\",  \"reporter\",  \"specification mutable\",  \"mock      form\",  \"matcher\",  \"execute\",  \"reflect    xml  time html\",  \"collection control io text main data\").withPrefix(\"org.specs2\")The above expression defines layers as an ordered list of `String`s containing space-separated package names. It is supplemented by a `withPrefix` declaration to factor out the common package prefix between all these packages.By default, the packages are supposed to correspond to directories in the `src/target/scala-<version>/classes` directory. If your project has a different layout you can declare another target directory: layers(\"...\").inTargetDir(\"out\" / \"classes\") Inclusion/ExclusionEvery rule has exceptions :-). In some rare cases, it might be desirable to exclude a class from being checked on a given layer. To do this, you can use the `include/exclude` methods on the `Layer` class: layers (  \"runner\",  \"reporter\",  \"specification mutable\".exclude(\"mutable.SpecificationWithJUnit\"),  \"mock      form\",  \"matcher\",  \"execute\",  \"reflect  xml  time html\",  \"collection control io text main data\").withPrefix(\"org.specs2\")The `include/exclude` methods accept a list of regular expressions to:- exclude fully qualified class names (generally, only `exclude` will be necessary)- re-include fully qualified class names if the exclusion list is to big VerificationNow you've defined layers, you can use the `beRespected` matcher to check if all the dependencies are verified: val design = layers(\"...\")design must beRespectedIf some dependencies are not respected:[error] those dependencies are not satisfied:[error] org.specs2.main x-> org.specs2.io because org.specs2.io.FileSystem -> org.specs2.main.Arguments[error] org.specs2.main x-> org.specs2.io because org.specs2.io.FileSystem -> org.specs2.main.ArgumentsArgs Layers as an ExampleThe `org.specs2.specification.Analysis` trait allows to directly embed the layers definition in a `Specification` and turn it into an `Example`: class DependenciesSpec extends Specification with specification.Analysis { def is =  \"this is the application design\"     layers(      \"gui commandline\",      \"controller\",      \"backend\"    )}", "tags":"", "loc":"org.specs2.guide.matchers.DependencyMatchers.html"},
{"title":"Case class matchers", "text":"There is a special support for matching case classes, using a matcher macro. To use it you need to add the `specs2-matcher-extra` jar to your project and add the `org.specs2.matcher.MatcherMacros` trait to your specification.Then, with the `matchA` matcher you can check the values of case class attributes:// case class for a Catcase class Cat(name: String = \"\", age: Int = 0, kitten: Seq[Cat] = Seq())// a given catval cat = Cat(name = \"Kitty\", age = 6, kitten = Seq(Cat(\"Oreo\", 1), Cat(\"Ella\", 2)))// this cat must be a Catcat must matchA[Cat]// check the value of \"name\"cat must matchA[Cat].name(\"Kitty\")// check the value of \"age\" using a matcherdef is[A](a: A) = be_==(a)cat must matchA[Cat].age(is(6))// check the value of \"kitten\" using a function returning a Resultcat must matchA[Cat].kitten((_:Seq[Cat]) must haveSize(2))// matchers can be chainedcat must matchA[Cat]  .name(\"Kitty\")  .age(is(6))  .kitten((_:Seq[Cat]) must haveSize(2)) And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - learn about all available </div>", "tags":"", "loc":"org.specs2.guide.matchers.CaseClassMatchers.html"},
{"title":"Syntactic variations", "text":"The \"standard\" way of using matchers is `value must matcher`. However there are several allowed variations:// use 'should' instead of 'must'1 should beEqualTo(1)// use 'beXXX' and 'haveXXX' as 'be XXX' and 'have XXX'1 must be equalTo(1)List(1) must have size(1)// use 'not' to negate a matcherList(1) must not have size (1)Finally there are some shortcuts for the equality matcher:1 must_== 11 mustEqual 11 === 1// with a negation1 must_!= 21 mustNotEqual 11 !=== 1 Postfix operationsThe notation `Seq() must be empty` is being parsed as `(Seq() must be) empty` where `empty` is a [\"Postfix operator\"](http://www.scala-lang.org/api/2.11.6/index.html#scala.language$). By default Scala disallows postfix operators but they are enabled in specs2 specifications thanks to the `org.spec2.control.LanguageFeatures` trait providing the `language.postfixOps` implicit definition.If that implicit definition conflicts with your own import of `language.postfixOps` you can use the `org.spec2.control.NoLanguageFeatures` trait to deactivate it.", "tags":"", "loc":"org.specs2.guide.matchers.SyntacticVariations.html"},
{"title":"Other build tools", "text":"The most straightforward way to run specs2 specifications is to use [sbt](http://scala-sbt.org). However other build tools such as Maven and Gradle can be used too (please refer to the  guide for instructions on how to set-up projects for those tools). MavenWith Maven you need to use the [Surefire](http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html) plugin and the `test` command. You will need however to annotate your specification classes as JUnit tests (this requires the `specs2-junit` jar):import org.specs2.runner.JUnitRunnerimport org.junit.runner.RunWith@RunWith(classOf[JUnitRunner])class MySpecification extends org.specs2.Specification { def is = s2\"\"\"  Define your specification as usual here\"\"\"} GradleWith Gradle you need to use the same `RunWith` annotation and the [`test`](http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.testing.Test.html) task. You can also follow the instructions in [this blog post](http://blog.mindcrime-ilab.de/2013/10/25/gradle-rocking-scala-specs2-tests) and create a task that will leverage the specs2 . This way you will avoid having to annotate the classes.", "tags":"", "loc":"org.specs2.guide.OtherBuildTools.html"},
{"title":"AsResult typeclass", "text":"There are many ways to define expectations in specs2:Boolean (`true, false`)Standard result (`success, failure`)Matcher result (`1 must_== 1`)Scalacheck propertyDataTableFormsAll of these types implement the `org.specs2.execute.AsResult` typeclass, meaning that they can be transformed into a `Result`:trait AsResult[T] {  def asResult(t: =>T): Result}This gives some flexibility in integrating any kind of custom definition of a \"result\" into specs2 and this is why you find this typeclass as a requirement to build examples or to declare contexts.You can take advantage of this type class by defining your own kind of result and providing a typeclass instance for it:// A new type of results for cluster executiontrait ClusterExecution {  def succeeded: Boolean  def errorMessage: String}object ClusterExecution {  implicit def clusterExecutionAsResult: AsResult[ClusterExecution] =    new AsResult[ClusterExecution] {      def asResult(t: =>ClusterExecution): Result = {        try {          val result = t          if (result.succeeded) Success()          else                  Failure(t.errorMessage)        } catch { case e: Throwable => Error(e) }      }   }} Decorated resultsYou can also embed custom data in a special kind of `Result`, a `DecoratedResult`:case class DecoratedResult[+T](decorator: T, result: Result) extends Result(result.message, result.expected)A `DecoratedResult[T]` decorates an ordinary result with an additional value of type `T`. If you want to take advantage of this custom value in your reports you will need to build a custom `org.specs2.reporter.Printer`, probably extending an existing one. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - mark any object having an `AsResult` instance as </div>", "tags":"", "loc":"org.specs2.guide.AsResultTypeclass.html"},
{"title":"Execution environment", "text":"When you run a specification, a `java.util.concurrent.ExecutorService` is used to execute examples concurrently. You can access this `ExecutorService` to execute `scalaz.concurrent.Futures` and it can also be wrapped into a `scala.concurrent.ExecutionContext` to create `scala.concurrent.Futures`. Scala FutureA Scala `Future` needs an implicit `ExecutionContext` to be created. You can reuse specs2 own execution context if you want (instead of Scala's global one: `scala.concurrent.ExecutionContext.Implicits.global`): class MyFutureSpec extends Specification { def is = s2\"\"\" Let's check this scala future ${ implicit ec: ExecutionContext =>    Await.result(Future(1), Duration.Inf) must_== 1 }\"\"\"}// in a mutable specificationclass MyMutableFutureSpec extends mutable.Specification {  \"Let's check this scala future\" >> { implicit ec: ExecutionContext =>    Await.result(Future(1), Duration.Inf) must_== 1  }}You can also use specs2's execution environment directly (from now on code examples are provided for immutable specifications only but are transposable to mutable ones): class MyFutureSpec extends Specification { def is = s2\"\"\" Let's check this scala future ${ implicit ee: ExecutionEnv =>   Await.result(Future(1), Duration.Inf) must_== 1 }\"\"\"}This works thanks to an implicit conversion between `ExecutionEnv` and `ExecutionContext` provided by the `org.specs2.execute.ImplicitExecutionContextFromExecutionEnv` trait (this can be deactivated by mixing-in the `NoImplicitExecutionContextFromExecutionEnv` trait). It is actually better to use an `ExecutionEnv` anyway because it is required when you want to  (see the \"Future\" tab). Scalaz FutureA Scalaz `Future` needs an implicit `ExecutorService` to evaluate values asynchronously. You can require an `ExecutorService` in your examples like this: class MyFutureSpec extends Specification { def is = s2\"\"\" Let's check this scalaz future ${ implicit es: ExecutorService =>   scalaz.concurrent.Future(1).run must_== 1 }\"\"\"}And, similarly to the section above, you can get an implicit `ExecutorService` from an `ExecutionEnv`:class MyFutureSpec extends Specification { def is = s2\"\"\"  Let's check this scalaz future ${ implicit ee: ExecutionEnv =>    scalaz.concurrent.Future(1).run must_== 1  }\"\"\"}You will also need a `ScheduledExecutorService` if you want to evaluate a Scalaz Future using the `timed` method (from Scalaz > 7.1): class MyFutureSpec extends Specification { def is = s2\"\"\"  Let's check this scalaz future ${ implicit ee: ExecutionEnv =>    implicit val ses = ee.scheduledExecutorService    scalaz.concurrent.Future(1).timed(3.seconds).run.toOption must beSome(1)  }\"\"\"} With matchersFuture  (see the \"Future\" tab) require an implicit `ExecutionEnv`. This environment is used to access: - the `timeFactor` when awaiting for Scala Futures - a `scheduledExecutorService` and the `timeFactor when attempting Scalaz FuturesThe `terminate` matcher (see the \"Termination\" tab in the optional  section) also needs an `ExecutionEnv` to run a piece of code and periodically check if it has terminated or not: s2\"\"\"  this code must be fast enough ${ implicit ee: ExecutionEnv =>    Thread.sleep(100) must terminate(retries = 1, sleep = 60.millis)  }\"\"\" Implicit ExecutionEnvPassing an implicit `ExecutionEnv` for each example can be tedious. An `ExecutionEnv` can be injected to the specification to make it available to all examples at once: case class MyFutureSpec(implicit ee: ExecutionEnv) extends Specification { def is = s2\"\"\" Let's check this scala future ${    Future(1) must be_==(1).await  }\"\"\"  }Another possibility is to mix-in the `org.specs2.specification.ExecutionEnvironment` trait to your specification: class MyFutureSpec extends Specification with ExecutionEnvironment { def is(implicit ee: ExecutionEnv) = s2\"\"\" Let's check this scala future ${   Future(1) must be_==(1).await }\"\"\"}// in a mutable specificationclass MyMutableFutureSpec extends mutable.Specification with specification.mutable.ExecutionEnvironment { def is(implicit ee: ExecutionEnv) = {  \"Let's check this scala future\" >> {    Future(1) must be_==(1).await  }}} And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use specs2  in a Specification</div>", "tags":"", "loc":"org.specs2.guide.ExecutionEnvironments.html"},
{"title":"Environment", "text":"The execution of a Specification depends on various parts, among which: - the command line arguments - an `ExecutorService` for concurrent execution - a \"StatisticsRepository\" to access previous results - a \"Logger\" to log results to the console - an interface for the file system<p/>All of this is bundled into one object `org.specs2.specification.core.Env`. The `Env` is accessible to your Specification by either: - having it injected as a Specification member - extending a trait Dependency injectionThe following objects can be injected in your specification if you declare a 1-parameter constructor:  - the `Env` itself  - the `Arguments` object  - the `CommandLine` object  - the `ExecutionEnv` object (can be implicit)  - the `ExecutionContext` object (can be implicit)  - the `ExecutorService` object (can be implicit)<p/>For example: class MySpec(env: Env) extends Specification { def is =s2\"\"\"  Use the environment fileSystem  ${ env.fileSystem.mkdirs(\"tmp\" / \"test\").runOption; ok }\"\"\"}Or if you want to access an `ExecutionContext`:class MySpec(implicit ec: ExecutionContext) extends Specification { def is =s2\"\"\"  Use a future  ${ Await.result(Future(1), 1.seconds) must_== 1 }\"\"\"  } Environment traitsThe `Env` object can also be accessed by mixing-in the `org.specs2.specification.Environment` trait class MySpec extends Specification with Environment { def is(env: Env) =s2\"\"\"  Use the environment fileSystem  ${ env.fileSystem.mkdirs(\"tmp\" / \"test\").runOption; ok }\"\"\"}As you can see, instead of defining the `is` method you now need to defined the `is(env: Env)` method. Then you can access any attribute of the current `Env`.There are also other specialised traits giving access to specific parts of the environment Command-line argumentsWhen you just want to access the command-line arguments you can use the `org.specs2.specification.CommandLineArguments` traitclass MySpec extends Specification with CommandLineArguments { def is(args: CommandLine) = s2\"\"\"  Use the command line arguments  ${ if (args.isSet(\"pass\")) ok else ko }\"\"\"} Execution environmentWhen you just want to access the execution environment can use the `org.specs2.specification.ExecutionEnvironment` traitclass MySpec extends Specification with ExecutionEnvironment { def is(implicit ee: ExecutionEnv) = s2\"\"\"  Use the implicit execution environment  ${ Future(1) must be_==(1).await }\"\"\"  }As you can see the `ExecutionEnv` parameter is defined as an implicit parameter because this is what is required when creating futures or using .", "tags":"", "loc":"org.specs2.guide.Environment.html"},
{"title":"Datatables", "text":"DataTables are used to pack several expectations inside one example using a tabular format: class DataTableSpec extends Specification with org.specs2.specification.Tables { def is = s2\"\"\" adding integers should just work in scala ${// the header of the table, with `|` separated strings (`>` executes the table)\"a\" | \"b\" | \"c\" |>2   !  2  !  4  |                   // an example row1   !  1  !  2  |                   // another example row  { (a, b, c) => a + b must_== c }  // the expectation to check on each row}\"\"\"}A `DataTable` which is used as a `Result` in the body of an Example will only be displayed when failing. If you also want to display the table when successful, to document your examples, you can omit the example description and inline the DataTable directly in the specification:class DataTableSpec extends Specification with Tables { def is = s2\"\"\" adding integers should just work in scala  ${     \"a\"   | \"b\" | \"c\" |>      2    !  2  !  4  |      1    !  1  !  2  |      { (a, b, c) => a + b must_== c }   }\"\"\"  }This specification will be rendered as:adding integers should just work in scala+  a | b | c |   2 | 2 | 4 |   1 | 1 | 2 | Implicit `!`The datatable DSL uses the `!` operator to define columns. However this operator is also used by the examples DSL to create the body of an example: `\"my example is\" ! ok`, so if the first column of the datatable contains strings you will not be able to use both at the same time to mean different things (\"create a table header\" and \"create an example\").You can solve this conflict by either: - using the `org.specs2.specification.Tables` and `org.specs2.mutable.Tables` traits which will deactivate the example DSL on acceptance and mutable specifications - using the `org.specs2.matcher.DataTables` trait and use `!!` instead of `!` if the first column is a string (for good visual balance you can use `||` in the header) Concurrent executionBy default the execution of a datatable is sequential, one row after another. This might not be very practical if you have long-running computations on each row.If this is the case you can use the `|*` operator (instead of just `|`) to define your execution function:\"a\"   | \"b\" | \"c\" |>   2    !  2  !  4  |   1    !  1  !  2  |* { (a, b, c) => a + b must_== c }This returns a function `ExecutorService => Result` which can be used directly as the body of an example. You can also pass it your own thread pool by creating, for example, `java.util.concurrent.Executors.newFixedThreadPool(4)`.More generally, you can use the \"Applicative\" operator `|@` to pass anything having a `scalaz.Applicative` instance, like a `scala.concurrent.Future`:// this table uses the global execution context implicitly to create futures  // scala.concurrent.ExecutionContext.Implicits.global  def result: scala.concurrent.Future[DecoratedResult[DataTable]] =    \"a\" | \"b\" | \"c\" |>     2  !  2  ! 4   |     1  !  1  ! 2   |@ { (a, b, c) => Future(a + b must_== c) }  // then you need to get an implicit execution environment and  // await on the Future result  implicit def ee: ExecutionEnv = ???  result.await", "tags":"", "loc":"org.specs2.guide.UseDatatables.html"},
{"title":"Fragments API", "text":"In specs2 a specification can simply be viewed as a sequence of \"Fragments\". A `Fragment` is something which has: - a `Description` - an `Execution`All the elements encountered in this User Guide fall under this representation: - an `Example` is a `Fragment` with a `Text` description and an `Execution` returning a `Result` - a `Step` is a `Fragment` with no description and a special `Execution` declaring that everything before the step must be executed before the `Step` is executed - a `Text` is a `Fragment` with a `Text` description and no `Execution`The role of the various DSLs in acceptance and unit specifications is to create those fragments and assemble them into a bigger `Fragments` object. They do this using: - the `FragmentFactory` API to create individual fragments - the `Fragments` API to assemble them The `FragmentFactory` APIThe `org.specs2.specification.create.FragmentFactory` trait possesses different methods to create: - texts - examples - steps / actions - tags - references - \"formatting\" fragments (break, paragraph, tab...)Please have a look at the ScalaDoc to see the exact API for the factory and look at the source code for the default implementation in `org.specs2.specification.create.DefaultFragmentFactory`. The `Fragments` APIIf you know how to create examples, texts and steps you will need to append them together as `Fragments`. You can create a `Fragments` object by using `Fragments.apply`:val ff = fragmentFactoryFragments(ff.text(\"introduction\"), ff.example(\"first example\", success), ff.break)Then you can use the methods of the `org.specs2.specification.core.Fragments` class to add more fragments or to modify existing ones: Method                                          | Description ----------------------------------------------- | ----------- `append(f: Fragment)`                           | to append a single fragment `append(fs: Fragments)`                         | to append another `Fragments` object `prepend(...)`                                  | to do the same as above but prepending instead of appending `append(fs: Seq[Fragment])`                     | to append a sequence `filter(f: Fragment => Boolean)`                | to filter out some fragments `map(f: Fragment => Fragment)`                  | to modify each fragment `mapDescription(f: Description => Description)` | to just modify the descriptions The `Fragments` DSLThe `org.specs2.specification.dsl.FragmentsDsl` trait provides a very versatile `` operator to append fragments together, so you can write:val ff = fragmentFactoryval fs = Fragments(ff.text(\"introduction\"), ff.example(\"first example\", success), ff.break)val f1 = ff.text(\"f1\")// all those combinations are possible and return a `Fragment` objectfs  f1f1  fsfs  fsf1  f1", "tags":"", "loc":"org.specs2.guide.FragmentsApi.html"},
{"title":"Datatables", "text":"DataTables are used to pack several expectations inside one example using a tabular format: class DataTableSpec extends Specification with org.specs2.specification.Tables { def is = s2\"\"\" adding integers should just work in scala ${// the header of the table, with `|` separated strings (`>` executes the table)\"a\" | \"b\" | \"c\" |>2   !  2  !  4  |                   // an example row1   !  1  !  2  |                   // another example row  { (a, b, c) => a + b must_== c }  // the expectation to check on each row}\"\"\"}A `DataTable` which is used as a `Result` in the body of an Example will only be displayed when failing. If you also want to display the table when successful, to document your examples, you can omit the example description and inline the DataTable directly in the specification:class DataTableSpec extends Specification with Tables { def is = s2\"\"\" adding integers should just work in scala  ${     \"a\"   | \"b\" | \"c\" |>      2    !  2  !  4  |      1    !  1  !  2  |      { (a, b, c) => a + b must_== c }   }\"\"\"  }This specification will be rendered as:adding integers should just work in scala+  a | b | c |   2 | 2 | 4 |   1 | 1 | 2 | Implicit `!`The datatable DSL uses the `!` operator to define columns. However this operator is also used by the examples DSL to create the body of an example: `\"my example is\" ! ok`, so if the first column of the datatable contains strings you will not be able to use both at the same time to mean different things (\"create a table header\" and \"create an example\").You can solve this conflict by either: - using the `org.specs2.specification.Tables` and `org.specs2.mutable.Tables` traits which will deactivate the example DSL on acceptance and mutable specifications - using the `org.specs2.matcher.DataTables` trait and use `!!` instead of `!` if the first column is a string (for good visual balance you can use `||` in the header) Concurrent executionBy default the execution of a datatable is sequential, one row after another. This might not be very practical if you have long-running computations on each row.If this is the case you can use the `|*` operator (instead of just `|`) to define your execution function:\"a\"   | \"b\" | \"c\" |>   2    !  2  !  4  |   1    !  1  !  2  |* { (a, b, c) => a + b must_== c }This returns a function `ExecutorService => Result` which can be used directly as the body of an example. You can also pass it your own thread pool by creating, for example, `java.util.concurrent.Executors.newFixedThreadPool(4)`.More generally, you can use the \"Applicative\" operator `|@` to pass anything having a `scalaz.Applicative` instance, like a `scala.concurrent.Future`:// this table uses the global execution context implicitly to create futures  // scala.concurrent.ExecutionContext.Implicits.global  def result: scala.concurrent.Future[DecoratedResult[DataTable]] =    \"a\" | \"b\" | \"c\" |>     2  !  2  ! 4   |     1  !  1  ! 2   |@ { (a, b, c) => Future(a + b must_== c) }  // then you need to get an implicit execution environment and  // await on the Future result  implicit def ee: ExecutionEnv = ???  result.await", "tags":"", "loc":"org.specs2.guide.UseDatatables.html"},
{"title":"Create online specifications", "text":" Most of the specifications we write are known up front because this is precisely what guides the construction of our systems. But sometimes data comes first and drives what we can do with the system. For example we want to check that:  1. all the Wikipedia pages mentioning the term \"BDD\" are referencing specs2  2. if there is a specs2 link on the page, the linked page must existMore precisely we want to create one example for `1.` and if it succeeds, create as many examples as there are links in `2.`. This can be done with the `org.specs2.specification.dsl.Online` trait and the `continueWith` method: class WikipediaBddSpec extends Specification with Online { def is = s2\"\"\"  All the pages mentioning the term BDD must contain a reference to specs2 $e1\"\"\"  def e1 = {    val pages = Wikipedia.getPages(\"BDD\")    { pages must contain((_:Page) must mention(\"specs2\")) } continueWith      pagesSpec(pages)  }  def pagesSpec(pages: Seq[Page]): Fragments = {    val specs2Links = pages.flatMap(_.getLinks).filter(_.contains(\"specs2\"))    s2\"\"\"     The specs2 links must all be active     ${ Fragments.foreach(specs2Links)(isActive) }    \"\"\"  }  def isActive(link: HtmlLink) =    s2\"\"\"  The page at ${link.getName}    must be active ${ link must beActive }\"\"\"  // implement this matcher  def mention(name: String): Matcher[Page] = ???  def beActive: Matcher[HtmlLink] = ???In the specification above, if we succeed in checking each BDD page then we continue with the creation of individual examples for each encountered link.", "tags":"", "loc":"org.specs2.guide.CreateOnlineSpecifications.html"},
{"title":"Forms", "text":"Forms are a way to represent domain objects or services, and declare expected values in a tabular format. Forms can be designed as reusable pieces of specification where complex forms can be built out of simple ones.Forms are built by creating `Fields` or `Props` and placing them on rows. The following examples show, by order of complexity, the creation of:  1. fields  1. effects  1. properties  1. a simple Form using properties  1. a simple Address entity encapsulating the above form  1. a composite Customer entity using the Address instance  1. a decision table having some related columns  1. a composite Order - OrderLine entity (1-n) relationship For all the code samples below you need to extend the `org.specs2.specification.Forms` trait. FieldsA `Field` is simply a label and a value. It is used in forms to display regular information. You can create a `Field` with these methods:`field(value)` creates a field for a value, where the label is empty`field(label, value)` creates a field with a label and a value`field(label, field1, field2, ...)` creates a field with a label and values coming from other fields, concatenated as stringsWhen the form is displayed, here is how the fields are displayed:  In terms of execution, the value is only evaluated when the `Field` is executed (when executing the parent Form for example). If an exception is thrown during that evaluation, the exception message will be displayed in place of the value. EffectsAn `Effect` is almost like a `Field` but it never shows its value. The value of an `Effect` is supposed to have some kind of side-effect, like clicking on a webpage, and only the effect label will be displayed (except when there is an exception, in that case the exception message is added). You can create an `Effect` with these methods: * `effect(value)` creates an effect with no label * `effect(label, value)` creates an effect with a label and a value that will be evaluated when the `Effect` is executed * `effect(effect1, effect2, ...)` creates an effect with all the effects labels and a side-effect sequencing all side-effects PropertiesA `Prop` is like a `Field`, it has a label. But you can give it 2 values, an \"actual\" one and an \"expected\" one. When executing the property, both values are compared to get a result. You can create a `Prop` with the following functions: Expression                                                               | Description ------------------------------------------------------------------------ | -------------------------- `prop(value)`                                                            | a property with no label `prop(label, actual)`                                                    | a property with a label and an actual value `prop(label, actual, expected)`                                          | a property with a label, an actual value and an expected one `prop(label, actual, constraint)`                                        | a property with a label, an actual value and a function taking the actual value, an expected one and returning a `Result` `prop(\"label\", \"actual\", (a: String, b: String) => (a === b).toResult)`  | a property with a label, an actual value and a function taking the expected value, returning a Matcher that will be applied to the actual one `prop(\"label\", \"expected\", (expected: String) => beEqualTo(expected))`   | a property with a label, an actual value and function applying a matcher to that value `prop(label, actual, matcher)`                                           | a property with a label, an actual value and a matcher to apply to that value    If the matcher is `mute`d then no message will be displayed in case of a failure.If the expected value is not provided when building the property, it can be given with the `apply` method:// apply \"sets\" the expected valueprop1.apply(\"expected\")// orprop1(\"expected\")Let's look at a few examples: <form>    <table><tr><th colspan=\"7\">Properties</th></tr><tr><td class=\"info\" style=\"text-align:center\"><b>code</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center\"><b>is displayed as</b></td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;expected&quot;)(&quot;expected&quot;)</code></td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;expected&quot;, &quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;expected&quot;)(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;)(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td class=\"failure\">expected</td><td colspan=\"5\" class=\"failure\" onclick=\"showHide(1700177895)\">'actual' is not equal to 'expected'</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, { error(&quot;but got an error&quot;); &quot;actual&quot; })(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td class=\"error\">expected</td><td colspan=\"5\" class=\"error\" onclick=\"showHide(1585423937)\">java.lang.RuntimeException: but got an error</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, (a: String, b: String) =&gt; (a === b).toResult)(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, (s: String) =&gt; beEqualTo(s))(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, beEqualTo(&quot;expected&quot;))</code></td><td style=\"background-color:#EEEEEE\">label</td><td class=\"failure\">actual</td><td colspan=\"5\" class=\"failure\" onclick=\"showHide(1606234234)\">'actual' is not equal to 'expected'</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, beEqualTo(&quot;expected&quot;).mute)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"failure\">actual</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"1700177895\">      'actual' is not equal to 'expected' (file:1)          </div><div class=\"formstacktrace details\" id=\"1585423937\">      java.lang.RuntimeException: but got an error (file:1)      <div>scala.sys.package$.error(package.scala:27)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34$$anonfun$29.apply(UseForms.scala:85)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34$$anonfun$29.apply(UseForms.scala:85)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property.execute(Property.scala:51)</div><div>org.specs2.control.Property.optionalValue(Property.scala:17)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.control.Exceptions$class.trye(Exceptions.scala:86)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:132)</div><div>org.specs2.execute.ResultExecution$class.executeEither(ResultExecution.scala:80)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:120)</div><div>org.specs2.execute.ResultExecution$class.executeProperty(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:120)</div><div>org.specs2.form.Prop.actualValue$lzycompute(Prop.scala:48)</div><div>org.specs2.form.Prop.actualValue(Prop.scala:48)</div><div>org.specs2.form.Prop.execute(Prop.scala:55)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>scala.Option.orElse(Option.scala:289)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:176)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:172)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>scala.collection.immutable.List.map(List.scala:273)</div><div>scalaz.NonEmptyList.map(NonEmptyList.scala:20)</div><div>org.specs2.form.Row.executeRow(Row.scala:38)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.map(TraversableLike.scala:245)</div><div>scala.collection.AbstractTraversable.map(Traversable.scala:104)</div><div>org.specs2.form.Form.executeRows(Form.scala:73)</div><div>org.specs2.form.Form.executeForm(Form.scala:81)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34.apply(UseForms.scala:89)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34.apply(UseForms.scala:89)</div><div>org.specs2.specification.create.S2StringContext$$anon$5.append(S2StringContext.scala:96)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:215)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:213)</div><div>scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)</div><div>scala.collection.immutable.List.foldLeft(List.scala:84)</div><div>org.specs2.specification.create.S2StringContextCreation$class.s2(S2StringContext.scala:213)</div><div>org.specs2.Specification.s2(Specification.scala:19)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$.org$specs2$specification$core$SpecStructure$$getRefs$1(SpecStructure.scala:119)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:252)</div><div>scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.getAll$1(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:134)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:124)</div><div>org.specs2.control.ActionT$$anonfun$safe$1.apply(ActionT.scala:89)</div><div>org.specs2.control.ActionT$$anonfun$reader$1$$anonfun$apply$6.apply(ActionT.scala:80)</div><div>org.specs2.control.Status$.safe(Status.scala:100)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self$lzycompute(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$ApplicativeIdV$$anonfun$point$1.apply(ApplicativeSyntax.scala:33)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.std.FunctionInstances$$anon$1$$anonfun$map$1.apply(Function.scala:56)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free.go2$1(Free.scala:119)</div><div>scalaz.Free.go(Free.scala:122)</div><div>scalaz.Free.run(Free.scala:172)</div><div>scalaz.effect.IO$class.unsafePerformIO(IO.scala:22)</div><div>scalaz.effect.IOFunctions$$anon$6.unsafePerformIO(IO.scala:227)</div><div>org.specs2.control.package$$anon$3.asResult(package.scala:85)</div><div>org.specs2.execute.AsResult$.apply(AsResult.scala:25)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution.setResult(Execution.scala:82)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:73)</div><div>scala.Option.fold(Option.scala:158)</div><div>org.specs2.specification.core.Execution.execute(Execution.scala:73)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:150)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:148)</div><div>org.specs2.specification.core.Fragment.updateExecution(Fragment.scala:49)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:148)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:147)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>scalaz.concurrent.Task$.Try(Task.scala:387)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>java.util.concurrent.FutureTask.run(FutureTask.java:266)</div><div>java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div>java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div>java.lang.Thread.run(Thread.java:745)</div>    </div><div class=\"formstacktrace details\" id=\"1606234234\">      'actual' is not equal to 'expected' (file:1)          </div><div class=\"formstacktrace details\" id=\"498692229\">       (file:1)          </div></pre></form> StylesMost of the time, the display of Fields and Properties can be left as it is but sometimes you want to style the output of labels and values. You can do this by using `decorateWith` and `styleWith` methods, or some equivalent shortcuts:  All the methods above, when named `xxx` are available as `xxxLabel` and `xxxValue` to do the formatting for the label or the value only. The available colors are:  Simple formNow that we know how to create Fields and Properties, creating a `Form` is as easy as putting them on separate lines: Form(\"Address\").    tr(prop(\"street\", actualStreet(123), \"Oxford St\")).    tr(prop(\"number\", actualNumber(123), 20))The form has a title `\"Address\"` and 2 properties, each one on a distinct row. The `actualStreet()` and `actualNumber()`methods are supposed to retrieve the relevant values from a database.In some cases (see the Calculator example below) you can create a header row using the `th` method:`th(field(\"a\"), field(\"b\"))`or `th(\"a\", \"b\")` using an implicit conversion of Any => Field[Any]Inserting the form in a Specification is also very simple: class SpecificationWithForms extends Specification with Forms { def is = s2\"\"\"The address must be retrieved from the database with the proper street and number  ${Form(\"Address\").  tr(prop(\"street\", actualStreet(123), \"Oxford St\")).  tr(prop(\"number\", actualNumber(123), 20))}\"\"\"}One way to encapsulate and reuse this Form across specifications is to define a case class: case class Address(street: String, number: Int) {  def retrieve(addressId: Int) = {    val address = actualAddress(addressId)    Form(\"Address\").      tr(prop(\"street\", address.street, street)).      tr(prop(\"number\", address.number, number))  }}And then you can use it like this: class AddressSpecification extends Specification with Forms { def is = s2\"\"\"The address must be retrieved from the database with the proper street and number  ${Address(\"Oxford St\", 20).     /** expected values */      retrieve(123)               /** actual address id */}\"\"\"} Adding several rows at onceA very practical way to add rows programatically is to start from a list of values and have a function creating a Row object for each value: Form(\"a new Form\").trs(addresses) { a: Address => Row.tr(field(a.number), field(a.street)) } Nesting into another FormForms can be composed of other Forms to display composite information: val address = Form(\"Address\").  tr(field(\"street\", \"Rose Crescent\")).  tr(field(\"number\", 3))val person = Form(\"Person\").  tr(field(\"name\", \"Eric\")).  tr(address)This will be displayed with the address as a nested table inside the main one on the last row. However in some case, it's preferable to have the rows of that Form to be included directly in the outer table. This can be done by *inlining* thenesting Form: val person = Form(\"Person\").    tr(field(\"name\", \"Eric\")).    tr(address.inline)            // address is inlinedAnd the result is: Nesting into an Effect or a PropWhen using Forms in specifications we can describe different levels of abstraction. If we consider the specification of a website for example, we want to be able to use a Form having 2 rows and describing the exact actions to do on the Login page: val loginForm = Form(\"login\").  tr(effect(\"click on login\", clickOn(\"login\"))).  tr(effect(\"enter name\",     enter(\"name\", \"me\"))).  tr(effect(\"enter password\", enter(\"password\", \"pw\"))).  tr(effect(\"submit\",         submit()))However in a \"purchase\" scenario we want all the steps above to represent the login actions as just one step. One way todo this is to transform the login Form to an Effect or a Prop: Form(\"purchase\").  tr(loginForm.toEffect(\"login\")).  tr(selectForm.toEffect(\"select goods\")).  tr(checkTotalForm.toProp(\"the total must be computed ok\").bkWhiteLabel)If everything goes fine, the detailed nested form is not shown:Otherwise: * if the Form is embedded into an Effect, Errors will be reported * if the Form is embedded into a Prop, Failures will be reported, like that<form>    <table><tr><th colspan=\"4\">purchase</th></tr><tr><td colspan=\"3\" style=\"\" class=\"info\">login</td></tr><tr><td colspan=\"3\" style=\"\" class=\"info\">select goods</td></tr><tr><td style=\"background-color:#EEEEEE; background-color:#FFFFFF\">the total must be computed ok</td><td class=\"failure\"><form>    <table><tr><th colspan=\"4\">Check Total</th></tr><tr><td colspan=\"3\" style=\"\" class=\"info\">Compute total</td></tr><tr><td style=\"background-color:#EEEEEE\">Total</td><td class=\"failure\">200</td><td colspan=\"3\" class=\"failure\" onclick=\"showHide(197383054)\">'100' is not equal to '200'</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"197383054\">      '100' is not equal to '200' (file:1)          </div></pre></form></td><td colspan=\"3\" class=\"failure\" onclick=\"showHide(1089405154)\">failed</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"1089405154\">      failed (file:1)      <div>org.specs2.execute.Failure$.apply$default$3(Result.scala:304)</div><div>org.specs2.form.Form.executedResult$lzycompute$1(Form.scala:131)</div><div>org.specs2.form.Form.org$specs2$form$Form$$executedResult$1(Form.scala:129)</div><div>org.specs2.form.Form$$anonfun$toProp$3.apply(Form.scala:136)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property.execute(Property.scala:51)</div><div>org.specs2.control.Property.optionalValue(Property.scala:17)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.control.Exceptions$class.trye(Exceptions.scala:86)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:132)</div><div>org.specs2.execute.ResultExecution$class.executeEither(ResultExecution.scala:80)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:120)</div><div>org.specs2.execute.ResultExecution$class.executeProperty(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:120)</div><div>org.specs2.form.Prop.expectedValue$lzycompute(Prop.scala:50)</div><div>org.specs2.form.Prop.expectedValue(Prop.scala:50)</div><div>org.specs2.form.Prop$$anonfun$1.apply(Prop.scala:56)</div><div>org.specs2.form.Prop$$anonfun$1.apply(Prop.scala:55)</div><div>scala.Option.flatMap(Option.scala:171)</div><div>org.specs2.form.Prop.execute(Prop.scala:55)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>scala.Option.orElse(Option.scala:289)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:176)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:172)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>scalaz.NonEmptyList.map(NonEmptyList.scala:20)</div><div>org.specs2.form.Row.executeRow(Row.scala:38)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.map(TraversableLike.scala:245)</div><div>scala.collection.AbstractTraversable.map(Traversable.scala:104)</div><div>org.specs2.form.Form.executeRows(Form.scala:73)</div><div>org.specs2.form.Form.executeForm(Form.scala:81)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$110.apply(UseForms.scala:244)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$110.apply(UseForms.scala:244)</div><div>org.specs2.specification.create.S2StringContext$$anon$5.append(S2StringContext.scala:96)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:215)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:213)</div><div>scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)</div><div>scala.collection.immutable.List.foldLeft(List.scala:84)</div><div>org.specs2.specification.create.S2StringContextCreation$class.s2(S2StringContext.scala:213)</div><div>org.specs2.Specification.s2(Specification.scala:19)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$.org$specs2$specification$core$SpecStructure$$getRefs$1(SpecStructure.scala:119)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:252)</div><div>scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.getAll$1(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:134)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:124)</div><div>org.specs2.control.ActionT$$anonfun$safe$1.apply(ActionT.scala:89)</div><div>org.specs2.control.ActionT$$anonfun$reader$1$$anonfun$apply$6.apply(ActionT.scala:80)</div><div>org.specs2.control.Status$.safe(Status.scala:100)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self$lzycompute(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$ApplicativeIdV$$anonfun$point$1.apply(ApplicativeSyntax.scala:33)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.std.FunctionInstances$$anon$1$$anonfun$map$1.apply(Function.scala:56)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free.go2$1(Free.scala:119)</div><div>scalaz.Free.go(Free.scala:122)</div><div>scalaz.Free.run(Free.scala:172)</div><div>scalaz.effect.IO$class.unsafePerformIO(IO.scala:22)</div><div>scalaz.effect.IOFunctions$$anon$6.unsafePerformIO(IO.scala:227)</div><div>org.specs2.control.package$$anon$3.asResult(package.scala:85)</div><div>org.specs2.execute.AsResult$.apply(AsResult.scala:25)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution.setResult(Execution.scala:82)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:73)</div><div>scala.Option.fold(Option.scala:158)</div><div>org.specs2.specification.core.Execution.execute(Execution.scala:73)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:150)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:148)</div><div>org.specs2.specification.core.Fragment.updateExecution(Fragment.scala:49)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:148)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:147)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>scalaz.concurrent.Task$.Try(Task.scala:387)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>java.util.concurrent.FutureTask.run(FutureTask.java:266)</div><div>java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div>java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div>java.lang.Thread.run(Thread.java:745)</div>    </div></pre></form> Using tabsIf there are too many fields to be displayed on a Form you can use tabs: s2\"\"\"A person can have 2 addresses ${  Form(\"Addresses\").tr {    tab(\"home\",      Address(\"Oxford St\", 12).        fill(\"Oxford St\", 12)).      tab(\"work\",        Address(\"Rose Cr.\", 3).          fill(\"Rose Cr.\", 3))  }}\"\"\"The first `tab` call will create a `Tabs` object containing the a first tab with \"home\" as the title and an Address form as its content. Then every subsequent `tab` calls on the `Tabs` object will create new tabs:Tabs can also be created from a seq of values. Let's pretend we have a list of `Address` objects with a name and a Form displaying the `Address` values. You can write: Form(\"Addresses\").tabs(addresses) { address: Address => tab(address.street, address.form) } Aggregating formsNow that we've defined a form for a simple entity, let's see how we can reuse it with a larger entity: * the Customer form defines a name attribute and embeds an instance of the Address form * it is defined by setting the name on one row and the Address form on the second row*[and for this example, we define a slightly different Address form]* case class Address(street: String, number: Int) {  def actualIs(address: Address) = {    Form(\"Address\").      tr(prop(\"street\", address.street, street)).      tr(prop(\"number\", address.number, number))  }}case class Customer(name: String, address: Address) {  def retrieve(customerId: Int) = {    val customer = actualCustomer(customerId)    Form(\"Customer\").      tr(prop(\"name\", customer.name)(name)).      tr(address.actualIs(customer.address))  }  def actualCustomer(customerId: Int): Customer = this // fetch from the database}class CustomerSpecification extends Specification with Forms { def is = s2\"\"\"The customer must be retrieved from the database with a proper name and address ${  Customer(name = \"Eric\",    address = Address(street = \"Rose Crescent\", number = 2)).    retrieve(123)  }\"\"\"}As you also see above, named arguments can bring more readability to the expected values. Lazy cellsFields, Props and Forms are added right away to a row when building a Form with the `tr` method. If it is necessary to add them with a \"call-by-name\" behavior, the `lazify` method can be used: def address = Address() // build an Addressdef customer = Customer()Form(\"Customer\").  tr(prop(\"name\", customer.name)(\"name\")).  // the address Form will be built only when the Customer Form is rendered  tr(lazify(address.actualIs(customer.address))) Xml cellsAny xml can be \"injected\" on a row by using an `XmlCell`: Form(\"Customer\").  tr(prop(\"name\", Customer().name)(\"name\")).  tr(XmlCell(<div><b>this is a bold statement</b></div>)) 1-n relationshipsWhen there are 1 - n relationships between entities the situation gets bit more complex.For example you can have an \"Order\" entity, which has several \"OrderLines\". In that case there are several things that we might want to specify: * the expected rows are included in the actual rows, with no specific order (this is the usual case) * the expected rows are included in the actual rows, in the same order * the expected rows are exactly the actual rows, with no specific order * the expected rows are exactly the actual rows, in the same orderLet's see how to declare this. The 2 classes we're going to use are:import Form._case class Order(orderId: Int) {  lazy val actualLines = // those should be extracted from the actual order entity retrieved by id    OrderLine(\"PIS\", 1) ::      OrderLine(\"PS\", 2) ::      OrderLine(\"BS\", 3) ::      OrderLine(\"SIS\", 4) ::      Nil  def base = Forms.form(\"Order\").th(\"name\", \"qty\")  def hasSubset(ls: OrderLine*)      = base.subset(actualLines, ls)  def hasSubsequence(ls: OrderLine*) = base.subsequence(actualLines, ls)  def hasSet(ls: OrderLine*)         = base.set(actualLines, ls)  def hasSequence(ls: OrderLine*)    = base.sequence(actualLines, ls)}case class OrderLine(name: String, quantity: Int) {  def form = tr(field(name), field(quantity))}The `OrderLine` class simply creates a form with 2 fields: name and quantity. The `Order` class is able to retrieve the actual order entity (say, from a database) and to extract `OrderLine` instances. It also has several methods to build Forms depending on the kind of comparison that we want to do. Subset`Form.subset` uses the `FormDiffs.subset(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are left untouched * lines existing in `a` and `b` are marked as success * lines existing in `b` and not `a` are marked as failures Order(123).hasSubset(  OrderLine(\"BS\", 3),  OrderLine(\"PIS\", 1),  OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"success\" style=\"\">PIS</td><td colspan=\"5\" class=\"success\" style=\"\">1</td></tr><tr><td class=\"info\" style=\"\">PS</td><td colspan=\"5\" class=\"info\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"info\" style=\"\">SIS</td><td colspan=\"5\" class=\"info\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Subsequence`Form.subsequence` uses the `FormDiffs.subsequence(a, b)` method to calculate the differences and add them to the Form: * lines existing in `a` but not `b` are left untouched * lines existing in `a` and `b` in the same order are marked as success * lines existing in `b` and not `a` are marked as failures * lines existing in `b` and `a` but out of order are marked as failures Order(123).hasSubsequence(  OrderLine(\"PS\", 2),  OrderLine(\"BS\", 3),  OrderLine(\"PIS\", 1),  OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"failure\" style=\"\">PIS</td><td colspan=\"5\" class=\"failure\" style=\"\">1</td></tr><tr><td class=\"success\" style=\"\">PS</td><td colspan=\"5\" class=\"success\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"info\" style=\"\">SIS</td><td colspan=\"5\" class=\"info\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Set`Form.set` uses the `FormDiffs.set(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are marked as failures * lines existing in `a` and `b` are marked as success * lines existing in `b` and not `a` are marked as failures Order(123).hasSet(  OrderLine(\"BS\", 3),  OrderLine(\"PIS\", 1),  OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"success\" style=\"\">PIS</td><td colspan=\"5\" class=\"success\" style=\"\">1</td></tr><tr><td class=\"failure\" style=\"\">PS</td><td colspan=\"5\" class=\"failure\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"failure\" style=\"\">SIS</td><td colspan=\"5\" class=\"failure\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Sequence`Form.sequence` uses the `FormDiffs.sequence(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are marked as failures * lines existing in `a` and `b` in the right order are marked as success * lines existing in `b` and not `a` are marked as failures Order(123).hasSequence(    OrderLine(\"PS\", 2),    OrderLine(\"BS\", 3),    OrderLine(\"PIS\", 1),    OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"failure\" style=\"\">PIS</td><td colspan=\"5\" class=\"failure\" style=\"\">1</td></tr><tr><td class=\"success\" style=\"\">PS</td><td colspan=\"5\" class=\"success\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"failure\" style=\"\">SIS</td><td colspan=\"5\" class=\"failure\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Decision tablesOne very popular type of Forms are *decision tables*. A decision table is a Form where, on each row, several values are used for a computation and the result must be equal to other values on the same row. A very simple example of this is a calculator: case class Calculator(form: Form = Form()) {  def tr(a: Int, b: Int, a_plus_b: Int, a_minus_b: Int) = Calculator {    def plus = prop(a + b)(a_plus_b)    def minus = prop(a - b)(a_minus_b)    form.tr(a, b, plus, minus)  }}def th(title1: String, titles: String*) = Calculator(Form.th(title1, titles:_*))The `Calculator` object defines a `th` method to create the first `Calculator` Form, with the proper title. The `th` method: * takes the column titles (there must be at least one title) * creates a header row on the form * returns a new Calculator containing this form (note that everything is immutable here)The `Calculator` case class embeds a Form and defines a `tr` method which * takes actual and expected values * creates properties for the computations * creates a form with a new row containing those fields and properties * returns a new Calculator containing this formAnd you use the `Calculator` Form like this: class CalculatorSpecification extends Specification with Forms { def is  = s2\"\"\" A calculator must add and subtract Ints ${   Calculator.     th(\"a\", \"b\", \"a + b\", \"a - b\").     tr(1,   2,   3,       -1     ).     tr(2,   2,   4,       0      ) }\"\"\"}Here is the output:And if something goes wrong:<form>    <table><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>b</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a + b</b></td><td colspan=\"9\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a - b</b></td></tr><tr><td class=\"info\" style=\"\">1</td><td class=\"info\" style=\"\">2</td><td class=\"success\">3</td><td colspan=\"9\" class=\"success\">-1</td></tr><tr><td class=\"info\" style=\"\">2</td><td class=\"info\" style=\"\">2</td><td class=\"success\">4</td><td class=\"failure\">2</td><td colspan=\"9\" class=\"failure\" onclick=\"showHide(1982810141)\">'0' is not equal to '2'</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"1982810141\">      '0' is not equal to '2' (file:1)          </div></pre></form>And when it goes *very* wrong (like throwing an `error(\"very wrong\")`), there will be red cells and stacktraces:<form>    <table><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>b</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a + b</b></td><td colspan=\"9\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a - b</b></td></tr><tr><td class=\"info\" style=\"\">1</td><td class=\"info\" style=\"\">2</td><td class=\"success\">3</td><td colspan=\"9\" class=\"success\">-1</td></tr><tr><td class=\"info\" style=\"\">2</td><td class=\"info\" style=\"\">2</td><td class=\"success\">4</td><td class=\"error\">2</td><td colspan=\"9\" class=\"error\" onclick=\"showHide(1316990506)\">java.lang.RuntimeException: very wrong</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"1316990506\">      java.lang.RuntimeException: very wrong (file:1)      <div>scala.sys.package$.error(package.scala:27)</div><div>org.specs2.guide.UseForms$WrongCalculator$$anonfun$minus$3$3.apply$mcI$sp(UseForms.scala:574)</div><div>org.specs2.guide.UseForms$WrongCalculator$$anonfun$minus$3$3.apply(UseForms.scala:574)</div><div>org.specs2.guide.UseForms$WrongCalculator$$anonfun$minus$3$3.apply(UseForms.scala:574)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property.execute(Property.scala:51)</div><div>org.specs2.control.Property.optionalValue(Property.scala:17)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.control.Exceptions$class.trye(Exceptions.scala:86)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:132)</div><div>org.specs2.execute.ResultExecution$class.executeEither(ResultExecution.scala:80)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:120)</div><div>org.specs2.execute.ResultExecution$class.executeProperty(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:120)</div><div>org.specs2.form.Prop.actualValue$lzycompute(Prop.scala:48)</div><div>org.specs2.form.Prop.actualValue(Prop.scala:48)</div><div>org.specs2.form.Prop.execute(Prop.scala:55)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>scala.Option.orElse(Option.scala:289)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:176)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:172)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>scala.collection.immutable.List.map(List.scala:277)</div><div>scalaz.NonEmptyList.map(NonEmptyList.scala:20)</div><div>org.specs2.form.Row.executeRow(Row.scala:38)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.map(TraversableLike.scala:245)</div><div>scala.collection.AbstractTraversable.map(Traversable.scala:104)</div><div>org.specs2.form.Form.executeRows(Form.scala:73)</div><div>org.specs2.form.Form.executeForm(Form.scala:81)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$139.apply(UseForms.scala:527)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$139.apply(UseForms.scala:527)</div><div>org.specs2.specification.create.S2StringContext$$anon$5.append(S2StringContext.scala:96)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:215)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:213)</div><div>scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)</div><div>scala.collection.immutable.List.foldLeft(List.scala:84)</div><div>org.specs2.specification.create.S2StringContextCreation$class.s2(S2StringContext.scala:213)</div><div>org.specs2.Specification.s2(Specification.scala:19)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$.org$specs2$specification$core$SpecStructure$$getRefs$1(SpecStructure.scala:119)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:252)</div><div>scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.getAll$1(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:134)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:124)</div><div>org.specs2.control.ActionT$$anonfun$safe$1.apply(ActionT.scala:89)</div><div>org.specs2.control.ActionT$$anonfun$reader$1$$anonfun$apply$6.apply(ActionT.scala:80)</div><div>org.specs2.control.Status$.safe(Status.scala:100)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self$lzycompute(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$ApplicativeIdV$$anonfun$point$1.apply(ApplicativeSyntax.scala:33)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.std.FunctionInstances$$anon$1$$anonfun$map$1.apply(Function.scala:56)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free.go2$1(Free.scala:119)</div><div>scalaz.Free.go(Free.scala:122)</div><div>scalaz.Free.run(Free.scala:172)</div><div>scalaz.effect.IO$class.unsafePerformIO(IO.scala:22)</div><div>scalaz.effect.IOFunctions$$anon$6.unsafePerformIO(IO.scala:227)</div><div>org.specs2.control.package$$anon$3.asResult(package.scala:85)</div><div>org.specs2.execute.AsResult$.apply(AsResult.scala:25)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution.setResult(Execution.scala:82)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:73)</div><div>scala.Option.fold(Option.scala:158)</div><div>org.specs2.specification.core.Execution.execute(Execution.scala:73)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:150)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:148)</div><div>org.specs2.specification.core.Fragment.updateExecution(Fragment.scala:49)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:148)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:147)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>scalaz.concurrent.Task$.Try(Task.scala:387)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>java.util.concurrent.FutureTask.run(FutureTask.java:266)</div><div>java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div>java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div>java.lang.Thread.run(Thread.java:745)</div>    </div></pre></form>Note that the Calculator class is not, in itself an Example. But there is an implicit definition automatically transforming `Any { def form: Form }` to `Example` so that an explicit call to `.form` is not necessary in order to include the Form in the specification.", "tags":"", "loc":"org.specs2.guide.UseForms.html"},
{"title":"Auto-numbered examples", "text":"In the  section we can see that there is a way to create groups of examples with standard names and use these names in the specification text (via the `s2` interpolated string). Here we go a step further.The specification text is going to be some pure text, the examples will be described as example groups and the numbers will be created automatically. What does it look like? class BulletedExamplesSpec extends script.Specification with Groups { def is = \"\"\"  This is an introduction  First section  =============  A bit more text there.   + and the first example   + and the second example  Second section  =============  Then another section   + and the third example   + and the fourth example\"\"\"  \"first section\" - new group {    eg := 1 must_== 1    eg := 1 must_== 1  }  \"second section\" - new group {    eg := 1 must_== 1  }}This style of specification uses the `org.specs2.specification.script.Specification` class and mixes-in the `Groups` trait to create example groups. You can notice that: - Nothing is interpolated in the text that defines the `is` method - groups are anonymous, just called `group` - examples are anonymous, just called `eg` ([_exampli gratia_](http://en.wikipedia.org/wiki/List_of_Latin_phrases_(E)#exempli_gratia) in latin, meaning \"for example\")At runtime, the text gets parsed and: - each Markdown header (underlined with `=====` or starting with `#`, ``, ``,... as per the markdown convention) marks the creation of a new example group - each text starting with `+` marks the creation of an example - groups and examples in the text are coupled with their counterpart in the code - if groups or examples are missing in the code, they are still created in the final specification but marked as `pending` - each group is enclosed in a `section` with the group name (automatically numbered, starting from `g1`) - each example is tagged with its group name, and its number (automatically numbered, starting from `e1`)So, in the specification above the fourth example will be marked as `pending (g2.e2)` where `g2` is the group name and `e2` is the example name. As you can guess, sections and tags make it easy to just re-run parts of the specification without having to create those sections and tags yourself.The major issue with this style of specification is that you cannot use your IDE to navigate from a piece of text to the corresponding code. You have to count the groups and count the number of examples to find the right one.", "tags":"", "loc":"org.specs2.guide.AutoNumberedExamples.html"},
{"title":"Named examples", "text":" Naming examplesWhen you create acceptance specifications, you have to find names to reference your examples and this can sometimes be a bit tedious. So why not have the specification do it for you? With the `org.specs2.specification.Grouped` trait you get \"group traits\", from `g1` to `g22` to define groups of examples. Each group trait defines 22 variables named `e1` to `e22`, to define examples.Here is an example on how to use groups: class MySpecification extends Specification with specification.Grouped { def is =  s2\"\"\"  first example in first group                                        ${g1.e1}  second example in first group                                       ${g1.e2}  first example in second group                                       ${g2.e1}  second example in second group                                      ${g2.e2}  third example in second group, not yet implemented                  ${g2.e3}  \"\"\"  // group of examples with no description  new g1 {    e1 := ok    e2 := ok  }  // group of examples with a description for the group  \"second group of examples\" - new g2 {    e1 := ok    e2 := ok  }}One cool feature is that with groups you can use the example names right away with no implementation. For example if you write `this is an example ${g2.e3}`, without providing an implementation, the example will be marked as `Pending`. Grouped vs GroupsThe groups from the `Grouped` trait can hold variables which you can use in your examples. However you must be careful because those variables will be shared across all the examples of a group. You can avoid this by using the `Groups` trait like this: class MySpecification extends Specification with specification.Groups { def is =  s2\"\"\"  first example    ${g1().e1}  second example   ${g1().e2}  \"\"\"  \"first group\" - new g1 {    val list: ListBuffer[Int] = new scala.collection.mutable.ListBuffer[Int]    e1 := {      list += 1      list must haveSize(1)    }    // the second example is isolated from the first and will succeed    e2 := {      list.append(1, 2, 3)      list must haveSize(3)    }  }}", "tags":"", "loc":"org.specs2.guide.NamedExamples.html"},
{"title":"Specification formatting", "text":"Acceptance specifications are displayed in the console almost as they are in `.scala` files thanks to interpolated strings. However it is not obvious to know how to change the display of a unit specification. How do you add a new line after an example? After the specification title? How do you indent a group of examples a bit more?First of all, you can always add a piece text by using the `txt` method on a `String`:class UnitSpec extends mutable.Specification {  \"\"\" This is a long and important introduction to this specification. The examples below show everything you can do with the system.  \"\"\".txt}Then if you want to add new lines you can use: - `br` (\"break\") to add a newline after any fragment, text, example... - `p` (\"paragraph\") to make a new paragraph with a break before and 2 afterTexts, or blocks of examples can also get a special indentation by using the `tab` and `backtab` methods:class UnitSpec extends mutable.Specification {\"\"\"This is a long and important introduction to this specification.\"\"\".txt\"\"\"The examples below show everything you can do with the system.\"\"\".txt.tab(3) // indent the text with 3 tabs compared to the previous text}", "tags":"", "loc":"org.specs2.guide.SpecificationFormatting.html"},
{"title":"Reference other specifications", "text":"For some large projects, or to write documentation, you will need to structure your specifications so that some of them will reference others. Those references will be of 2 types: - \"see\" reference: a simple textual reference, with an html link to navigate to the other specification when you create an html report - \"link\" reference: an \"executed\" reference where the second specification will be executed and its status reported in the first oneHere is the DSL you will use for those 2 types of references:object FirstSpecification extends Specification { def is = s2\"\"\" We can consider one example  ${ 1 must_== 1 }  And all these examples are also important so we need to know if they all pass  ${\"important specification\" ~ SecondSpecification}  Finally it is worth having a look at ${\"this specification\" ~/ ThirdSpecification}.\"\"\"}import org.specs2.specification.core._object SecondSpecification extends Specification { def is = s2\"\"\" This spec contains lots of examples   ${ Fragment.foreach(1 to 100) { i => \"example \"+i ! ok } }\"\"\"}object ThirdSpecification extends Specification { def is = s2\"\"\" This is the third specification with a simple example   this should pass $ok\"\"\"}The syntax shown above to create references is using a string for the link alias and uses two operators: Operator  | Description --------- | ----------- `~`       | a *`link` reference*. The referenced specification gets executed when the first one is `~/`      | a *`see` reference*. The referenced specification doesn't get executed (`\"$FirstSpecification\"` creates a *see* link as well)Also, for better html rendering, you can add a tooltip:  ${ \"alias\" ~/ (OtherSpec, \"tooltip\") }Finally I'm also drawing your attention to the fact that you don't have to create your specifications as Scala classes but you can use simple objects as shown above. ReportingBy default specification links are reported with a status icon in HTML pages. You can change this by using the following methods: - `link(MySpec).hide` doesn't show the link at all. This is useful when you want a children specification to be executed from a parent one without having to mention it - `link(MySpec).mute` doesn't show the link status. This is useful when you want a children specification to be executed from a parent one but just display its html link ExecutionWhen you execute a given specification you can pass the `all` argument to execute all the referenced specifications. They will be collected and executed in (topological sort)[http://en.wikipedia.org/wiki/Topological_sorting] order and any cycle in the reference graph will be broken. Only the \"link\" references will be executed, not the \"see\" references.", "tags":"", "loc":"org.specs2.guide.ReferenceOtherSpecifications.html"},
{"title":"Get all expectations", "text":"The 2 main modes of expectations in specs2 are:  - No thrown expectations  - thrown expectationsThey correspond to different style of declaring expectations and you will use one or the other depending on how many expectations you have per example.The `org.specs2.specification.AllExpectations` trait goes further and gives you the possibility to report _all_ the failures of an Example without stopping at the first failure. This enables a type of specification where it is possible to define lots of expectations inside the body of an example and get a maximum of information on what fails and what passes: import org.specs2.specification.AllExpectationsimport org.specs2.mutable.Specificationclass AllExpectationsSpec extends Specification with AllExpectations {  \"In this example all the expectations are evaluated\" >> {    1 === 2  // this fails    1 === 3  // this also fails    1 === 1  }  \"There is no collision with this example\" >> {    10 === 11 // this fails    12 === 12    13 === 31 // this also fails  }}The second example above hints at a restriction for this kind of Specification. The failures are accumulated for each example by mutating a shared variable. \"Mutable\" means that the concurrent execution of examples will be an issue if done blindly. To avoid this, the `AllExpectations` trait overrides the `Specification` arguments to make it  (unless it is already `isolated` or `sequential`).", "tags":"", "loc":"org.specs2.guide.GetAllExpectations.html"},
{"title":"Given when then", "text":" PresentationThe Given/When/Then style structures the specification with 3 main elements: - Given steps: actions which setup the system - When steps:  command which your are currently specifying - Then steps:  expectations about the end state of the systemIn specs2 the support for Given/When/Then can be more or less complex depending on the features you wish to use: - basic support: given and when steps are just commands on a system, returning no value - intermediate support: given/when/then steps can parse part of the text to create their commands - full support: variables are not necessary to save intermediate values and the given/when/then order is enforced Basic support With an acceptance specificationGiven/When/Then specifications are easy to write using the acceptance style, you just use regular text, steps and examples:class GWTSpec extends Specification { def is = s2\"\"\" Given a first number         $g1 When I double it             $w1 Then I get twice that number $t1\"\"\"  var number = 0  def g1 = step {    // do something to provide a number    number = 1  }  def w1 = step {    // do an action    number *= number  }  // check the result  def t1 = number must_== 2} With a mutable specificationWith a mutable specification you would write:class GWTSpec extends mutable.Specification { \"Given a first number\".txt.p  step { number = 1 }  \"When I double it\".br  step { number *= number }  \"Then I get twice that number\" >> {    number must_== 2  }  var number = 0} Intermediate supportGiven/When/Then specifications are often written as blocks of text where part of the text contains values to use during the execution. For example:This is a specification for a bank transfer given an account with the amount {100} given another account with the amount {500} when we transfer {50} from the first account to the second then the first amount is {50} and the second is {550}How do you code this with an acceptance specification? With an acceptance specificationYou can implement this approach with the `org.specs2.specification.dsl.GWT` trait:class GWTSpec extends Specification with specification.dsl.GWT with StandardDelimitedStepParsers { def is = s2\"\"\" Given a first number {2}     $g1 When multiply it by {3}      $w1 Then I get {6}               $t1\"\"\"  var number = 0  def g1 = step(anInt) { i => number = i }  def w1 = step(anInt) { j => number = number * j }  def t1 = example(anInt) { n => number must_== n }}Now we need a bit of help to extract values from the text. This is provided in the form of `StepParsers`. Delimited parsersThe easiest way to extract values from a string is to delimit exactly where are the values to extract, then to provide a way to give them meaningful types. This is the role of `StepParsers`. Those parsers are using `{}` as delimiters for the values you want to extract. For example you can define an extractor for Int values like this: val anInt = StepParser((_: String).toInt)The `anInt` step parser has a method `parse(text: String)` returning: - either an exception if the parse is unsuccessful - or the desired value + the original text stripped for its delimitersYou can change the delimiters being used by overriding the implicit regular expression from the `StepParsers` trait:   // use `[]` as a delimiter  override implicit lazy val stepParserRegex = new Regex(\"\\[([\\]]+)\\]\")But you can also specify another regular expression \"locally\" for a given step parser:val anInt = StepParser((_: String).toInt)(new Regex(\"\\[([\\]]+)\\]\"))Finally `StepParsers` can collect all the delimited values at once with the `seq` method:StepParser.seq((seq: Seq[String]) => seq.map(_.toInt).sum).parse(\"values {1}, {2}, {3}\") === Right(6) Regex parsersMore generally you can use any regular expression to parse values with the `readAs` and `groupAs` methods // match the whole lineval anInt1 = readAs(\".*(\\d+).*\").and((s: String) => s.toInt)// just declare the groups you want to matchval anInt2 = groupAs(\"\\d+\").and((s: String) => s.toInt)// note: if you want to extract 2 ints, just pass a function of 2 argumentsval twoInts = groupAs(\"\\d+\").and((s1: String, s2: String) => (s1.toInt, s2.toInt)) Standard parsersA few `StepParsers` have been predefined for you in the `StandardDelimitedStepParsers` and `StandardRegexStepParsers` traits to extract `Int`s, `Double`s and `String`s: - `anInt`, `twoInts`, `threeInts` - `aDouble`, `twoDoubles`, `threeDoubles` - `aString`, `twoStrings`, `threeStrings` With a mutable specificationSeveral syntaxes are available with a mutable specification. The first syntax uses modified `step` and `example` methods to create steps and examples:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers {  \"adding numbers\".p  step(\"Given a first number {2}\")(anInt) { i =>    number = i  }  step(\"When I multiply it by {3}\")(anInt) { j =>    number = number * j  }  example(\"Then I get {6}\")(anInt) { n: Int =>    number must_== n  }  var number = 0}The second syntax is mostly the same but with postfix methods:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers {  \"adding numbers\".p  \"Given a first number {2}\".step(anInt) { i =>    number = i  }  \"When I multiply it by {3}\".step(anInt) { j =>    number = number * j  }  \"Then I get {6}\".example(anInt) { n: Int =>    number must_== n  }  var number = 0}Those two syntaxes are just specialisations of the `mutable.GivenWhenThen` trait which provides  `Given/When/Then` keywords:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers with GivenWhenThenSyntax {  \"adding numbers\".p  Given(\"a first number {2}\")(anInt) { i =>    number = i  }  When(\"I multiply it by {3}\")(anInt) { j =>    number = number * j  }  Then(\"I get {6}\")(anInt) { n: Int =>    number must_== n  }  var number = 0}This will create sentences such as:Given a first number 2When I multiply it by 3Then I get 6If you prefer to have uncapitalized `given/when/then` methods you can use the `GivenWhenAndThenSyntax` trait:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT  with StandardDelimitedStepParsers with GivenWhenAndThenSyntax {  \"adding numbers\".p  given(\"a first number {2}\")(anInt) { i =>    number = i  }  when(\"I multiply it by {3}\")(anInt) { j =>    number = number * j  }  andThen(\"I get {6}\")(anInt) { n: Int =>    number must_== n  }  var number = 0}Which rendersgiven a first number 2when I multiply it by 3then I get 6In this case `andThen` has to be used in place of `then` because `then` is going to become a Scala keyword in future releases. Full supportThe full support fixes an issue with all the previous styles: the necessity to create mutable variables to keep track of state changes between steps and examples. It also enforces statically a proper sequencing of the Given/When/Then actions.Here, we mix-in the `org.specs2.specification.script.GWT` trait. This trait provides a class, `Scenario`, to parse the specification text and create `Steps` and `Examples`. Let's see an example:class GWTSpec extends Specification with org.specs2.specification.script.GWT with StandardRegexStepParsers { def is = s2\"\"\" A given-when-then example for a calculator                       ${calculator1.start}   Given the following number: 1   And a second number: 2   And a third number: 6   When I use this operator: +   Then I should get: 9   And it should be >: 0                                          ${calculator1.end}\"\"\"  val anOperator = readAs(\".*: (.)$\").and((s: String) => s)  val calculator1 =    Scenario(\"calculator1\").      given(anInt).      given(anInt).      given(anInt).      when(anOperator) { case op :: i :: j :: k :: _ => if (op == \"+\") i + j + k else i * j * k }.      andThen(anInt)   { case expected :: sum :: _ => sum === expected}.      andThen(anInt)   { case expected :: sum :: _ => sum must be_>(expected)}}In this example, `calculator1.start` marks the beginning of a Given/When/Then section and each line until `calculator1.end` must correspond to a `given`, `when` or `andThen` call on the scenario. * `given` uses a `StepParser` to extract values for a line of text * `when` uses a `StepParser` to extract values from the corresponding line of text and a `mapping` function to combine the result of the extraction + all the values from the given steps * `andThen` uses a `StepParser` (usually to extract expected values) and a `check` function taking `when values` and returning a `Result`More precisely, the functions passed to a `when` step must be of the form * `when(aStepParser) { case p1 :: p2 :: .. :: _ => w1 }`, where `p1` has the type extracted from `aStepParser` and `p2 .. pn` have the types of the values extracted by the previous `given` steps * `when(aStepParser).collect { case (p1, p2n: Seq[LUB]) => w1 }`, where `p1` has the type extracted from `aStepParser` and `p2n` is a `Seq[LUB]` where `LUB` is the least upper bound of the types of all the values extracted by the previous `given` steps`::` is the [Shapeless](https://github.com/milessabin/shapeless) `HCons` operator so don't forget to add the Shapeless dependency to your project if you are using the `GWT` trait!And similarly for `andThen` steps * `andThen(aStepParser) { case p1 :: p2 :: .. :: _ => r: R }`, where `p1` has the type extracted from `aStepParser` and `p2 .. pn` have the types of the values mapped by the previous `when` steps * `andThen(aStepParser).collect { case (p1, p2n: Seq[LUB]) => r: R }`, where `p1` has the type extracted from `aStepParser` and `p2n` is a `Seq[LUB]` where `LUB` is the least upper bound of the types of all the values mapped by the previous `when` stepsThe type `R` of the value `r` must be such that there is an `AsResult` type class instance in scope to transform it to a `Result`. In other words r is: a `Boolean`, a `MatchResult[_]`, a ScalaCheck `Prop`,...You will also note that the `Scenario` class restricts the order of methods which you can call. It always has to be `given* -> when* -> andThen*`. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - read about the </div>", "tags":"", "loc":"org.specs2.guide.GivenWhenThenStyle.html"},
{"title":"Auto-examples", "text":"When you want to specify an API, most of your examples are self-describing:class SeqSpecification extends mutable.Specification {  \"updateLast modifies the last element of a Seq\".p   \"when the collection has 1 element\"  >> { Seq(1).updateLast(_ + 1)     must_== Seq(2) }   \"when the collection has 2 elements\" >> { Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3) }   \"when the collection is empty\"       >> { Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() }}It is a bit redundant to provide a textual description for these 3 examples because the code is pretty clear and simple. In this situation you can use the `eg` operator to create an example where the description will be the code itself:class SeqSpecification extends mutable.Specification {  \"updateLast modifies the last element of a Seq\".p  eg { Seq(1).updateLast(_ + 1)     must_== Seq(2)     }  eg { Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3)  }  eg { Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() }}This prints:[info] updateLast modifies the last element of a Seq[info]  Seq(1).updateLast(_ + 1)     must_== Seq(2)[info]  Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3)[info]  Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() In an acceptance specificationAcceptance specifications are using interpolated strings so you can directly write:class SeqSpecification extends Specification { def is = s2\"\"\"  updateLast modifies the last element of a Seq  ${ Seq(1).updateLast(_ + 1)     must_== Seq(2)     }  ${ Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3)  }  ${ Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() }\"\"\"}There is a huge gotcha though! Each of these expressions needs an implicit conversion to be included in the interpolated spec. And in Scala, if you have a block of code returning a value of type `T`, ***only the last expression of the block is converted***. This means that if there is a statement in the block that throws an exception, this exception won't be caught and the whole specification will fail to be instantiated! So if you want to use blocks as auto-examples you should better wrap them with an `eg` call:class SeqSpecification extends Specification { def is = s2\"\"\"  This is a problematic specification  ${ sys.error(\"ouch, this one is going to blow up the spec\"); Seq(1).updateLast(_ + 1) must_== Seq(2) }  ${ eg { sys.error(\"it's ok, this one is well protected\");    Seq(1).updateLast(_ + 1) must_== Seq(2) } }\"\"\"}", "tags":"", "loc":"org.specs2.guide.AutoExamples.html"},
{"title":"Reference other specifications", "text":"For some large projects, or to write documentation, you will need to structure your specifications so that some of them will reference others. Those references will be of 2 types: - \"see\" reference: a simple textual reference, with an html link to navigate to the other specification when you create an html report - \"link\" reference: an \"executed\" reference where the second specification will be executed and its status reported in the first oneHere is the DSL you will use for those 2 types of references:object FirstSpecification extends Specification { def is = s2\"\"\" We can consider one example  ${ 1 must_== 1 }  And all these examples are also important so we need to know if they all pass  ${\"important specification\" ~ SecondSpecification}  Finally it is worth having a look at ${\"this specification\" ~/ ThirdSpecification}.\"\"\"}import org.specs2.specification.core._object SecondSpecification extends Specification { def is = s2\"\"\" This spec contains lots of examples   ${ Fragment.foreach(1 to 100) { i => \"example \"+i ! ok } }\"\"\"}object ThirdSpecification extends Specification { def is = s2\"\"\" This is the third specification with a simple example   this should pass $ok\"\"\"}The syntax shown above to create references is using a string for the link alias and uses two operators: Operator  | Description --------- | ----------- `~`       | a *`link` reference*. The referenced specification gets executed when the first one is `~/`      | a *`see` reference*. The referenced specification doesn't get executed (`\"$FirstSpecification\"` creates a *see* link as well)Also, for better html rendering, you can add a tooltip:  ${ \"alias\" ~/ (OtherSpec, \"tooltip\") }Finally I'm also drawing your attention to the fact that you don't have to create your specifications as Scala classes but you can use simple objects as shown above. ReportingBy default specification links are reported with a status icon in HTML pages. You can change this by using the following methods: - `link(MySpec).hide` doesn't show the link at all. This is useful when you want a children specification to be executed from a parent one without having to mention it - `link(MySpec).mute` doesn't show the link status. This is useful when you want a children specification to be executed from a parent one but just display its html link ExecutionWhen you execute a given specification you can pass the `all` argument to execute all the referenced specifications. They will be collected and executed in (topological sort)[http://en.wikipedia.org/wiki/Topological_sorting] order and any cycle in the reference graph will be broken. Only the \"link\" references will be executed, not the \"see\" references.", "tags":"", "loc":"org.specs2.guide.ReferenceOtherSpecifications.html"},
{"title":"Syntactic variations", "text":"The \"standard\" way of using matchers is `value must matcher`. However there are several allowed variations:// use 'should' instead of 'must'1 should beEqualTo(1)// use 'beXXX' and 'haveXXX' as 'be XXX' and 'have XXX'1 must be equalTo(1)List(1) must have size(1)// use 'not' to negate a matcherList(1) must not have size (1)Finally there are some shortcuts for the equality matcher:1 must_== 11 mustEqual 11 === 1// with a negation1 must_!= 21 mustNotEqual 11 !=== 1 Postfix operationsThe notation `Seq() must be empty` is being parsed as `(Seq() must be) empty` where `empty` is a [\"Postfix operator\"](http://www.scala-lang.org/api/2.11.6/index.html#scala.language$). By default Scala disallows postfix operators but they are enabled in specs2 specifications thanks to the `org.spec2.control.LanguageFeatures` trait providing the `language.postfixOps` implicit definition.If that implicit definition conflicts with your own import of `language.postfixOps` you can use the `org.spec2.control.NoLanguageFeatures` trait to deactivate it.", "tags":"", "loc":"org.specs2.guide.matchers.SyntacticVariations.html"},
{"title":"Specification formatting", "text":"Acceptance specifications are displayed in the console almost as they are in `.scala` files thanks to interpolated strings. However it is not obvious to know how to change the display of a unit specification. How do you add a new line after an example? After the specification title? How do you indent a group of examples a bit more?First of all, you can always add a piece text by using the `txt` method on a `String`:class UnitSpec extends mutable.Specification {  \"\"\" This is a long and important introduction to this specification. The examples below show everything you can do with the system.  \"\"\".txt}Then if you want to add new lines you can use: - `br` (\"break\") to add a newline after any fragment, text, example... - `p` (\"paragraph\") to make a new paragraph with a break before and 2 afterTexts, or blocks of examples can also get a special indentation by using the `tab` and `backtab` methods:class UnitSpec extends mutable.Specification {\"\"\"This is a long and important introduction to this specification.\"\"\".txt\"\"\"The examples below show everything you can do with the system.\"\"\".txt.tab(3) // indent the text with 3 tabs compared to the previous text}", "tags":"", "loc":"org.specs2.guide.SpecificationFormatting.html"},
{"title":"Reference card", "text":" EqualityThe most common type of matcher is `beEqualTo` to test the equality of 2 values. Several syntaxes can be used, according to your own taste Matcher                    |  Comment -------------------------- | -------------------------- `1 must beEqualTo(1)      `| the normal way `1 must be_==(1)          `| with a symbol `1 must_== 1              `| my favorite! `1 mustEqual 1            `| if you dislike underscores `1 should_== 1            `| for `should` lovers `1 === 1                  `| the ultimate shortcut `1 must be equalTo(1)     `| with a literate styleThere are also other notions of equality Matcher                    |  Comment -------------------------- | -------------------------- `beTypedEqualTo           `| typed equality. `a must beTypedEqualTo(b)` will not work if `a` and `b` don't have compatible types `be_===                   `| synonym for `beTypedEqualTo` `a ==== b                 `| synonym for `a must beTypedEqualTo(b)` `a must_=== b             `| similar to `a must_== b` but will not typecheck if `a` and `b` don't have the same type `be_==~                   `| check if `(a: A) == conv(b: B)` when there is an implicit conversion `conv` from `B` to `A` `beTheSameAs              `| reference equality: check if `a eq b` (`a must be(b)` also works) `be                       `| `a must be(b)`: synonym for `beTheSameAs` `beTrue, beFalse          `| shortcuts for Boolean equality_Note_: the `beEqualTo` matcher is using the regular `==` Scala equality. However in the case of `Arrays`, Scala `==` is just using reference equality, `eq`. So the `beEqualTo` matcher has been adapted to use the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested), before checking for equality, so that `Array(1, 2, 3) === Array(1, 2, 3)` (despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`). Out of the boxThese are the all the available matchers when you extend `Specification` OptionalThose matchers are optional. To use them, you need to add a new trait to your specification:", "tags":"", "loc":"org.specs2.guide.matchers.ReferenceCard.html"},
{"title":"Outside specs2", "text":"The specs2 matchers are a well-delimited piece of functionality that you should be able to reuse in your own test framework. You can reuse the following traits: * `org.specs2.matcher.MustMatchers` (or `org.specs2.matcher.ShouldMatchers`) to write anything like `1 must be_==(1)` and   get a `Result` back * **Important**: the `MustMatchers` *trait* will fill-in stacktraces on `MatchResults` to mark the location of a result while the `MustMatchers` object will not. This has some important consequences in terms of performances because creating stack traces is expensive * You can also use the side-effecting version of that trait called `org.specs2.matcher.MustThrownMatchers` (or `org.specs2.matcher.ShouldThrownMatchers`).   It throws a `FailureException` as soon as an expectation is failing * Finally, in a JUnit-like library you can use the `org.specs2.matcher.JUnitMustMatchers` trait which throws `AssertionFailureError`s Without any dependency on specs2It is possible to add testing features to your library without depending on a specific testing library, like specs2 or ScalaTest. You will let clients of your library decide which one they want with the following trait:trait TestInterface {  def fail(msg: String): Nothing  def skip(msg: String): Nothing}// and use the trait in your librarytrait TestKit extends TestInterface {  def runTest(call: =>Unit) = {    // run the code and if there is an error    fail(\"error!\")  }}When there is a failure or an error the library will call the `TestKit` methods. Then the library client can use both the library and specs2 by mixing in the `org.specs2.matcher.ThrownMessages` trait:trait ThrownMessages { this: ThrownExpectations =>  def fail(m: String): Nothing = failure(m)  def skip(m: String): Nothing = skipped(m)}class MySpec extends Specification with TestKit with ThrownMessages { def is = s2\"\"\"  An example using the TestKit $e1\"\"\"  def e1 = {    // do something with the library    runTest(...)  }}", "tags":"", "loc":"org.specs2.guide.matchers.OutsideSpecs2.html"},
{"title":"Other build tools", "text":"The most straightforward way to run specs2 specifications is to use [sbt](http://scala-sbt.org). However other build tools such as Maven and Gradle can be used too (please refer to the  guide for instructions on how to set-up projects for those tools). MavenWith Maven you need to use the [Surefire](http://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html) plugin and the `test` command. You will need however to annotate your specification classes as JUnit tests (this requires the `specs2-junit` jar):import org.specs2.runner.JUnitRunnerimport org.junit.runner.RunWith@RunWith(classOf[JUnitRunner])class MySpecification extends org.specs2.Specification { def is = s2\"\"\"  Define your specification as usual here\"\"\"} GradleWith Gradle you need to use the same `RunWith` annotation and the [`test`](http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.testing.Test.html) task. You can also follow the instructions in [this blog post](http://blog.mindcrime-ilab.de/2013/10/25/gradle-rocking-scala-specs2-tests) and create a task that will leverage the specs2 . This way you will avoid having to annotate the classes.", "tags":"", "loc":"org.specs2.guide.OtherBuildTools.html"},
{"title":"Named examples", "text":" Naming examplesWhen you create acceptance specifications, you have to find names to reference your examples and this can sometimes be a bit tedious. So why not have the specification do it for you? With the `org.specs2.specification.Grouped` trait you get \"group traits\", from `g1` to `g22` to define groups of examples. Each group trait defines 22 variables named `e1` to `e22`, to define examples.Here is an example on how to use groups: class MySpecification extends Specification with specification.Grouped { def is =  s2\"\"\"  first example in first group                                        ${g1.e1}  second example in first group                                       ${g1.e2}  first example in second group                                       ${g2.e1}  second example in second group                                      ${g2.e2}  third example in second group, not yet implemented                  ${g2.e3}  \"\"\"  // group of examples with no description  new g1 {    e1 := ok    e2 := ok  }  // group of examples with a description for the group  \"second group of examples\" - new g2 {    e1 := ok    e2 := ok  }}One cool feature is that with groups you can use the example names right away with no implementation. For example if you write `this is an example ${g2.e3}`, without providing an implementation, the example will be marked as `Pending`. Grouped vs GroupsThe groups from the `Grouped` trait can hold variables which you can use in your examples. However you must be careful because those variables will be shared across all the examples of a group. You can avoid this by using the `Groups` trait like this: class MySpecification extends Specification with specification.Groups { def is =  s2\"\"\"  first example    ${g1().e1}  second example   ${g1().e2}  \"\"\"  \"first group\" - new g1 {    val list: ListBuffer[Int] = new scala.collection.mutable.ListBuffer[Int]    e1 := {      list += 1      list must haveSize(1)    }    // the second example is isolated from the first and will succeed    e2 := {      list.append(1, 2, 3)      list must haveSize(3)    }  }}", "tags":"", "loc":"org.specs2.guide.NamedExamples.html"},
{"title":"Given when then", "text":" PresentationThe Given/When/Then style structures the specification with 3 main elements: - Given steps: actions which setup the system - When steps:  command which your are currently specifying - Then steps:  expectations about the end state of the systemIn specs2 the support for Given/When/Then can be more or less complex depending on the features you wish to use: - basic support: given and when steps are just commands on a system, returning no value - intermediate support: given/when/then steps can parse part of the text to create their commands - full support: variables are not necessary to save intermediate values and the given/when/then order is enforced Basic support With an acceptance specificationGiven/When/Then specifications are easy to write using the acceptance style, you just use regular text, steps and examples:class GWTSpec extends Specification { def is = s2\"\"\" Given a first number         $g1 When I double it             $w1 Then I get twice that number $t1\"\"\"  var number = 0  def g1 = step {    // do something to provide a number    number = 1  }  def w1 = step {    // do an action    number *= number  }  // check the result  def t1 = number must_== 2} With a mutable specificationWith a mutable specification you would write:class GWTSpec extends mutable.Specification { \"Given a first number\".txt.p  step { number = 1 }  \"When I double it\".br  step { number *= number }  \"Then I get twice that number\" >> {    number must_== 2  }  var number = 0} Intermediate supportGiven/When/Then specifications are often written as blocks of text where part of the text contains values to use during the execution. For example:This is a specification for a bank transfer given an account with the amount {100} given another account with the amount {500} when we transfer {50} from the first account to the second then the first amount is {50} and the second is {550}How do you code this with an acceptance specification? With an acceptance specificationYou can implement this approach with the `org.specs2.specification.dsl.GWT` trait:class GWTSpec extends Specification with specification.dsl.GWT with StandardDelimitedStepParsers { def is = s2\"\"\" Given a first number {2}     $g1 When multiply it by {3}      $w1 Then I get {6}               $t1\"\"\"  var number = 0  def g1 = step(anInt) { i => number = i }  def w1 = step(anInt) { j => number = number * j }  def t1 = example(anInt) { n => number must_== n }}Now we need a bit of help to extract values from the text. This is provided in the form of `StepParsers`. Delimited parsersThe easiest way to extract values from a string is to delimit exactly where are the values to extract, then to provide a way to give them meaningful types. This is the role of `StepParsers`. Those parsers are using `{}` as delimiters for the values you want to extract. For example you can define an extractor for Int values like this: val anInt = StepParser((_: String).toInt)The `anInt` step parser has a method `parse(text: String)` returning: - either an exception if the parse is unsuccessful - or the desired value + the original text stripped for its delimitersYou can change the delimiters being used by overriding the implicit regular expression from the `StepParsers` trait:   // use `[]` as a delimiter  override implicit lazy val stepParserRegex = new Regex(\"\\[([\\]]+)\\]\")But you can also specify another regular expression \"locally\" for a given step parser:val anInt = StepParser((_: String).toInt)(new Regex(\"\\[([\\]]+)\\]\"))Finally `StepParsers` can collect all the delimited values at once with the `seq` method:StepParser.seq((seq: Seq[String]) => seq.map(_.toInt).sum).parse(\"values {1}, {2}, {3}\") === Right(6) Regex parsersMore generally you can use any regular expression to parse values with the `readAs` and `groupAs` methods // match the whole lineval anInt1 = readAs(\".*(\\d+).*\").and((s: String) => s.toInt)// just declare the groups you want to matchval anInt2 = groupAs(\"\\d+\").and((s: String) => s.toInt)// note: if you want to extract 2 ints, just pass a function of 2 argumentsval twoInts = groupAs(\"\\d+\").and((s1: String, s2: String) => (s1.toInt, s2.toInt)) Standard parsersA few `StepParsers` have been predefined for you in the `StandardDelimitedStepParsers` and `StandardRegexStepParsers` traits to extract `Int`s, `Double`s and `String`s: - `anInt`, `twoInts`, `threeInts` - `aDouble`, `twoDoubles`, `threeDoubles` - `aString`, `twoStrings`, `threeStrings` With a mutable specificationSeveral syntaxes are available with a mutable specification. The first syntax uses modified `step` and `example` methods to create steps and examples:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers {  \"adding numbers\".p  step(\"Given a first number {2}\")(anInt) { i =>    number = i  }  step(\"When I multiply it by {3}\")(anInt) { j =>    number = number * j  }  example(\"Then I get {6}\")(anInt) { n: Int =>    number must_== n  }  var number = 0}The second syntax is mostly the same but with postfix methods:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers {  \"adding numbers\".p  \"Given a first number {2}\".step(anInt) { i =>    number = i  }  \"When I multiply it by {3}\".step(anInt) { j =>    number = number * j  }  \"Then I get {6}\".example(anInt) { n: Int =>    number must_== n  }  var number = 0}Those two syntaxes are just specialisations of the `mutable.GivenWhenThen` trait which provides  `Given/When/Then` keywords:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers with GivenWhenThenSyntax {  \"adding numbers\".p  Given(\"a first number {2}\")(anInt) { i =>    number = i  }  When(\"I multiply it by {3}\")(anInt) { j =>    number = number * j  }  Then(\"I get {6}\")(anInt) { n: Int =>    number must_== n  }  var number = 0}This will create sentences such as:Given a first number 2When I multiply it by 3Then I get 6If you prefer to have uncapitalized `given/when/then` methods you can use the `GivenWhenAndThenSyntax` trait:class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT  with StandardDelimitedStepParsers with GivenWhenAndThenSyntax {  \"adding numbers\".p  given(\"a first number {2}\")(anInt) { i =>    number = i  }  when(\"I multiply it by {3}\")(anInt) { j =>    number = number * j  }  andThen(\"I get {6}\")(anInt) { n: Int =>    number must_== n  }  var number = 0}Which rendersgiven a first number 2when I multiply it by 3then I get 6In this case `andThen` has to be used in place of `then` because `then` is going to become a Scala keyword in future releases. Full supportThe full support fixes an issue with all the previous styles: the necessity to create mutable variables to keep track of state changes between steps and examples. It also enforces statically a proper sequencing of the Given/When/Then actions.Here, we mix-in the `org.specs2.specification.script.GWT` trait. This trait provides a class, `Scenario`, to parse the specification text and create `Steps` and `Examples`. Let's see an example:class GWTSpec extends Specification with org.specs2.specification.script.GWT with StandardRegexStepParsers { def is = s2\"\"\" A given-when-then example for a calculator                       ${calculator1.start}   Given the following number: 1   And a second number: 2   And a third number: 6   When I use this operator: +   Then I should get: 9   And it should be >: 0                                          ${calculator1.end}\"\"\"  val anOperator = readAs(\".*: (.)$\").and((s: String) => s)  val calculator1 =    Scenario(\"calculator1\").      given(anInt).      given(anInt).      given(anInt).      when(anOperator) { case op :: i :: j :: k :: _ => if (op == \"+\") i + j + k else i * j * k }.      andThen(anInt)   { case expected :: sum :: _ => sum === expected}.      andThen(anInt)   { case expected :: sum :: _ => sum must be_>(expected)}}In this example, `calculator1.start` marks the beginning of a Given/When/Then section and each line until `calculator1.end` must correspond to a `given`, `when` or `andThen` call on the scenario. * `given` uses a `StepParser` to extract values for a line of text * `when` uses a `StepParser` to extract values from the corresponding line of text and a `mapping` function to combine the result of the extraction + all the values from the given steps * `andThen` uses a `StepParser` (usually to extract expected values) and a `check` function taking `when values` and returning a `Result`More precisely, the functions passed to a `when` step must be of the form * `when(aStepParser) { case p1 :: p2 :: .. :: _ => w1 }`, where `p1` has the type extracted from `aStepParser` and `p2 .. pn` have the types of the values extracted by the previous `given` steps * `when(aStepParser).collect { case (p1, p2n: Seq[LUB]) => w1 }`, where `p1` has the type extracted from `aStepParser` and `p2n` is a `Seq[LUB]` where `LUB` is the least upper bound of the types of all the values extracted by the previous `given` steps`::` is the [Shapeless](https://github.com/milessabin/shapeless) `HCons` operator so don't forget to add the Shapeless dependency to your project if you are using the `GWT` trait!And similarly for `andThen` steps * `andThen(aStepParser) { case p1 :: p2 :: .. :: _ => r: R }`, where `p1` has the type extracted from `aStepParser` and `p2 .. pn` have the types of the values mapped by the previous `when` steps * `andThen(aStepParser).collect { case (p1, p2n: Seq[LUB]) => r: R }`, where `p1` has the type extracted from `aStepParser` and `p2n` is a `Seq[LUB]` where `LUB` is the least upper bound of the types of all the values mapped by the previous `when` stepsThe type `R` of the value `r` must be such that there is an `AsResult` type class instance in scope to transform it to a `Result`. In other words r is: a `Boolean`, a `MatchResult[_]`, a ScalaCheck `Prop`,...You will also note that the `Scenario` class restricts the order of methods which you can call. It always has to be `given* -> when* -> andThen*`. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - read about the </div>", "tags":"", "loc":"org.specs2.guide.GivenWhenThenStyle.html"},
{"title":"Get all expectations", "text":"The 2 main modes of expectations in specs2 are:  - No thrown expectations  - thrown expectationsThey correspond to different style of declaring expectations and you will use one or the other depending on how many expectations you have per example.The `org.specs2.specification.AllExpectations` trait goes further and gives you the possibility to report _all_ the failures of an Example without stopping at the first failure. This enables a type of specification where it is possible to define lots of expectations inside the body of an example and get a maximum of information on what fails and what passes: import org.specs2.specification.AllExpectationsimport org.specs2.mutable.Specificationclass AllExpectationsSpec extends Specification with AllExpectations {  \"In this example all the expectations are evaluated\" >> {    1 === 2  // this fails    1 === 3  // this also fails    1 === 1  }  \"There is no collision with this example\" >> {    10 === 11 // this fails    12 === 12    13 === 31 // this also fails  }}The second example above hints at a restriction for this kind of Specification. The failures are accumulated for each example by mutating a shared variable. \"Mutable\" means that the concurrent execution of examples will be an issue if done blindly. To avoid this, the `AllExpectations` trait overrides the `Specification` arguments to make it  (unless it is already `isolated` or `sequential`).", "tags":"", "loc":"org.specs2.guide.GetAllExpectations.html"},
{"title":"Fragments API", "text":"In specs2 a specification can simply be viewed as a sequence of \"Fragments\". A `Fragment` is something which has: - a `Description` - an `Execution`All the elements encountered in this User Guide fall under this representation: - an `Example` is a `Fragment` with a `Text` description and an `Execution` returning a `Result` - a `Step` is a `Fragment` with no description and a special `Execution` declaring that everything before the step must be executed before the `Step` is executed - a `Text` is a `Fragment` with a `Text` description and no `Execution`The role of the various DSLs in acceptance and unit specifications is to create those fragments and assemble them into a bigger `Fragments` object. They do this using: - the `FragmentFactory` API to create individual fragments - the `Fragments` API to assemble them The `FragmentFactory` APIThe `org.specs2.specification.create.FragmentFactory` trait possesses different methods to create: - texts - examples - steps / actions - tags - references - \"formatting\" fragments (break, paragraph, tab...)Please have a look at the ScalaDoc to see the exact API for the factory and look at the source code for the default implementation in `org.specs2.specification.create.DefaultFragmentFactory`. The `Fragments` APIIf you know how to create examples, texts and steps you will need to append them together as `Fragments`. You can create a `Fragments` object by using `Fragments.apply`:val ff = fragmentFactoryFragments(ff.text(\"introduction\"), ff.example(\"first example\", success), ff.break)Then you can use the methods of the `org.specs2.specification.core.Fragments` class to add more fragments or to modify existing ones: Method                                          | Description ----------------------------------------------- | ----------- `append(f: Fragment)`                           | to append a single fragment `append(fs: Fragments)`                         | to append another `Fragments` object `prepend(...)`                                  | to do the same as above but prepending instead of appending `append(fs: Seq[Fragment])`                     | to append a sequence `filter(f: Fragment => Boolean)`                | to filter out some fragments `map(f: Fragment => Fragment)`                  | to modify each fragment `mapDescription(f: Description => Description)` | to just modify the descriptions The `Fragments` DSLThe `org.specs2.specification.dsl.FragmentsDsl` trait provides a very versatile `` operator to append fragments together, so you can write:val ff = fragmentFactoryval fs = Fragments(ff.text(\"introduction\"), ff.example(\"first example\", success), ff.break)val f1 = ff.text(\"f1\")// all those combinations are possible and return a `Fragment` objectfs  f1f1  fsfs  fsf1  f1", "tags":"", "loc":"org.specs2.guide.FragmentsApi.html"},
{"title":"Execution environment", "text":"When you run a specification, a `java.util.concurrent.ExecutorService` is used to execute examples concurrently. You can access this `ExecutorService` to execute `scalaz.concurrent.Futures` and it can also be wrapped into a `scala.concurrent.ExecutionContext` to create `scala.concurrent.Futures`. Scala FutureA Scala `Future` needs an implicit `ExecutionContext` to be created. You can reuse specs2 own execution context if you want (instead of Scala's global one: `scala.concurrent.ExecutionContext.Implicits.global`): class MyFutureSpec extends Specification { def is = s2\"\"\" Let's check this scala future ${ implicit ec: ExecutionContext =>    Await.result(Future(1), Duration.Inf) must_== 1 }\"\"\"}// in a mutable specificationclass MyMutableFutureSpec extends mutable.Specification {  \"Let's check this scala future\" >> { implicit ec: ExecutionContext =>    Await.result(Future(1), Duration.Inf) must_== 1  }}You can also use specs2's execution environment directly (from now on code examples are provided for immutable specifications only but are transposable to mutable ones): class MyFutureSpec extends Specification { def is = s2\"\"\" Let's check this scala future ${ implicit ee: ExecutionEnv =>   Await.result(Future(1), Duration.Inf) must_== 1 }\"\"\"}This works thanks to an implicit conversion between `ExecutionEnv` and `ExecutionContext` provided by the `org.specs2.execute.ImplicitExecutionContextFromExecutionEnv` trait (this can be deactivated by mixing-in the `NoImplicitExecutionContextFromExecutionEnv` trait). It is actually better to use an `ExecutionEnv` anyway because it is required when you want to  (see the \"Future\" tab). Scalaz FutureA Scalaz `Future` needs an implicit `ExecutorService` to evaluate values asynchronously. You can require an `ExecutorService` in your examples like this: class MyFutureSpec extends Specification { def is = s2\"\"\" Let's check this scalaz future ${ implicit es: ExecutorService =>   scalaz.concurrent.Future(1).run must_== 1 }\"\"\"}And, similarly to the section above, you can get an implicit `ExecutorService` from an `ExecutionEnv`:class MyFutureSpec extends Specification { def is = s2\"\"\"  Let's check this scalaz future ${ implicit ee: ExecutionEnv =>    scalaz.concurrent.Future(1).run must_== 1  }\"\"\"}You will also need a `ScheduledExecutorService` if you want to evaluate a Scalaz Future using the `timed` method (from Scalaz > 7.1): class MyFutureSpec extends Specification { def is = s2\"\"\"  Let's check this scalaz future ${ implicit ee: ExecutionEnv =>    implicit val ses = ee.scheduledExecutorService    scalaz.concurrent.Future(1).timed(3.seconds).run.toOption must beSome(1)  }\"\"\"} With matchersFuture  (see the \"Future\" tab) require an implicit `ExecutionEnv`. This environment is used to access: - the `timeFactor` when awaiting for Scala Futures - a `scheduledExecutorService` and the `timeFactor when attempting Scalaz FuturesThe `terminate` matcher (see the \"Termination\" tab in the optional  section) also needs an `ExecutionEnv` to run a piece of code and periodically check if it has terminated or not: s2\"\"\"  this code must be fast enough ${ implicit ee: ExecutionEnv =>    Thread.sleep(100) must terminate(retries = 1, sleep = 60.millis)  }\"\"\" Implicit ExecutionEnvPassing an implicit `ExecutionEnv` for each example can be tedious. An `ExecutionEnv` can be injected to the specification to make it available to all examples at once: case class MyFutureSpec(implicit ee: ExecutionEnv) extends Specification { def is = s2\"\"\" Let's check this scala future ${    Future(1) must be_==(1).await  }\"\"\"  }Another possibility is to mix-in the `org.specs2.specification.ExecutionEnvironment` trait to your specification: class MyFutureSpec extends Specification with ExecutionEnvironment { def is(implicit ee: ExecutionEnv) = s2\"\"\" Let's check this scala future ${   Future(1) must be_==(1).await }\"\"\"}// in a mutable specificationclass MyMutableFutureSpec extends mutable.Specification with specification.mutable.ExecutionEnvironment { def is(implicit ee: ExecutionEnv) = {  \"Let's check this scala future\" >> {    Future(1) must be_==(1).await  }}} And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use specs2  in a Specification</div>", "tags":"", "loc":"org.specs2.guide.ExecutionEnvironments.html"},
{"title":"Environment", "text":"The execution of a Specification depends on various parts, among which: - the command line arguments - an `ExecutorService` for concurrent execution - a \"StatisticsRepository\" to access previous results - a \"Logger\" to log results to the console - an interface for the file system<p/>All of this is bundled into one object `org.specs2.specification.core.Env`. The `Env` is accessible to your Specification by either: - having it injected as a Specification member - extending a trait Dependency injectionThe following objects can be injected in your specification if you declare a 1-parameter constructor:  - the `Env` itself  - the `Arguments` object  - the `CommandLine` object  - the `ExecutionEnv` object (can be implicit)  - the `ExecutionContext` object (can be implicit)  - the `ExecutorService` object (can be implicit)<p/>For example: class MySpec(env: Env) extends Specification { def is =s2\"\"\"  Use the environment fileSystem  ${ env.fileSystem.mkdirs(\"tmp\" / \"test\").runOption; ok }\"\"\"}Or if you want to access an `ExecutionContext`:class MySpec(implicit ec: ExecutionContext) extends Specification { def is =s2\"\"\"  Use a future  ${ Await.result(Future(1), 1.seconds) must_== 1 }\"\"\"  } Environment traitsThe `Env` object can also be accessed by mixing-in the `org.specs2.specification.Environment` trait class MySpec extends Specification with Environment { def is(env: Env) =s2\"\"\"  Use the environment fileSystem  ${ env.fileSystem.mkdirs(\"tmp\" / \"test\").runOption; ok }\"\"\"}As you can see, instead of defining the `is` method you now need to defined the `is(env: Env)` method. Then you can access any attribute of the current `Env`.There are also other specialised traits giving access to specific parts of the environment Command-line argumentsWhen you just want to access the command-line arguments you can use the `org.specs2.specification.CommandLineArguments` traitclass MySpec extends Specification with CommandLineArguments { def is(args: CommandLine) = s2\"\"\"  Use the command line arguments  ${ if (args.isSet(\"pass\")) ok else ko }\"\"\"} Execution environmentWhen you just want to access the execution environment can use the `org.specs2.specification.ExecutionEnvironment` traitclass MySpec extends Specification with ExecutionEnvironment { def is(implicit ee: ExecutionEnv) = s2\"\"\"  Use the implicit execution environment  ${ Future(1) must be_==(1).await }\"\"\"  }As you can see the `ExecutionEnv` parameter is defined as an implicit parameter because this is what is required when creating futures or using .", "tags":"", "loc":"org.specs2.guide.Environment.html"},
{"title":"Create online specifications", "text":" Most of the specifications we write are known up front because this is precisely what guides the construction of our systems. But sometimes data comes first and drives what we can do with the system. For example we want to check that:  1. all the Wikipedia pages mentioning the term \"BDD\" are referencing specs2  2. if there is a specs2 link on the page, the linked page must existMore precisely we want to create one example for `1.` and if it succeeds, create as many examples as there are links in `2.`. This can be done with the `org.specs2.specification.dsl.Online` trait and the `continueWith` method: class WikipediaBddSpec extends Specification with Online { def is = s2\"\"\"  All the pages mentioning the term BDD must contain a reference to specs2 $e1\"\"\"  def e1 = {    val pages = Wikipedia.getPages(\"BDD\")    { pages must contain((_:Page) must mention(\"specs2\")) } continueWith      pagesSpec(pages)  }  def pagesSpec(pages: Seq[Page]): Fragments = {    val specs2Links = pages.flatMap(_.getLinks).filter(_.contains(\"specs2\"))    s2\"\"\"     The specs2 links must all be active     ${ Fragments.foreach(specs2Links)(isActive) }    \"\"\"  }  def isActive(link: HtmlLink) =    s2\"\"\"  The page at ${link.getName}    must be active ${ link must beActive }\"\"\"  // implement this matcher  def mention(name: String): Matcher[Page] = ???  def beActive: Matcher[HtmlLink] = ???In the specification above, if we succeed in checking each BDD page then we continue with the creation of individual examples for each encountered link.", "tags":"", "loc":"org.specs2.guide.CreateOnlineSpecifications.html"},
{"title":"Forms", "text":"Forms are a way to represent domain objects or services, and declare expected values in a tabular format. Forms can be designed as reusable pieces of specification where complex forms can be built out of simple ones.Forms are built by creating `Fields` or `Props` and placing them on rows. The following examples show, by order of complexity, the creation of:  1. fields  1. effects  1. properties  1. a simple Form using properties  1. a simple Address entity encapsulating the above form  1. a composite Customer entity using the Address instance  1. a decision table having some related columns  1. a composite Order - OrderLine entity (1-n) relationship For all the code samples below you need to extend the `org.specs2.specification.Forms` trait. FieldsA `Field` is simply a label and a value. It is used in forms to display regular information. You can create a `Field` with these methods:`field(value)` creates a field for a value, where the label is empty`field(label, value)` creates a field with a label and a value`field(label, field1, field2, ...)` creates a field with a label and values coming from other fields, concatenated as stringsWhen the form is displayed, here is how the fields are displayed:  In terms of execution, the value is only evaluated when the `Field` is executed (when executing the parent Form for example). If an exception is thrown during that evaluation, the exception message will be displayed in place of the value. EffectsAn `Effect` is almost like a `Field` but it never shows its value. The value of an `Effect` is supposed to have some kind of side-effect, like clicking on a webpage, and only the effect label will be displayed (except when there is an exception, in that case the exception message is added). You can create an `Effect` with these methods: * `effect(value)` creates an effect with no label * `effect(label, value)` creates an effect with a label and a value that will be evaluated when the `Effect` is executed * `effect(effect1, effect2, ...)` creates an effect with all the effects labels and a side-effect sequencing all side-effects PropertiesA `Prop` is like a `Field`, it has a label. But you can give it 2 values, an \"actual\" one and an \"expected\" one. When executing the property, both values are compared to get a result. You can create a `Prop` with the following functions: Expression                                                               | Description ------------------------------------------------------------------------ | -------------------------- `prop(value)`                                                            | a property with no label `prop(label, actual)`                                                    | a property with a label and an actual value `prop(label, actual, expected)`                                          | a property with a label, an actual value and an expected one `prop(label, actual, constraint)`                                        | a property with a label, an actual value and a function taking the actual value, an expected one and returning a `Result` `prop(\"label\", \"actual\", (a: String, b: String) => (a === b).toResult)`  | a property with a label, an actual value and a function taking the expected value, returning a Matcher that will be applied to the actual one `prop(\"label\", \"expected\", (expected: String) => beEqualTo(expected))`   | a property with a label, an actual value and function applying a matcher to that value `prop(label, actual, matcher)`                                           | a property with a label, an actual value and a matcher to apply to that value    If the matcher is `mute`d then no message will be displayed in case of a failure.If the expected value is not provided when building the property, it can be given with the `apply` method:// apply \"sets\" the expected valueprop1.apply(\"expected\")// orprop1(\"expected\")Let's look at a few examples: <form>    <table><tr><th colspan=\"7\">Properties</th></tr><tr><td class=\"info\" style=\"text-align:center\"><b>code</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center\"><b>is displayed as</b></td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;expected&quot;)(&quot;expected&quot;)</code></td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;expected&quot;, &quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;expected&quot;)(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;)(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td class=\"failure\">expected</td><td colspan=\"5\" class=\"failure\" onclick=\"showHide(988007917)\">'actual' is not equal to 'expected'</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, { error(&quot;but got an error&quot;); &quot;actual&quot; })(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td class=\"error\">expected</td><td colspan=\"5\" class=\"error\" onclick=\"showHide(905975052)\">java.lang.RuntimeException: but got an error</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, (a: String, b: String) =&gt; (a === b).toResult)(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, (s: String) =&gt; beEqualTo(s))(&quot;expected&quot;)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"success\">expected</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, beEqualTo(&quot;expected&quot;))</code></td><td style=\"background-color:#EEEEEE\">label</td><td class=\"failure\">actual</td><td colspan=\"5\" class=\"failure\" onclick=\"showHide(96330520)\">'actual' is not equal to 'expected'</td></tr><tr><td class=\"info\" style=\"\"><code class=\"prettyprint\">prop(&quot;label&quot;, &quot;actual&quot;, beEqualTo(&quot;expected&quot;).mute)</code></td><td style=\"background-color:#EEEEEE\">label</td><td colspan=\"5\" class=\"failure\">actual</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"988007917\">      'actual' is not equal to 'expected' (file:1)          </div><div class=\"formstacktrace details\" id=\"905975052\">      java.lang.RuntimeException: but got an error (file:1)      <div>scala.sys.package$.error(package.scala:27)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34$$anonfun$29.apply(UseForms.scala:85)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34$$anonfun$29.apply(UseForms.scala:85)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property.execute(Property.scala:51)</div><div>org.specs2.control.Property.optionalValue(Property.scala:17)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.control.Exceptions$class.trye(Exceptions.scala:86)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:132)</div><div>org.specs2.execute.ResultExecution$class.executeEither(ResultExecution.scala:80)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:120)</div><div>org.specs2.execute.ResultExecution$class.executeProperty(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:120)</div><div>org.specs2.form.Prop.actualValue$lzycompute(Prop.scala:48)</div><div>org.specs2.form.Prop.actualValue(Prop.scala:48)</div><div>org.specs2.form.Prop.execute(Prop.scala:55)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>scala.Option.orElse(Option.scala:289)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:176)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:172)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>scala.collection.immutable.List.map(List.scala:273)</div><div>scalaz.NonEmptyList.map(NonEmptyList.scala:20)</div><div>org.specs2.form.Row.executeRow(Row.scala:38)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.map(TraversableLike.scala:245)</div><div>scala.collection.AbstractTraversable.map(Traversable.scala:104)</div><div>org.specs2.form.Form.executeRows(Form.scala:73)</div><div>org.specs2.form.Form.executeForm(Form.scala:81)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34.apply(UseForms.scala:89)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$34.apply(UseForms.scala:89)</div><div>org.specs2.specification.create.S2StringContext$$anon$5.append(S2StringContext.scala:96)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:215)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:213)</div><div>scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)</div><div>scala.collection.immutable.List.foldLeft(List.scala:84)</div><div>org.specs2.specification.create.S2StringContextCreation$class.s2(S2StringContext.scala:213)</div><div>org.specs2.Specification.s2(Specification.scala:19)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$.org$specs2$specification$core$SpecStructure$$getRefs$1(SpecStructure.scala:119)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:252)</div><div>scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.getAll$1(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:134)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:124)</div><div>org.specs2.control.ActionT$$anonfun$safe$1.apply(ActionT.scala:89)</div><div>org.specs2.control.ActionT$$anonfun$reader$1$$anonfun$apply$6.apply(ActionT.scala:80)</div><div>org.specs2.control.Status$.safe(Status.scala:100)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self$lzycompute(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$ApplicativeIdV$$anonfun$point$1.apply(ApplicativeSyntax.scala:33)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.std.FunctionInstances$$anon$1$$anonfun$map$1.apply(Function.scala:56)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free.go2$1(Free.scala:119)</div><div>scalaz.Free.go(Free.scala:122)</div><div>scalaz.Free.run(Free.scala:172)</div><div>scalaz.effect.IO$class.unsafePerformIO(IO.scala:22)</div><div>scalaz.effect.IOFunctions$$anon$6.unsafePerformIO(IO.scala:227)</div><div>org.specs2.control.package$$anon$3.asResult(package.scala:85)</div><div>org.specs2.execute.AsResult$.apply(AsResult.scala:25)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution.setResult(Execution.scala:82)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:73)</div><div>scala.Option.fold(Option.scala:158)</div><div>org.specs2.specification.core.Execution.execute(Execution.scala:73)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:150)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:148)</div><div>org.specs2.specification.core.Fragment.updateExecution(Fragment.scala:49)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:148)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:147)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>scalaz.concurrent.Task$.Try(Task.scala:387)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>java.util.concurrent.FutureTask.run(FutureTask.java:266)</div><div>java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div>java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div>java.lang.Thread.run(Thread.java:745)</div>    </div><div class=\"formstacktrace details\" id=\"96330520\">      'actual' is not equal to 'expected' (file:1)          </div><div class=\"formstacktrace details\" id=\"620099259\">       (file:1)          </div></pre></form> StylesMost of the time, the display of Fields and Properties can be left as it is but sometimes you want to style the output of labels and values. You can do this by using `decorateWith` and `styleWith` methods, or some equivalent shortcuts:  All the methods above, when named `xxx` are available as `xxxLabel` and `xxxValue` to do the formatting for the label or the value only. The available colors are:  Simple formNow that we know how to create Fields and Properties, creating a `Form` is as easy as putting them on separate lines: Form(\"Address\").    tr(prop(\"street\", actualStreet(123), \"Oxford St\")).    tr(prop(\"number\", actualNumber(123), 20))The form has a title `\"Address\"` and 2 properties, each one on a distinct row. The `actualStreet()` and `actualNumber()`methods are supposed to retrieve the relevant values from a database.In some cases (see the Calculator example below) you can create a header row using the `th` method:`th(field(\"a\"), field(\"b\"))`or `th(\"a\", \"b\")` using an implicit conversion of Any => Field[Any]Inserting the form in a Specification is also very simple: class SpecificationWithForms extends Specification with Forms { def is = s2\"\"\"The address must be retrieved from the database with the proper street and number  ${Form(\"Address\").  tr(prop(\"street\", actualStreet(123), \"Oxford St\")).  tr(prop(\"number\", actualNumber(123), 20))}\"\"\"}One way to encapsulate and reuse this Form across specifications is to define a case class: case class Address(street: String, number: Int) {  def retrieve(addressId: Int) = {    val address = actualAddress(addressId)    Form(\"Address\").      tr(prop(\"street\", address.street, street)).      tr(prop(\"number\", address.number, number))  }}And then you can use it like this: class AddressSpecification extends Specification with Forms { def is = s2\"\"\"The address must be retrieved from the database with the proper street and number  ${Address(\"Oxford St\", 20).     /** expected values */      retrieve(123)               /** actual address id */}\"\"\"} Adding several rows at onceA very practical way to add rows programatically is to start from a list of values and have a function creating a Row object for each value: Form(\"a new Form\").trs(addresses) { a: Address => Row.tr(field(a.number), field(a.street)) } Nesting into another FormForms can be composed of other Forms to display composite information: val address = Form(\"Address\").  tr(field(\"street\", \"Rose Crescent\")).  tr(field(\"number\", 3))val person = Form(\"Person\").  tr(field(\"name\", \"Eric\")).  tr(address)This will be displayed with the address as a nested table inside the main one on the last row. However in some case, it's preferable to have the rows of that Form to be included directly in the outer table. This can be done by *inlining* thenesting Form: val person = Form(\"Person\").    tr(field(\"name\", \"Eric\")).    tr(address.inline)            // address is inlinedAnd the result is: Nesting into an Effect or a PropWhen using Forms in specifications we can describe different levels of abstraction. If we consider the specification of a website for example, we want to be able to use a Form having 2 rows and describing the exact actions to do on the Login page: val loginForm = Form(\"login\").  tr(effect(\"click on login\", clickOn(\"login\"))).  tr(effect(\"enter name\",     enter(\"name\", \"me\"))).  tr(effect(\"enter password\", enter(\"password\", \"pw\"))).  tr(effect(\"submit\",         submit()))However in a \"purchase\" scenario we want all the steps above to represent the login actions as just one step. One way todo this is to transform the login Form to an Effect or a Prop: Form(\"purchase\").  tr(loginForm.toEffect(\"login\")).  tr(selectForm.toEffect(\"select goods\")).  tr(checkTotalForm.toProp(\"the total must be computed ok\").bkWhiteLabel)If everything goes fine, the detailed nested form is not shown:Otherwise: * if the Form is embedded into an Effect, Errors will be reported * if the Form is embedded into a Prop, Failures will be reported, like that<form>    <table><tr><th colspan=\"4\">purchase</th></tr><tr><td colspan=\"3\" style=\"\" class=\"info\">login</td></tr><tr><td colspan=\"3\" style=\"\" class=\"info\">select goods</td></tr><tr><td style=\"background-color:#EEEEEE; background-color:#FFFFFF\">the total must be computed ok</td><td class=\"failure\"><form>    <table><tr><th colspan=\"4\">Check Total</th></tr><tr><td colspan=\"3\" style=\"\" class=\"info\">Compute total</td></tr><tr><td style=\"background-color:#EEEEEE\">Total</td><td class=\"failure\">200</td><td colspan=\"3\" class=\"failure\" onclick=\"showHide(14535533)\">'100' is not equal to '200'</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"14535533\">      '100' is not equal to '200' (file:1)          </div></pre></form></td><td colspan=\"3\" class=\"failure\" onclick=\"showHide(910366223)\">failed</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"910366223\">      failed (file:1)      <div>org.specs2.execute.Failure$.apply$default$3(Result.scala:304)</div><div>org.specs2.form.Form.executedResult$lzycompute$1(Form.scala:131)</div><div>org.specs2.form.Form.org$specs2$form$Form$$executedResult$1(Form.scala:129)</div><div>org.specs2.form.Form$$anonfun$toProp$3.apply(Form.scala:136)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property.execute(Property.scala:51)</div><div>org.specs2.control.Property.optionalValue(Property.scala:17)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.control.Exceptions$class.trye(Exceptions.scala:86)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:132)</div><div>org.specs2.execute.ResultExecution$class.executeEither(ResultExecution.scala:80)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:120)</div><div>org.specs2.execute.ResultExecution$class.executeProperty(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:120)</div><div>org.specs2.form.Prop.expectedValue$lzycompute(Prop.scala:50)</div><div>org.specs2.form.Prop.expectedValue(Prop.scala:50)</div><div>org.specs2.form.Prop$$anonfun$1.apply(Prop.scala:56)</div><div>org.specs2.form.Prop$$anonfun$1.apply(Prop.scala:55)</div><div>scala.Option.flatMap(Option.scala:171)</div><div>org.specs2.form.Prop.execute(Prop.scala:55)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>scala.Option.orElse(Option.scala:289)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:176)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:172)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>scalaz.NonEmptyList.map(NonEmptyList.scala:20)</div><div>org.specs2.form.Row.executeRow(Row.scala:38)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.map(TraversableLike.scala:245)</div><div>scala.collection.AbstractTraversable.map(Traversable.scala:104)</div><div>org.specs2.form.Form.executeRows(Form.scala:73)</div><div>org.specs2.form.Form.executeForm(Form.scala:81)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$110.apply(UseForms.scala:244)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$110.apply(UseForms.scala:244)</div><div>org.specs2.specification.create.S2StringContext$$anon$5.append(S2StringContext.scala:96)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:215)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:213)</div><div>scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)</div><div>scala.collection.immutable.List.foldLeft(List.scala:84)</div><div>org.specs2.specification.create.S2StringContextCreation$class.s2(S2StringContext.scala:213)</div><div>org.specs2.Specification.s2(Specification.scala:19)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$.org$specs2$specification$core$SpecStructure$$getRefs$1(SpecStructure.scala:119)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:252)</div><div>scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.getAll$1(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:134)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:124)</div><div>org.specs2.control.ActionT$$anonfun$safe$1.apply(ActionT.scala:89)</div><div>org.specs2.control.ActionT$$anonfun$reader$1$$anonfun$apply$6.apply(ActionT.scala:80)</div><div>org.specs2.control.Status$.safe(Status.scala:100)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self$lzycompute(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$ApplicativeIdV$$anonfun$point$1.apply(ApplicativeSyntax.scala:33)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.std.FunctionInstances$$anon$1$$anonfun$map$1.apply(Function.scala:56)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free.go2$1(Free.scala:119)</div><div>scalaz.Free.go(Free.scala:122)</div><div>scalaz.Free.run(Free.scala:172)</div><div>scalaz.effect.IO$class.unsafePerformIO(IO.scala:22)</div><div>scalaz.effect.IOFunctions$$anon$6.unsafePerformIO(IO.scala:227)</div><div>org.specs2.control.package$$anon$3.asResult(package.scala:85)</div><div>org.specs2.execute.AsResult$.apply(AsResult.scala:25)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution.setResult(Execution.scala:82)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:73)</div><div>scala.Option.fold(Option.scala:158)</div><div>org.specs2.specification.core.Execution.execute(Execution.scala:73)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:150)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:148)</div><div>org.specs2.specification.core.Fragment.updateExecution(Fragment.scala:49)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:148)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:147)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>scalaz.concurrent.Task$.Try(Task.scala:387)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>java.util.concurrent.FutureTask.run(FutureTask.java:266)</div><div>java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div>java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div>java.lang.Thread.run(Thread.java:745)</div>    </div></pre></form> Using tabsIf there are too many fields to be displayed on a Form you can use tabs: s2\"\"\"A person can have 2 addresses ${  Form(\"Addresses\").tr {    tab(\"home\",      Address(\"Oxford St\", 12).        fill(\"Oxford St\", 12)).      tab(\"work\",        Address(\"Rose Cr.\", 3).          fill(\"Rose Cr.\", 3))  }}\"\"\"The first `tab` call will create a `Tabs` object containing the a first tab with \"home\" as the title and an Address form as its content. Then every subsequent `tab` calls on the `Tabs` object will create new tabs:Tabs can also be created from a seq of values. Let's pretend we have a list of `Address` objects with a name and a Form displaying the `Address` values. You can write: Form(\"Addresses\").tabs(addresses) { address: Address => tab(address.street, address.form) } Aggregating formsNow that we've defined a form for a simple entity, let's see how we can reuse it with a larger entity: * the Customer form defines a name attribute and embeds an instance of the Address form * it is defined by setting the name on one row and the Address form on the second row*[and for this example, we define a slightly different Address form]* case class Address(street: String, number: Int) {  def actualIs(address: Address) = {    Form(\"Address\").      tr(prop(\"street\", address.street, street)).      tr(prop(\"number\", address.number, number))  }}case class Customer(name: String, address: Address) {  def retrieve(customerId: Int) = {    val customer = actualCustomer(customerId)    Form(\"Customer\").      tr(prop(\"name\", customer.name)(name)).      tr(address.actualIs(customer.address))  }  def actualCustomer(customerId: Int): Customer = this // fetch from the database}class CustomerSpecification extends Specification with Forms { def is = s2\"\"\"The customer must be retrieved from the database with a proper name and address ${  Customer(name = \"Eric\",    address = Address(street = \"Rose Crescent\", number = 2)).    retrieve(123)  }\"\"\"}As you also see above, named arguments can bring more readability to the expected values. Lazy cellsFields, Props and Forms are added right away to a row when building a Form with the `tr` method. If it is necessary to add them with a \"call-by-name\" behavior, the `lazify` method can be used: def address = Address() // build an Addressdef customer = Customer()Form(\"Customer\").  tr(prop(\"name\", customer.name)(\"name\")).  // the address Form will be built only when the Customer Form is rendered  tr(lazify(address.actualIs(customer.address))) Xml cellsAny xml can be \"injected\" on a row by using an `XmlCell`: Form(\"Customer\").  tr(prop(\"name\", Customer().name)(\"name\")).  tr(XmlCell(<div><b>this is a bold statement</b></div>)) 1-n relationshipsWhen there are 1 - n relationships between entities the situation gets bit more complex.For example you can have an \"Order\" entity, which has several \"OrderLines\". In that case there are several things that we might want to specify: * the expected rows are included in the actual rows, with no specific order (this is the usual case) * the expected rows are included in the actual rows, in the same order * the expected rows are exactly the actual rows, with no specific order * the expected rows are exactly the actual rows, in the same orderLet's see how to declare this. The 2 classes we're going to use are:import Form._case class Order(orderId: Int) {  lazy val actualLines = // those should be extracted from the actual order entity retrieved by id    OrderLine(\"PIS\", 1) ::      OrderLine(\"PS\", 2) ::      OrderLine(\"BS\", 3) ::      OrderLine(\"SIS\", 4) ::      Nil  def base = Forms.form(\"Order\").th(\"name\", \"qty\")  def hasSubset(ls: OrderLine*)      = base.subset(actualLines, ls)  def hasSubsequence(ls: OrderLine*) = base.subsequence(actualLines, ls)  def hasSet(ls: OrderLine*)         = base.set(actualLines, ls)  def hasSequence(ls: OrderLine*)    = base.sequence(actualLines, ls)}case class OrderLine(name: String, quantity: Int) {  def form = tr(field(name), field(quantity))}The `OrderLine` class simply creates a form with 2 fields: name and quantity. The `Order` class is able to retrieve the actual order entity (say, from a database) and to extract `OrderLine` instances. It also has several methods to build Forms depending on the kind of comparison that we want to do. Subset`Form.subset` uses the `FormDiffs.subset(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are left untouched * lines existing in `a` and `b` are marked as success * lines existing in `b` and not `a` are marked as failures Order(123).hasSubset(  OrderLine(\"BS\", 3),  OrderLine(\"PIS\", 1),  OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"success\" style=\"\">PIS</td><td colspan=\"5\" class=\"success\" style=\"\">1</td></tr><tr><td class=\"info\" style=\"\">PS</td><td colspan=\"5\" class=\"info\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"info\" style=\"\">SIS</td><td colspan=\"5\" class=\"info\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Subsequence`Form.subsequence` uses the `FormDiffs.subsequence(a, b)` method to calculate the differences and add them to the Form: * lines existing in `a` but not `b` are left untouched * lines existing in `a` and `b` in the same order are marked as success * lines existing in `b` and not `a` are marked as failures * lines existing in `b` and `a` but out of order are marked as failures Order(123).hasSubsequence(  OrderLine(\"PS\", 2),  OrderLine(\"BS\", 3),  OrderLine(\"PIS\", 1),  OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"failure\" style=\"\">PIS</td><td colspan=\"5\" class=\"failure\" style=\"\">1</td></tr><tr><td class=\"success\" style=\"\">PS</td><td colspan=\"5\" class=\"success\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"info\" style=\"\">SIS</td><td colspan=\"5\" class=\"info\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Set`Form.set` uses the `FormDiffs.set(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are marked as failures * lines existing in `a` and `b` are marked as success * lines existing in `b` and not `a` are marked as failures Order(123).hasSet(  OrderLine(\"BS\", 3),  OrderLine(\"PIS\", 1),  OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"success\" style=\"\">PIS</td><td colspan=\"5\" class=\"success\" style=\"\">1</td></tr><tr><td class=\"failure\" style=\"\">PS</td><td colspan=\"5\" class=\"failure\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"failure\" style=\"\">SIS</td><td colspan=\"5\" class=\"failure\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Sequence`Form.sequence` uses the `FormDiffs.sequence(a, b)` method to calculate the differences between the lines of `a` and `b`: * lines existing in `a` but not `b` are marked as failures * lines existing in `a` and `b` in the right order are marked as success * lines existing in `b` and not `a` are marked as failures Order(123).hasSequence(    OrderLine(\"PS\", 2),    OrderLine(\"BS\", 3),    OrderLine(\"PIS\", 1),    OrderLine(\"TDGL\", 5))This form returns:<form>    <table><tr><th colspan=\"7\">Order</th></tr><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>name</b></td><td colspan=\"5\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>qty</b></td></tr><tr><td class=\"failure\" style=\"\">PIS</td><td colspan=\"5\" class=\"failure\" style=\"\">1</td></tr><tr><td class=\"success\" style=\"\">PS</td><td colspan=\"5\" class=\"success\" style=\"\">2</td></tr><tr><td class=\"success\" style=\"\">BS</td><td colspan=\"5\" class=\"success\" style=\"\">3</td></tr><tr><td class=\"failure\" style=\"\">SIS</td><td colspan=\"5\" class=\"failure\" style=\"\">4</td></tr><tr><td class=\"failure\" style=\"\">TDGL</td><td colspan=\"5\" class=\"failure\" style=\"\">5</td></tr></table></form> Decision tablesOne very popular type of Forms are *decision tables*. A decision table is a Form where, on each row, several values are used for a computation and the result must be equal to other values on the same row. A very simple example of this is a calculator: case class Calculator(form: Form = Form()) {  def tr(a: Int, b: Int, a_plus_b: Int, a_minus_b: Int) = Calculator {    def plus = prop(a + b)(a_plus_b)    def minus = prop(a - b)(a_minus_b)    form.tr(a, b, plus, minus)  }}def th(title1: String, titles: String*) = Calculator(Form.th(title1, titles:_*))The `Calculator` object defines a `th` method to create the first `Calculator` Form, with the proper title. The `th` method: * takes the column titles (there must be at least one title) * creates a header row on the form * returns a new Calculator containing this form (note that everything is immutable here)The `Calculator` case class embeds a Form and defines a `tr` method which * takes actual and expected values * creates properties for the computations * creates a form with a new row containing those fields and properties * returns a new Calculator containing this formAnd you use the `Calculator` Form like this: class CalculatorSpecification extends Specification with Forms { def is  = s2\"\"\" A calculator must add and subtract Ints ${   Calculator.     th(\"a\", \"b\", \"a + b\", \"a - b\").     tr(1,   2,   3,       -1     ).     tr(2,   2,   4,       0      ) }\"\"\"}Here is the output:And if something goes wrong:<form>    <table><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>b</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a + b</b></td><td colspan=\"9\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a - b</b></td></tr><tr><td class=\"info\" style=\"\">1</td><td class=\"info\" style=\"\">2</td><td class=\"success\">3</td><td colspan=\"9\" class=\"success\">-1</td></tr><tr><td class=\"info\" style=\"\">2</td><td class=\"info\" style=\"\">2</td><td class=\"success\">4</td><td class=\"failure\">2</td><td colspan=\"9\" class=\"failure\" onclick=\"showHide(1552717564)\">'0' is not equal to '2'</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"1552717564\">      '0' is not equal to '2' (file:1)          </div></pre></form>And when it goes *very* wrong (like throwing an `error(\"very wrong\")`), there will be red cells and stacktraces:<form>    <table><tr><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>b</b></td><td class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a + b</b></td><td colspan=\"9\" class=\"info\" style=\"text-align:center; background-color:#EEEEEE\"><b>a - b</b></td></tr><tr><td class=\"info\" style=\"\">1</td><td class=\"info\" style=\"\">2</td><td class=\"success\">3</td><td colspan=\"9\" class=\"success\">-1</td></tr><tr><td class=\"info\" style=\"\">2</td><td class=\"info\" style=\"\">2</td><td class=\"success\">4</td><td class=\"error\">2</td><td colspan=\"9\" class=\"error\" onclick=\"showHide(1472721912)\">java.lang.RuntimeException: very wrong</td></tr></table><pre><i>[click on failed cells to see the stacktraces]</i><div class=\"formstacktrace details\" id=\"1472721912\">      java.lang.RuntimeException: very wrong (file:1)      <div>scala.sys.package$.error(package.scala:27)</div><div>org.specs2.guide.UseForms$WrongCalculator$$anonfun$minus$3$3.apply$mcI$sp(UseForms.scala:574)</div><div>org.specs2.guide.UseForms$WrongCalculator$$anonfun$minus$3$3.apply(UseForms.scala:574)</div><div>org.specs2.guide.UseForms$WrongCalculator$$anonfun$minus$3$3.apply(UseForms.scala:574)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property$$anonfun$apply$2.apply(Property.scala:67)</div><div>org.specs2.control.Property.execute(Property.scala:51)</div><div>org.specs2.control.Property.optionalValue(Property.scala:17)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$$anonfun$2.apply(ResultExecution.scala:109)</div><div>org.specs2.control.Exceptions$class.trye(Exceptions.scala:86)</div><div>org.specs2.control.Exceptions$.trye(Exceptions.scala:132)</div><div>org.specs2.execute.ResultExecution$class.executeEither(ResultExecution.scala:80)</div><div>org.specs2.execute.ResultExecution$.executeEither(ResultExecution.scala:120)</div><div>org.specs2.execute.ResultExecution$class.executeProperty(ResultExecution.scala:109)</div><div>org.specs2.execute.ResultExecution$.executeProperty(ResultExecution.scala:120)</div><div>org.specs2.form.Prop.actualValue$lzycompute(Prop.scala:48)</div><div>org.specs2.form.Prop.actualValue(Prop.scala:48)</div><div>org.specs2.form.Prop.execute(Prop.scala:55)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>org.specs2.form.PropCell$$anonfun$executeCell$3.apply(Cells.scala:176)</div><div>scala.Option.orElse(Option.scala:289)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:176)</div><div>org.specs2.form.PropCell.executeCell(Cells.scala:172)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>org.specs2.form.Row$$anonfun$executeRow$1.apply(Row.scala:38)</div><div>scala.collection.immutable.List.map(List.scala:277)</div><div>scalaz.NonEmptyList.map(NonEmptyList.scala:20)</div><div>org.specs2.form.Row.executeRow(Row.scala:38)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>org.specs2.form.Form$$anonfun$executeRows$1.apply(Form.scala:73)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.map(TraversableLike.scala:245)</div><div>scala.collection.AbstractTraversable.map(Traversable.scala:104)</div><div>org.specs2.form.Form.executeRows(Form.scala:73)</div><div>org.specs2.form.Form.executeForm(Form.scala:81)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$139.apply(UseForms.scala:527)</div><div>org.specs2.guide.UseForms$$anonfun$is$1$$anonfun$apply$139.apply(UseForms.scala:527)</div><div>org.specs2.specification.create.S2StringContext$$anon$5.append(S2StringContext.scala:96)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:215)</div><div>org.specs2.specification.create.S2StringContextCreation$$anonfun$13.apply(S2StringContext.scala:213)</div><div>scala.collection.LinearSeqOptimized$class.foldLeft(LinearSeqOptimized.scala:124)</div><div>scala.collection.immutable.List.foldLeft(List.scala:84)</div><div>org.specs2.specification.create.S2StringContextCreation$class.s2(S2StringContext.scala:213)</div><div>org.specs2.Specification.s2(Specification.scala:19)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.guide.UseForms$$anonfun$is$1.apply(UseForms.scala:9)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$1.apply(SpecStructure.scala:28)</div><div>org.specs2.specification.core.SpecStructure.fragments$lzycompute(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure.fragments(SpecStructure.scala:25)</div><div>org.specs2.specification.core.SpecStructure$.linkedSpecStructuresRefs(SpecStructure.scala:144)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$linkedSpecifications$1.apply(SpecStructure.scala:102)</div><div>org.specs2.specification.core.SpecStructure$.org$specs2$specification$core$SpecStructure$$getRefs$1(SpecStructure.scala:119)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1$$anonfun$7.apply(SpecStructure.scala:128)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.scala:252)</div><div>scala.collection.Iterator$class.foreach(Iterator.scala:742)</div><div>scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</div><div>scala.collection.IterableLike$class.foreach(IterableLike.scala:72)</div><div>scala.collection.AbstractIterable.foreach(Iterable.scala:54)</div><div>scala.collection.TraversableLike$class.flatMap(TraversableLike.scala:252)</div><div>scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.getAll$1(SpecStructure.scala:128)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:134)</div><div>org.specs2.specification.core.SpecStructure$$anonfun$specStructuresRefs$1.apply(SpecStructure.scala:124)</div><div>org.specs2.control.ActionT$$anonfun$safe$1.apply(ActionT.scala:89)</div><div>org.specs2.control.ActionT$$anonfun$reader$1$$anonfun$apply$6.apply(ActionT.scala:80)</div><div>org.specs2.control.Status$.safe(Status.scala:100)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>org.specs2.control.StatusT$$anonfun$safe$1.apply(StatusT.scala:62)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self$lzycompute(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$$anon$1.self(ApplicativeSyntax.scala:29)</div><div>scalaz.syntax.ToApplicativeOps$ApplicativeIdV$$anonfun$point$1.apply(ApplicativeSyntax.scala:33)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.WriterTApplicative$$anonfun$point$1.apply(WriterT.scala:282)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.effect.IO$$anonfun$apply$19$$anonfun$apply$20.apply(IO.scala:136)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.FreeFunctions$$anonfun$return_$1.apply(Free.scala:326)</div><div>scalaz.std.FunctionInstances$$anon$1$$anonfun$map$1.apply(Function.scala:56)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free$$anonfun$run$1.apply(Free.scala:172)</div><div>scalaz.Free.go2$1(Free.scala:119)</div><div>scalaz.Free.go(Free.scala:122)</div><div>scalaz.Free.run(Free.scala:172)</div><div>scalaz.effect.IO$class.unsafePerformIO(IO.scala:22)</div><div>scalaz.effect.IOFunctions$$anon$6.unsafePerformIO(IO.scala:227)</div><div>org.specs2.control.package$$anon$3.asResult(package.scala:85)</div><div>org.specs2.execute.AsResult$.apply(AsResult.scala:25)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$withEnv$1.apply(Execution.scala:133)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2$$anonfun$apply$4.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution.setResult(Execution.scala:82)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:74)</div><div>org.specs2.specification.core.Execution$$anonfun$execute$2.apply(Execution.scala:73)</div><div>scala.Option.fold(Option.scala:158)</div><div>org.specs2.specification.core.Execution.execute(Execution.scala:73)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:150)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1$$anonfun$apply$16.apply(Executor.scala:148)</div><div>org.specs2.specification.core.Fragment.updateExecution(Fragment.scala:49)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:148)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$executeFragment$1.apply(Executor.scala:147)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>org.specs2.specification.process.DefaultExecutor$$anonfun$sequencedExecution$1$$anonfun$9.apply(Executor.scala:135)</div><div>scalaz.concurrent.Task$.Try(Task.scala:387)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>org.specs2.data.Processes$$anonfun$start$1.apply(Processes.scala:115)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>scalaz.concurrent.Future$$anonfun$apply$15$$anon$4.call(Future.scala:380)</div><div>java.util.concurrent.FutureTask.run(FutureTask.java:266)</div><div>java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div>java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div>java.lang.Thread.run(Thread.java:745)</div>    </div></pre></form>Note that the Calculator class is not, in itself an Example. But there is an implicit definition automatically transforming `Any { def form: Form }` to `Example` so that an explicit call to `.form` is not necessary in order to include the Form in the specification.", "tags":"", "loc":"org.specs2.guide.UseForms.html"},
{"title":"Dependency matchers", "text":"It is highly desirable to have acyclic dependencies between the packages of a project. This often leads to describing the packages structure as \"layered\": each package on a layer can only depend on a package on a lower layer. specs2 helps you enforce this design property with specific matchers. Layers definitionFirst you need to define the packages and their expected dependencies. Mix-in the `org.specs2.specification.Analysis` trait and define layers (taking specs2 as an example): layers (  \"runner\",  \"reporter\",  \"specification mutable\",  \"mock      form\",  \"matcher\",  \"execute\",  \"reflect    xml  time html\",  \"collection control io text main data\").withPrefix(\"org.specs2\")The above expression defines layers as an ordered list of `String`s containing space-separated package names. It is supplemented by a `withPrefix` declaration to factor out the common package prefix between all these packages.By default, the packages are supposed to correspond to directories in the `src/target/scala-<version>/classes` directory. If your project has a different layout you can declare another target directory: layers(\"...\").inTargetDir(\"out\" / \"classes\") Inclusion/ExclusionEvery rule has exceptions :-). In some rare cases, it might be desirable to exclude a class from being checked on a given layer. To do this, you can use the `include/exclude` methods on the `Layer` class: layers (  \"runner\",  \"reporter\",  \"specification mutable\".exclude(\"mutable.SpecificationWithJUnit\"),  \"mock      form\",  \"matcher\",  \"execute\",  \"reflect  xml  time html\",  \"collection control io text main data\").withPrefix(\"org.specs2\")The `include/exclude` methods accept a list of regular expressions to:- exclude fully qualified class names (generally, only `exclude` will be necessary)- re-include fully qualified class names if the exclusion list is to big VerificationNow you've defined layers, you can use the `beRespected` matcher to check if all the dependencies are verified: val design = layers(\"...\")design must beRespectedIf some dependencies are not respected:[error] those dependencies are not satisfied:[error] org.specs2.main x-> org.specs2.io because org.specs2.io.FileSystem -> org.specs2.main.Arguments[error] org.specs2.main x-> org.specs2.io because org.specs2.io.FileSystem -> org.specs2.main.ArgumentsArgs Layers as an ExampleThe `org.specs2.specification.Analysis` trait allows to directly embed the layers definition in a `Specification` and turn it into an `Example`: class DependenciesSpec extends Specification with specification.Analysis { def is =  \"this is the application design\"     layers(      \"gui commandline\",      \"controller\",      \"backend\"    )}", "tags":"", "loc":"org.specs2.guide.matchers.DependencyMatchers.html"},
{"title":"Datatables", "text":"DataTables are used to pack several expectations inside one example using a tabular format: class DataTableSpec extends Specification with org.specs2.specification.Tables { def is = s2\"\"\" adding integers should just work in scala ${// the header of the table, with `|` separated strings (`>` executes the table)\"a\" | \"b\" | \"c\" |>2   !  2  !  4  |                   // an example row1   !  1  !  2  |                   // another example row  { (a, b, c) => a + b must_== c }  // the expectation to check on each row}\"\"\"}A `DataTable` which is used as a `Result` in the body of an Example will only be displayed when failing. If you also want to display the table when successful, to document your examples, you can omit the example description and inline the DataTable directly in the specification:class DataTableSpec extends Specification with Tables { def is = s2\"\"\" adding integers should just work in scala  ${     \"a\"   | \"b\" | \"c\" |>      2    !  2  !  4  |      1    !  1  !  2  |      { (a, b, c) => a + b must_== c }   }\"\"\"  }This specification will be rendered as:adding integers should just work in scala+  a | b | c |   2 | 2 | 4 |   1 | 1 | 2 | Implicit `!`The datatable DSL uses the `!` operator to define columns. However this operator is also used by the examples DSL to create the body of an example: `\"my example is\" ! ok`, so if the first column of the datatable contains strings you will not be able to use both at the same time to mean different things (\"create a table header\" and \"create an example\").You can solve this conflict by either: - using the `org.specs2.specification.Tables` and `org.specs2.mutable.Tables` traits which will deactivate the example DSL on acceptance and mutable specifications - using the `org.specs2.matcher.DataTables` trait and use `!!` instead of `!` if the first column is a string (for good visual balance you can use `||` in the header) Concurrent executionBy default the execution of a datatable is sequential, one row after another. This might not be very practical if you have long-running computations on each row.If this is the case you can use the `|*` operator (instead of just `|`) to define your execution function:\"a\"   | \"b\" | \"c\" |>   2    !  2  !  4  |   1    !  1  !  2  |* { (a, b, c) => a + b must_== c }This returns a function `ExecutorService => Result` which can be used directly as the body of an example. You can also pass it your own thread pool by creating, for example, `java.util.concurrent.Executors.newFixedThreadPool(4)`.More generally, you can use the \"Applicative\" operator `|@` to pass anything having a `scalaz.Applicative` instance, like a `scala.concurrent.Future`:// this table uses the global execution context implicitly to create futures  // scala.concurrent.ExecutionContext.Implicits.global  def result: scala.concurrent.Future[DecoratedResult[DataTable]] =    \"a\" | \"b\" | \"c\" |>     2  !  2  ! 4   |     1  !  1  ! 2   |@ { (a, b, c) => Future(a + b must_== c) }  // then you need to get an implicit execution environment and  // await on the Future result  implicit def ee: ExecutionEnv = ???  result.await", "tags":"", "loc":"org.specs2.guide.UseDatatables.html"},
{"title":"Case class matchers", "text":"There is a special support for matching case classes, using a matcher macro. To use it you need to add the `specs2-matcher-extra` jar to your project and add the `org.specs2.matcher.MatcherMacros` trait to your specification.Then, with the `matchA` matcher you can check the values of case class attributes:// case class for a Catcase class Cat(name: String = \"\", age: Int = 0, kitten: Seq[Cat] = Seq())// a given catval cat = Cat(name = \"Kitty\", age = 6, kitten = Seq(Cat(\"Oreo\", 1), Cat(\"Ella\", 2)))// this cat must be a Catcat must matchA[Cat]// check the value of \"name\"cat must matchA[Cat].name(\"Kitty\")// check the value of \"age\" using a matcherdef is[A](a: A) = be_==(a)cat must matchA[Cat].age(is(6))// check the value of \"kitten\" using a function returning a Resultcat must matchA[Cat].kitten((_:Seq[Cat]) must haveSize(2))// matchers can be chainedcat must matchA[Cat]  .name(\"Kitty\")  .age(is(6))  .kitten((_:Seq[Cat]) must haveSize(2)) And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - learn about all available </div>", "tags":"", "loc":"org.specs2.guide.matchers.CaseClassMatchers.html"},
{"title":"Auto-numbered examples", "text":"In the  section we can see that there is a way to create groups of examples with standard names and use these names in the specification text (via the `s2` interpolated string). Here we go a step further.The specification text is going to be some pure text, the examples will be described as example groups and the numbers will be created automatically. What does it look like? class BulletedExamplesSpec extends script.Specification with Groups { def is = \"\"\"  This is an introduction  First section  =============  A bit more text there.   + and the first example   + and the second example  Second section  =============  Then another section   + and the third example   + and the fourth example\"\"\"  \"first section\" - new group {    eg := 1 must_== 1    eg := 1 must_== 1  }  \"second section\" - new group {    eg := 1 must_== 1  }}This style of specification uses the `org.specs2.specification.script.Specification` class and mixes-in the `Groups` trait to create example groups. You can notice that: - Nothing is interpolated in the text that defines the `is` method - groups are anonymous, just called `group` - examples are anonymous, just called `eg` ([_exampli gratia_](http://en.wikipedia.org/wiki/List_of_Latin_phrases_(E)#exempli_gratia) in latin, meaning \"for example\")At runtime, the text gets parsed and: - each Markdown header (underlined with `=====` or starting with `#`, ``, ``,... as per the markdown convention) marks the creation of a new example group - each text starting with `+` marks the creation of an example - groups and examples in the text are coupled with their counterpart in the code - if groups or examples are missing in the code, they are still created in the final specification but marked as `pending` - each group is enclosed in a `section` with the group name (automatically numbered, starting from `g1`) - each example is tagged with its group name, and its number (automatically numbered, starting from `e1`)So, in the specification above the fourth example will be marked as `pending (g2.e2)` where `g2` is the group name and `e2` is the example name. As you can guess, sections and tags make it easy to just re-run parts of the specification without having to create those sections and tags yourself.The major issue with this style of specification is that you cannot use your IDE to navigate from a piece of text to the corresponding code. You have to count the groups and count the number of examples to find the right one.", "tags":"", "loc":"org.specs2.guide.AutoNumberedExamples.html"},
{"title":"Auto-examples", "text":"When you want to specify an API, most of your examples are self-describing:class SeqSpecification extends mutable.Specification {  \"updateLast modifies the last element of a Seq\".p   \"when the collection has 1 element\"  >> { Seq(1).updateLast(_ + 1)     must_== Seq(2) }   \"when the collection has 2 elements\" >> { Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3) }   \"when the collection is empty\"       >> { Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() }}It is a bit redundant to provide a textual description for these 3 examples because the code is pretty clear and simple. In this situation you can use the `eg` operator to create an example where the description will be the code itself:class SeqSpecification extends mutable.Specification {  \"updateLast modifies the last element of a Seq\".p  eg { Seq(1).updateLast(_ + 1)     must_== Seq(2)     }  eg { Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3)  }  eg { Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() }}This prints:[info] updateLast modifies the last element of a Seq[info]  Seq(1).updateLast(_ + 1)     must_== Seq(2)[info]  Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3)[info]  Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() In an acceptance specificationAcceptance specifications are using interpolated strings so you can directly write:class SeqSpecification extends Specification { def is = s2\"\"\"  updateLast modifies the last element of a Seq  ${ Seq(1).updateLast(_ + 1)     must_== Seq(2)     }  ${ Seq(1, 2).updateLast(_ + 1)  must_== Seq(1, 3)  }  ${ Seq[Int]().updateLast(_ + 1) must_== Seq[Int]() }\"\"\"}There is a huge gotcha though! Each of these expressions needs an implicit conversion to be included in the interpolated spec. And in Scala, if you have a block of code returning a value of type `T`, ***only the last expression of the block is converted***. This means that if there is a statement in the block that throws an exception, this exception won't be caught and the whole specification will fail to be instantiated! So if you want to use blocks as auto-examples you should better wrap them with an `eg` call:class SeqSpecification extends Specification { def is = s2\"\"\"  This is a problematic specification  ${ sys.error(\"ouch, this one is going to blow up the spec\"); Seq(1).updateLast(_ + 1) must_== Seq(2) }  ${ eg { sys.error(\"it's ok, this one is well protected\");    Seq(1).updateLast(_ + 1) must_== Seq(2) } }\"\"\"}", "tags":"", "loc":"org.specs2.guide.AutoExamples.html"},
{"title":"Arguments reference", "text":"Arguments can be passed on the command line, or declared inside a specification, using the `args(name=value)` syntax:class MySpec extends Specification { def is = args(xonly=true)  s2\"\"\"  Clever spec title  And some intro text  brilliant expectation $success                                   \"\"\"}They can also be passed as system properties: `-Dspecs2.name=value` (`-Dname=value` also works but you might have collisions with other properties).Note that boolean properties like `color` can be defined in several ways: - not defined => the default value, `true`, is used - `color`     => use colors - `color true` => use colors - `color false` => don't use colors (`nocolor` is an alias) - `-Dspecs2.color`     => use colors - `-Dspecs2.color=true` => use colors - `-Dspecs2.color=false` => don't use colors (`-Dspecs2.nocolor` is an alias)This reference guide for arguments is divided in several sections: - \"path\" arguments defining where specs2 should read or write files - \"selection\" arguments to select the examples to run - \"execution\" arguments for execution parameters - \"storing\" arguments to store statistics - \"reporting\" arguments to control the output - API for arguments when used in the code Paths Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------------------------------------------------------------------- `stats.outdir`          | `target/specs2-reports/stats`  | output directory for run statistics (see ) `junit.outdir`          | `target/test-reports/`         | output directory for JUnit XML files (see ) `filesrunner.basepath`  | `src/test/scala`               | source directory for test files (see ) `filesrunner.path`      | `**/*.scala`                   | glob pattern for the file paths (see ) `filesrunner.pattern`   | `.*Spec`                       | regular expression for the specification class/object name (see ) `html.outdir`           | `target/specs2-reports`        | output directory for html files (see ) Selection Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------------------------------------------------------------------- `ex`                    | `.*`                           | regular expression specifying the examples to execute. Use `ex .*brilliant.*` on the command line `include`               | `\"\"`                           | execute only the fragments tagged with any of the comma-separated list of tags: `t1,t2,...` `exclude`               | `\"\"`                           | do not execute the fragments tagged with any of the comma-separated list of tags: `t1,t2,...` `was`                   | `\"\"`                           | select only some previously executed examples based on their status `selector`              | `\"\"`                           | implementation of the `org.specs2.specification.process.Selector` trait Execution Name                    | Default value                            | Description ----------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------- `plan`                  | `false`                                  | only report the text of the specification without executing anything `skipAll`               | `false`                                  | skip all the examples `stopOnFail`            | `false`                                  | skip all examples after the first failure or error `stopOnSkip`            | `false`                                  | skip all examples after the first skipped result `sequential`            | `false`                                  | don't execute examples concurrently `asap`                  | `false`                                  | execute all the examples before reporting them `isolated`              | `false`                                  | execute each example in its own specification to get \"fresh\" local variables `threadsNb`             | `Runtime.getRuntime.availableProcessors` | number of threads to use for concurrent execution `scheduledThreadsNb`    | `1`                                      | number of threads to use for timed out execution on Scalaz Futures `timeFactor`            | `1`                                      | multiply all durations by this factor when waiting for futures `executor`              | `\"\"`                                     | implementation of the `org.specs2.specification.process.Executor` trait Storing Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------ `neverstore`            | `false`                        | never store statistics if true `resetstore`            | `false`                        | delete previous store statistics if true ReportingSee the  page for a more precise description of these options. Name                    | Default value                  | Description ----------------------- | ------------------------------ | ------------------------------ `all`                   | `false`                        | execute and report linked specifications `xonly`                 | `false`                        | only report failures and errors `showonly`              | `\"\"`                           | only report some examples based on their status `failtrace`             | `false`                        | show a stack trace for failures `fullstacktrace`        | `false`                        | show a full stack trace `tracefilter`           | `\"\"`                           | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`            | `\"\"`                           | define the parameters for the `SmartDiffs` instance for differences `diffsclass`            | `\"\"`                           | use a specific instance of the `Diffs` trait `color`                 | `true`                         | use colors `colors`                | `\"\"`                           | use different colors `colorsclass`           | `\"\"`                           | use a specific instance of the `Colors` trait `showtimes`             | `false`                        | show execution times for examples `notifier`              | `\"\"`                           | name of a class extending the `org.specs2.reporter.Notifier` trait `printer`               | `\"\"`                           | name of a class extending the `org.specs2.reporter.Printer` trait `reporter`              | `\"\"`                           | name of a class extending the `org.specs2.reporter.Reporter` traitFor  the following options can be used: Name                    | Default value                                 | Description ----------------------- | --------------------------------------------- | ------------------------------ `all`                   | `false`                                       | execute and report linked specifications `html.outdir`           | `target/specs2-reports/`                      | output directory for the html files `html.template`         | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`        | `Map[String, String]()`                       | passed to the template during the Pandoc evaluation `html.nostats`          | `false`                                       | if true no stats are displayed `html.search`           | `true`                                        | add a search box to the generated files `html.toc`              | `true`                                        | add a table of contents to the generated files `html.toc.entrymaxsize` | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs` | `true`                                        | report \"see\" references which do not correspond to any generated file Arguments APIFrom inside a specification, the `args` method provides the most frequent arguments as `args(argumentName = argumentValue)`. In the least frequent cases you will have to write:// for selection argumentsargs.select(ex = \"example \\d*\")// for reporting argumentsargs.execute(threadsNb = 4)// for storing argumentsargs.store(reset = true)// for reporting argumentsargs.report(xonly = true)There are also a few shortcuts: Name                                                                  | Equivalent --------------------------------------------------------------------- | ----------------------- `include(tags: String)`                                               | `args(include=tags)` `exclude(tags: String)`                                               | `args(exclude=tags)` `only(examples: String)`                                              | `args(ex=examples)` `was(status: String)`                                                 | `args(was=status)` `plan`                                                                | `args(plan=true)` `skipAll`                                                             | `args(skipAll=true)` `stopOnFail`                                                          | `args(stopOnFail=true)` `stopOnSkip`                                                          | `args(stopOnSkip=true)` `sequential`                                                          | `args(sequential=true)` `isolated`                                                            | `args(isolated=true)` `xonly`                                                               | `args(xonly=true)` `showOnly(status: String)`                                            | `args(showOnly=status)` `fullStackTrace`                                                      | `args.report(traceFilter=NoStackTraceFilter)` `diffs(show, separators, triggerSize, shortenSize, diffRatio, full)`  | `args.report(diffs=SmartDiffs(show, separators, triggerSize, shortenSize, diffRatio, full))`", "tags":"", "loc":"org.specs2.guide.ArgumentsReference.html"},
{"title":"AsResult typeclass", "text":"There are many ways to define expectations in specs2:Boolean (`true, false`)Standard result (`success, failure`)Matcher result (`1 must_== 1`)Scalacheck propertyDataTableFormsAll of these types implement the `org.specs2.execute.AsResult` typeclass, meaning that they can be transformed into a `Result`:trait AsResult[T] {  def asResult(t: =>T): Result}This gives some flexibility in integrating any kind of custom definition of a \"result\" into specs2 and this is why you find this typeclass as a requirement to build examples or to declare contexts.You can take advantage of this type class by defining your own kind of result and providing a typeclass instance for it:// A new type of results for cluster executiontrait ClusterExecution {  def succeeded: Boolean  def errorMessage: String}object ClusterExecution {  implicit def clusterExecutionAsResult: AsResult[ClusterExecution] =    new AsResult[ClusterExecution] {      def asResult(t: =>ClusterExecution): Result = {        try {          val result = t          if (result.succeeded) Success()          else                  Failure(t.errorMessage)        } catch { case e: Throwable => Error(e) }      }   }} Decorated resultsYou can also embed custom data in a special kind of `Result`, a `DecoratedResult`:case class DecoratedResult[+T](decorator: T, result: Result) extends Result(result.message, result.expected)A `DecoratedResult[T]` decorates an ordinary result with an additional value of type `T`. If you want to take advantage of this custom value in your reports you will need to build a custom `org.specs2.reporter.Printer`, probably extending an existing one. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - mark any object having an `AsResult` instance as </div>", "tags":"", "loc":"org.specs2.guide.AsResultTypeclass.html"},
{"title":"Example description", "text":"[\"Don't repeat yourself\"](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself) mandates that the same information is not repeated twice.However this situation happens when part of an example description is reused in the example body: s2\"\"\"  1971-01-01 is a correct date $correct\"\"\"  def correct = { \"1971-01-01\" must beCorrect } Use the example descriptionYou can avoid this by creating the example body as a function using the description string: s2\"\"\" 1971-01-01 is a correct date $correct\"\"\"  def correct = { date: String =>    date.split(\" \")(0) must beCorrect  } Parse the example description Delimited valuesWe can reuse the `StepParsers` presented in the  to extract the values we wish to use: s2\"\"\" {1971-01-01} is a correct date $correct {1} plus {1} is {2}            $addition\"\"\"  import org.specs2.specification.script.StepParsers._  def correct = extract { date: String =>    date must beCorrect  }  def addition = extract { (a: String, b: String, c: String) =>    a.toInt + b.toInt must_== c.toInt  }The values to be extracted are delimited by `{}` and those curly braces will not be displayed when the specification is reported. Standard delimited parsersWhen you parse values with `extract` you get only Strings which you have to transform into `Int` for example. specs2 comes up with a few predefined parsers to help you with that: s2\"\"\" {1} plus {1} is {2}            $addition\"\"\"  import org.specs2.specification.script.StandardDelimitedStepParsers._  def addition = threeInts.map { case (a, b, c) =>    a + b must_== c  }The other parsers are: parser        | description ------------- | ----------- `anInt`       | return a `Int` `twoInts`     | return a pair `(Int, Int)` `threeInts`   | return a triple `(Int, Int, Int)` `aDouble`     | return a `Double` `twoDoubles`  | return a pair `(Double, Double)` `threeDoubles`| return a triple `(Double, Double, Double)` `aString`     | return a `String` `twoStrings`  | return a pair `(String, String)` `threeStrings`| return a triple `(String, String, String)` Regular expressionsAnother way to extract values is to use regular expressions to extract similar groups of values. In that case no delimiters are required. For example: s2\"\"\" 1971-01-01 is a correct date $correct 1 plus 1 is 2                $addition\"\"\"  import org.specs2.specification.script.StepParsers._  // groupAs is equivalent to running 'regexp findAllIn text'  // and getting one argument per match group found  def correct = groupAs(\"[ ]+\").and { date: String =>    date must beCorrect  }  def addition = groupAs(\"\\d+\").and { (a: String, b: String, c: String) =>    a.toInt + b.toInt must_== c.toInt  } Standard regexp parsersSimilarly to delimited parsers, there are some predefined regexp parsers: s2\"\"\" 1 plus 1 is 2            $addition\"\"\"  import org.specs2.specification.script.StandardRegexStepParsers._  def addition = threeInts.map { case (a, b, c) =>    a + b must_== c  }", "tags":"", "loc":"org.specs2.guide.ExampleDescription.html"},
{"title":"Timeout examples", "text":" One exampleSome examples take too long to run and it is desirable to interrupt them if they do. This is the purpose of the `org.specs2.specification.AroundTimeout` trait: import org.specs2.specification.AroundTimeoutimport scala.concurrent.duration._class MySpec extends Specification with AroundTimeout                                   with ExecutionEnvironment {def is(implicit ee: ExecutionEnv) = s2\"\"\"  this should not take too long ${upTo(1.second)(e1)}\"\"\"  def e1 = { 1 + 1 === 2 }}Note that you need to extend the `org.specs2.specification.ExecutionEnvironment` trait to get an implicit `ExecutionEnv` in order to use this functionality (read more on the ). The whole specificationYou can also declare a timeout for all the examples of a given specification with the `org.specs2.specification.ExamplesTimeout` trait:import org.specs2.specification.ExamplesTimeoutclass MySpec extends Specification with ExamplesTimeout                                   with ExecutionEnvironment {def is(implicit ee: ExecutionEnv) = s2\"\"\"  this should not take too long $e1  this one too                  $e2\"\"\"  def e1 = { 1 + 1 === 2 }  def e2 = { 2 + 2 === 4 }}With the `ExamplesTimeout` trait you can control the duration of the time out by passing the `timeout` argument on the command-line (in milliseconds).", "tags":"", "loc":"org.specs2.guide.TimeoutExamples.html"},
{"title":"Isolation", "text":"Unit specifications allow to nest blocks, as if they were different contexts, going from the more general to the more specific. It can be very tempting, for some applications, to include some mutable state representing data in more and more specific contexts. However, this can be problematic because: - you have to reset the state for each example in a sequential specification - you will have concurrency issues for a concurrent oneOne way to avoid this is to execute each example in its own instance of the specification. Isolated variablesThe `isolated` argument duplicates the body of each example so that it is executed in a brand new instance of the Specification: class IsolatedSpec extends mutable.Specification {  isolated  \"Java Properties can store configuration properties\" >> {    // empty properties context    val props = new Properties    \"we can add a property\" >> {      props.setProperty(\"p1\", \"v1\")      props.getProperty(\"p1\") must_== \"v1\"    }    \"we can get all the properties names\" >> {      props.setProperty(\"p1\", \"v1\")      props.setProperty(\"p2\", \"v2\")      props.propertyNames.toList must_== List(\"p1\", \"p2\")    }    \"Properties can be stored\" >> {      // non-empty properties context      props.setProperty(\"p1\", \"v1\")      props.setProperty(\"p2\", \"v2\")      \"to an OutputStream\" >> {        val out = new ByteArrayOutputStream        props.store(out, \"to stream\")        out.size() must be_>(0)      }      \"to a Writer\" >> {        val out = new ByteArrayOutputStream        val writer = new PrintWriter(out)        props.store(writer, \"to writer\")        out.size() must be_>(0)      }    }  }}Since there is a new Specification for each example, then all the variables accessible to the example will be seen as new. InstantiationIf the specification has a constructor with parameters, they need themselves to be instantiable with a no-args constructor. For example `class AkkaSpec(system: AkkaSystem) extends Specification` can not be instantiated because `AkkaSystem` doesn't have a 0-args constructor.", "tags":"", "loc":"org.specs2.guide.Isolation.html"},
{"title":"Multiline descriptions", "text":"In a `s2` string the description of an example is taken as all the text having the same indentation before the example body:s2\"\"\"  This is the introduction paragraph  Which presents the examples    the first example has one line $ok    the second example has    more than one line             $ok\"\"\"This printsThis is the introduction paragraphWhich presents the examples  + the first example has one line  + the second example has    more than one lineIf you want the example description to be unevenly aligned you can use a margin `|`:s2\"\"\"  This is the introduction paragraph  Which presents the examples    |this example has a very    | very very    |   specific indentation $ok\"\"\"This printsThis is the introduction paragraphWhich presents the examples  + this example has a very     very very       specific indentation", "tags":"", "loc":"org.specs2.guide.MultilineDescriptions.html"},
{"title":"Print execution data", "text":" Print success dataIf an example returns returns a `Success` we just print the example name on the console but it can be interesting to also get some information about the data the example was executed with. In order to do that you can use the `updateExpected` method and pass a non-empty string with your message: \"this is an obvious example\" ! {    val i = 1    (i must_== 1).toResult.updateExpected(\"executed with \"+i)  }Let's use this method now to display the execution time for each example. Print execution timeKnowing that an example succeeded is fine but sometimes you want to display more information, like the time spent executing the example for instance, or some other state before and after each example.This can be done by using the `AroundEach` trait and updating the `Result` of the example execution with whatever you want to display: trait Timed extends AroundEach {  def around[T : AsResult](t: =>T): Result = {    // use `ResultExecution.execute` to catch possible exceptions    val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))    // update the result with a piece of text which will be displayed in the console    result.updateExpected(\"Execution time: \"+timer.time)  }  /** mesure the execution time of a piece of code */  def withTimer[T](t: =>T): (T, SimpleTimer) = {    val timer = (new SimpleTimer).start    val result = t    (result, timer.stop)  }}When you execute a specification mixing the `Timed` trait you should see the timing of each example displayed in the console:[info] TimedExecutionSpecification[info][info] + example 1[info] Execution time: 94 ms[info] + example 2[info] Execution time: 11 msNote that this is just an example. The same functionality is actually accessible with the [`showtimes` argument](). With the example descriptionMore generally, you can both use the example description and the example body to display custom messages. To do this you need to intercept the creation of examples by creating a new `FragmentFactory`: // a trait to create an Around context using the example descriptiontrait TimedContext {  def context(exampleDescription: String) = new Timed(exampleDescription)  case class Timed(exampleDescription: String) extends Around {    def around[T : AsResult](t: =>T): Result = {      val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))      result.updateExpected(s\"Execution time for example $$exampleDescription: $${timer.time}\")    }    def withTimer[T](t: =>T): (T, SimpleTimer) = {      val timer = (new SimpleTimer).start      val result = t      (result, timer.stop)    }  }}class TimedSpecification extends Specification with TimedContext { def is = s2\"\"\" Example 1 $ok Example 2 $ok\"\"\"  // create a new DefaultFragmentFactory where the body of the example uses  // the current example description  override lazy val fragmentFactory = new DefaultFragmentFactory {    override def example[T : AsResult](description: String, t: =>T): Fragment =      super.example(description, context(description)(AsResult(t)))  }}", "tags":"", "loc":"org.specs2.guide.PrintExecutionData.html"},
{"title":"Print execution data", "text":" Print success dataIf an example returns returns a `Success` we just print the example name on the console but it can be interesting to also get some information about the data the example was executed with. In order to do that you can use the `updateExpected` method and pass a non-empty string with your message: \"this is an obvious example\" ! {    val i = 1    (i must_== 1).toResult.updateExpected(\"executed with \"+i)  }Let's use this method now to display the execution time for each example. Print execution timeKnowing that an example succeeded is fine but sometimes you want to display more information, like the time spent executing the example for instance, or some other state before and after each example.This can be done by using the `AroundEach` trait and updating the `Result` of the example execution with whatever you want to display: trait Timed extends AroundEach {  def around[T : AsResult](t: =>T): Result = {    // use `ResultExecution.execute` to catch possible exceptions    val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))    // update the result with a piece of text which will be displayed in the console    result.updateExpected(\"Execution time: \"+timer.time)  }  /** mesure the execution time of a piece of code */  def withTimer[T](t: =>T): (T, SimpleTimer) = {    val timer = (new SimpleTimer).start    val result = t    (result, timer.stop)  }}When you execute a specification mixing the `Timed` trait you should see the timing of each example displayed in the console:[info] TimedExecutionSpecification[info][info] + example 1[info] Execution time: 94 ms[info] + example 2[info] Execution time: 11 msNote that this is just an example. The same functionality is actually accessible with the [`showtimes` argument](). With the example descriptionMore generally, you can both use the example description and the example body to display custom messages. To do this you need to intercept the creation of examples by creating a new `FragmentFactory`: // a trait to create an Around context using the example descriptiontrait TimedContext {  def context(exampleDescription: String) = new Timed(exampleDescription)  case class Timed(exampleDescription: String) extends Around {    def around[T : AsResult](t: =>T): Result = {      val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))      result.updateExpected(s\"Execution time for example $$exampleDescription: $${timer.time}\")    }    def withTimer[T](t: =>T): (T, SimpleTimer) = {      val timer = (new SimpleTimer).start      val result = t      (result, timer.stop)    }  }}class TimedSpecification extends Specification with TimedContext { def is = s2\"\"\" Example 1 $ok Example 2 $ok\"\"\"  // create a new DefaultFragmentFactory where the body of the example uses  // the current example description  override lazy val fragmentFactory = new DefaultFragmentFactory {    override def example[T : AsResult](description: String, t: =>T): Fragment =      super.example(description, context(description)(AsResult(t)))  }}", "tags":"", "loc":"org.specs2.guide.PrintExecutionData.html"},
{"title":"Lightweight specs", "text":"The default `Specification` class mixes in most of specs2 features in order to make it very easy to write your first specifications without worrying too much about where the feature resides.There at least 2 downsides to this approach:inside a `Specification` you get lots of inherited method names, encumbering the namespacemany of the traits mixed-in the `Specification` class define implicit methods and those methods have a big impact on compilation timesIt is thus possible to use another class, `org.specs2.Spec` (or `org.specs2.mutable.Spec`), which only provides the minimum number of implicits to create specifications.With the `Spec` class you can create examples and expectations with simple matchers. For example:class HelloWorldSpec extends Spec { def is = s2\"\"\" This is a specification to check the 'Hello world' string The 'Hello world' string should   contain 11 characters                                         $e1   start with 'Hello'                                            $e2   end with 'world'                                              $e3                                                                 \"\"\" def e1 = \"Hello world\" must haveSize(11) def e2 = \"Hello world\" must startWith(\"Hello\") def e3 = \"Hello world\" must endWith(\"world\")}Or, for mutable specs:class HelloWorldSpec extends mutable.Spec {  addParagraph(\"This is a specification to check the 'Hello world' string\") \"The 'Hello world' string\" should {   \"contain 11 characters\" in {     \"Hello world\" must haveSize(11)   }   \"start with 'Hello'\" in {     \"Hello world\" must startWith(\"Hello\")   }   \"end with 'world'\" in {     \"Hello world\" must endWith(\"world\")   } }}If you compare those 2 specifications with the \"HelloWorldSpec\" examples using `Specification` you will notice some differences: - you cannot write `\"Hello world\" must have size(11)` - you cannot write `\"This is a specification to check the 'Hello world' string\".txt` to add some text to a mutable specBut not all is lost! For each functionality you might want to use there is a trait which you can mix-in to get it. Adding featuresWhen creating expectations: Feature                                          | Trait                                           | Comment ------------------------------------------------ | ----------------------------------------------- | ---------------------- Use `should` for expectations                    | `org.specs2.matcher.ShouldMatchers`             | Describe expectations with `==>`                 | `org.specs2.matcher.ExpectationsDescription`    | Describe expectations with `aka` and `must`      | `org.specs2.matcher.MustExpectations`           | Use `list must have size(3)`                     | `org.specs2.matcher.TraversableMatchers`        | For each matcher you want to use after `be/have/not`, you need to mix-in the corresponding matchers trait Use matchers in `contain` or `beSome` matchers   | `org.specs2.matcher.ValueChecks`                | Use `===`, `====` to check for equality          | `org.specs2.matcher.TypedEqual`                 | Create matchers from functions                   | `org.specs2.matcher.MatchersCreation`           | Combine `MatchResults` with `and/or`             | `org.specs2.matcher.MatchResultsCombinators`    | Transform a `Matcher[T]` to `Matcher[Seq[T]]`    | `org.specs2.matcher.SequenceMatchersCreation`   | Use `forall(values)(t => t must xxx)`            | `org.specs2.matcher.SequenceMatchersCreation`   | You can combine all matchers features by using the `org.specs2.matcher.MatchersImplicits` trait Set failed expectations as Pending               | `org.specs2.execute.PendingUntilFixed`          |When creating acceptance specifications Feature                                                      | Trait                                                  | Comment ------------------------------------------------------------ | ------------------------------------------------------ | ---------------------- Interpolate anything else than a `Result` in a `s2` string   | `org.specs2.specification.create.S2StringContext`      | Use \"bang\" examples: `\"example\" ! ok`                        | `org.specs2.specification.dsl.ExampleDsl`              | Create and append `Fragments` with ``                       | `org.specs2.specification.dsl.FragmentsDsl`            | Add arguments and a title to `Fragments` with ``            | `org.specs2.specification.dsl.SpecStructureDsl`        | Create a title with `\"A title\".title\"`                       | `org.specs2.specification.dsl.TitleDsl`                | Create references to other specifications                    | `org.specs2.specification.dsl.ReferenceDsl`                 | Create steps and actions                                     | `org.specs2.specification.dsl.ActionDsl`               | Use tags                                                     | `org.specs2.specification.dsl.TagDsl`                  | To use all of the `Dsl` traits use `AcceptanceDsl`When creating mutable specifications Feature                                                      | Trait                                                  | Comment ------------------------------------------------------------ | ------------------------------------------------------ | ---------------------- Use \"bang\" examples: `\"example\" ! ok`                        | `org.specs2.specification.dsl.mutable.ExampleDsl`      | Create a title with `\"A title\".title\"`                       | `org.specs2.specification.dsl.mutable.TitleDsl`        | Set arguments                                                | `org.specs2.specification.dsl.mutable.ArgumentsDsl`    | Create references to other specifications                    | `org.specs2.specification.dsl.mutable.ReferenceDsl`         | Create steps and actions                                     | `org.specs2.specification.dsl.mutable.ActionDsl`       | Add text and paragraphs                                      | `org.specs2.specification.dsl.mutable.TextDsl`         | Use tags                                                     | `org.specs2.specification.dsl.mutable.TagDsl`          | To use all of the `Dsl` traits use `MutableDsl`", "tags":"", "loc":"org.specs2.guide.LightweightSpecs.html"},
{"title":"JUnit XML output", "text":"Many continuous integration servers (like [Jenkins](http://jenkins-ci.org)) accept JUnit XML as their de facto standard for reporting test results. You can output a JUnit XML file by simply using the `junitxml` argument: `testOnly org.acme.MySpec -- junitxml`The JUnit XML file corresponding to the specification will be produced by default in the `target/test-reports` directory. You can change this directory by passing the `junit.outdir` argument like so: `testOnly org.acme.MySpec -- junitxml junit.outdir custom_xml_folder`This will output the xml files in the `custom_xml_folder` in the top level project directory. that using `junitxml` by itself will turn off the console reporting. You need to add `console` to get it back.Note that `sbt test` does not take parameters so the default behavior is to produce the JUnit XML files for all specifications in the default output directoryIn order to change the default output directory of the junit xml files when running the tests with `test`, add the following to your sbt build file: `testOptions in Test += Tests.Argument(\"junitxml\", \"junit.outdir\", \"custom_xml_folder\")`Note that this will suppress the console output, which may be what you want if this is a configuration for a build machine. To re-enable console output, use instead:  testOptions in Test ++= Seq(    Tests.Argument(\"junitxml\", \"junit.outdir\", \"custom_xml_folder\"),    Tests.Argument(\"console\") ) ", "tags":"", "loc":"org.specs2.guide.JUnitXmlOutput.html"},
{"title":"Debug statements", "text":"When quick and hacky `println` statements are what you want, the `Debug` trait, mixed in every `Specification`, provides useful methods: * `pp` or \"print and pass\", prints a value to the console, then returns it to be used in the rest of the expression: `graph.pp must haveSize(3)` * `pp(condition)` prints a value if a condition holds * `pp(f: T => Boolean)` prints a value if a condition on that value holds", "tags":"", "loc":"org.specs2.guide.DebugStatements.html"},
{"title":"Random execution", "text":" The  page describes the most frequent modes of execution:  - fully concurrent  - concurrent with steps  - fully sequentialExecuting the specification concurrently in particular can be a good way to test the stability of the system in presence of random commands. However it is sometimes not possible to overlap examples executions because that could break the external state. Random sequential executionIn this case you can use another mode of execution. By mixing-in the `org.specs2.specification.process.RandomSequentialExecution` trait some execution constraints will be randomly added to your examples so that they will force your examples to execute in a random order, one after the other. This randomization is only being done for examples in between steps so if you have steps inside the specification guaranteeing some kind of checkpoints during the execution, they will be preserved.Let's see this on an example:class RandomSequentialSpec extends Specification with RandomSequentialExecution { def is = s2\"\"\" example1 $e1 example2 $e2 example3 $e3 ${step(\"here\".pp)} example4 $e4 example5 $e5 example6 $e6\"\"\"  def e1 = { \"e1\".pp; ok }  def e2 = { \"e2\".pp; ok }  def e3 = { \"e3\".pp; ok }  def e4 = { \"e4\".pp; ok }  def e5 = { \"e5\".pp; ok }  def e6 = { \"e6\".pp; ok }}With such a specification you might see in the console:[info] e3[info] e2[info] e1[info] here[info] e5[info] e6[info] e4 Using ScalaCheckThe `RandomSequentialExecution` trait is actually a very naive way to test random commands on a system. A much better approach is to use ScalaCheck and its notion of [stateful property-based testing](http://www.scalacheck.org/files/scaladays2014/index.html).", "tags":"", "loc":"org.specs2.guide.RandomExecution.html"},
{"title":"Html output", "text":"specs2 can be used to produce HTML documentation to either: - report the execution of specifications - provide a user guide like this oneIf Markdown notation is used in the specification text and you have [Pandoc](http://johnmacfarlane.net/pandoc) installed on the command line then it will rendered in the final output. Create Html filesWhen you execute a specification with the `html` command-line argument an HTML report is created in the `target/specs2-reports` directory. It will show the status of examples (success, failure,...) and stack traces if there are any errors.You can use the following arguments to change the HTML generation: Name                         | Default value                                 | Description ---------------------------- | --------------------------------------------- | ------------------------------ `all`                        | `false`                                       | execute and report linked specifications `html.outdir`                | `target/specs2-reports`                       | output directory `html.template`              | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`             | `Map[String, String]()`                       | those variables will be replaced during template evaluation `html.nostats`               | `false`                                       | if true no stats are displayed `html.search`                | `false`                                       | add a search box to the generated files `html.toc`                   | `false`                                       | add a table of contents to the generated files `html.toc.entrymaxsize`      | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs`      | `true`                                        | report \"see\" references which do not correspond to any generated file Use Pandoc for Markdown[Markdown](http://commonmark.org) text is supported if [Pandoc](http://johnmacfarlane.net/pandoc) is available on the command line and if the `!pandoc` boolean flag is not set._NOTE!!!_: the currently supported version of Pandoc is 1.13.2. Name                    | Default value                                                                     | Description ----------------------- | --------------------------------------------------------------------------------- | ------------------------------ `pandoc`                | `true`                                                                            | set to `false` by passing `!pandoc` `pandoc.exec`           | `pandoc`                                                                          | path to the Pandoc executable `pandoc.inputformat`    | `markdown+pipe_tables+auto_identifiers+header_attributes+inline_code_attributes`  | pandoc arguments (see the Pandoc [user guide](http://johnmacfarlane.net/pandoc/README.html)) `pandoc.outputformat`   | `html`                                                                            | Use a different templateYou can change the overall structure of the html page for a specification by providing a different template with the `html.template` variable. When using your custom template the following variables will be replaced: Name                    | Description ----------------------- | ------------------------------ `$title$`             | specification title `$issues$`            | true if there are issues in the specification `$body$`              | the specification bodyYou can also pass your own variables by passing a map `name1=value1,name2=value2,...` to the `html.variables` argument. Those variables can then be used in the template: - by enclosing them in `$`: `$myVariable$` - by using the `if/else/endif` construct:$if(issues)$<h1>Failed! $title$$else$<h1>$title$</h1>$endif$ Use other CSS/Javascript filesCustom CSS and JavaScript files can be used without changing the template. In order to do this just put your own `specs2-user.css` file in `src/test/resources/css` or your own `specs2-user.js` file in `src/test/resources/javascript`. Create an indexHere is something you can do to automatically create an index page for your specifications: import org.specs2._import specification.core._import runner.SpecificationsFinder._class index extends Specification { def is =  examplesLinks(\"Example specifications\")  // see the SpecificationsFinder trait for the parameters of the 'specifications' method  def examplesLinks(t: String) =    t.title     Fragments.foreach(specifications())(s => link(s)  br)}The specification above creates an index.html file in the `target/specs2-reports` directory. The specifications method creates specifications using the following parameters: Name                    | Default                                       | Description ----------------------- | --------------------------------------------  | ---------------- `glob`                  | `**/*.scala`                                  | glob pattern to filter specification files `pattern`               | `.*Spec`                                      | pattern to use when trying to retrieve the specification names from the source files `filter`                | `(name: String) => true`                      | function to keep only some specifications depending on their name `basePath`              | `src/test/scala`                              | the path where to start the search `verbose`               | `false`                                       | boolean indicating if information about finding files and specifications must be printed `classLoader`           | `Thread.currentThread.getContextClassLoader`  | classloader used to load the specification classes `filePathReader`        | `org.specs2.io.FileSystem`                    | object used to read source files", "tags":"", "loc":"org.specs2.guide.HtmlOutput.html"},
{"title":"Capture snippets", "text":"It is possible to include pieces of code in your documentation with the `org.specs2.specification.Snippets` trait using the `snippet` method to capture a block code with marker comments to delimit the parts you want to show.What does this look like? SnippetHere is an example of using the `snippet` method:s2\"\"\"This is a multi-line string with a code snippet: ${ snippet {def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))factorial(3) == 6}}\"\"\"When you use the `snippet` method, the reports will show:This is a multi-line string with a code snippet:def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))factorial(3) == 6 CutsSince snippets are compiled code, you might have to include many declarations, like imports or variables definitions to make the code compile. This can make your documentation more verbose than necessary so you can hide those definitions by delimiting the code to show with some comments of the form `// 8<--`:s2\"\"\"This is a snippet of code with one relevant line: ${ snippet {// 8<--def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))// 8<--factorial(3) == 6// 8<--}}\"\"\"The snippet above will only show `factorial(3) == 6`. You can repeat this pattern several times:s2\"\"\"This is a snippet of code with 2 relevant lines: ${ snippet {// 8<--def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))// 8<--factorial(3) == 6// 8<--val n = 4// 8<--factorial(n) == 24}}\"\"\"This just displays:factorial(3) == 6factorial(n) == 24 EvaluationBy default the last value of a Snippet is not shown but you can display it with the `eval` method:s2\"\"\"This is a snippet of code with a result: ${ snippet {factorial(3)}.eval}\"\"\"This displays:factorial(3)> 6 OffsetsIt is possible to adjust the margin of captured source code by adding or removing whitespace:s2\"\"\"This is a snippet of code with a negative offset to align the code to the border of the screen: ${ snippet {   def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))   factorial(3)}.offsetIs(-3)}\"\"\"This displays:factorial(3) ParametersAll of the settings above: cuts, offset,... are coming from an implicit `SnippetParams` object that is changing the behavior of the created Snippets. You can choose, for a given scope, to replace these parameters with other ones and simply shadow the default parameters with your own, for example to always evaluate the snippets results:implicit snippetParams = SnippetParams(eval = true)The parameters you can set are:name              | description----------------- | ---------------- `trimExpression` | function that is trimming the expression from newlines or accolades `cutter`         | function to remove parts which must not be shown `asCode`         | function to render the resulting text (as Markdown for example) `prompt`         | function to display the evaluated result with a prompt `eval`           | boolean indicating if a snippet must be evaluated `verify`         | function checking the snippet value", "tags":"", "loc":"org.specs2.guide.CaptureSnippets.html"},
{"title":"Use command-line arguments", "text":"Some specifications need to be fine-tuned and constantly modified. Sometimes to access a specific environment, or to disable some examples, or to execute more ScalaCheck properties. For all those situations it is desirable to modify the specification directly from the command-line without having to recompile it. Control an exampleLet's see first how to use the command line to modify the outcome of just one example:class SpecificationWithArgs extends Specification { def is = s2\"\"\" This example is controlled from the command line $e1\"\"\"  def e1 = (commandLine: CommandLine) =>    if (commandLine.isSet(\"isOk\")) 1 must_== 1    else                           1 must_== 2}With a mutable specification the code is similar:class SpecificationWithArgs extends mutable.Specification { \"This example is controlled from the command line\" in { commandLine: CommandLine =>   if (commandLine.isSet(\"isOk\")) 1 must_== 1   else                           1 must_== 2 }} Control a specificationThere are 2 ways to drive the creation of the full specification with command line arguments. CommandLineArguments traitMixing-in the `CommandLineArguments` trait allow you to pass the command line arguments in the `is` method: class SpecificationWithArgs extends Specification with CommandLineArguments { def is(commandLine: CommandLine) =  if (commandLine.isSet(\"small\"))s2\"\"\" This is a small specification  with one example $e1\"\"\"  elses2\"\"\" This is a BIG specification  with many examples ${ Fragment.foreach(1 to 1000)(i => \"ex\"+i ! ok) }\"\"\"  def e1 = ok}For a mutable specification we can use almost the same syntax but the `CommandLineArguments` trait must come from the `org.specs2.specification.mutable` package:class SpecificationWithArgs extends mutable.Specification with specification.mutable.CommandLineArguments {  def is(commandLine: CommandLine) =    if (commandLine.isSet(\"small\"))      \"This is a small specification\" should {        \"with one example\" in { 1 must_== 1 }      }    else      \"This is a small specification\" >> {        \"with lots of examples\" >> Fragment.foreach(1 to 1000)(i => \"ex\"+i >> ok)      }} Dependency injectionAny specification with a 1-parameter constructor can be instantiated provided that: - the parameter has itself a constructor with no parameters or a 1-parameter constructor which we can instantiate - the paramater is of type `Env`, `Arguments`, `CommandLine`In particular this means that you can define a `Specification` with a constructor using a `CommandLine` argument and when the specification will be created it will be passed the command line arguments: case class MyDbSpec(commandLine: CommandLine) extends Specification with DbSpec { def is = s2\"\"\"  create a user $createUser\"\"\"  // the database client is created from the command line  // arguments and can be used in the examples  def createUser = client.createUser(\"xxx\") must beSome}// Template trait for accessing the database// this trait can be controlled from command line arguments// and it takes care of the setup of the database before and after all// the examplestrait DbSpec extends Specification with BeforeAfterAll {  def commandLine: CommandLine  def beforeAll = println(\"start db here\")  def afterAll  = println(\"stop db here\")  lazy val client = {    if (commandLine.contains(\"prod\")) DbClient(\"production\")    else                              DbClient(\"test\")  }  case class DbClient(env: String) {    def createUser(name: String): Option[String] = ???  }} Control a contextThe next thing you might want to control is contexts. Instead of using the `BeforeEach` / `AfterEach` / `AroundEach` traits directly you will need to implement the `ContextWithCommandLineArguments` trait and provide the appropriate context object:class SpecificationWithArgs extends Specification with ContextWithCommandLineArguments { def is = s2\"\"\" This is a specification with a context depending on command line arguments  with one example $ok\"\"\"  /** you need to define this method */  def context = (commandLine: CommandLine) =>    new Before {      def before = if (commandLine.isSet(\"dobefore\")) println(\"before!\")    }} Control data injectionThe final situation where you would need to use command-line arguments is with a `ForEach` trait. If you want to influence the injection of data with the command line, the `ForEachWithCommandLineArguments` trait needs to be mixed in:class SpecificationWithArgs extends Specification with ForEachWithCommandLineArguments[Int] { def is = s2\"\"\" This is a specification  with one example using injected data ${ (i: Int) => i must_== i }\"\"\"  /** you need to define this method */  def foreach[R : AsResult](commandLine: CommandLine)(f: Int => R) =    AsResult(f(commandLine.int(\"value\").getOrElse(0)))}And for a mutable specification:class SpecificationWithArgs extends mutable.Specification with specification.mutable.ForEachWithCommandLine[Int] {  \"This is a specification\" >> {    \"with one example using injected data\" >> { (i: Int) =>      i must_== i    }   }   /** you need to define this method */   def foreach[R : AsResult](commandLine: CommandLine)(f: Int => R) =     AsResult(f(commandLine.int(\"value\").getOrElse(0)))}", "tags":"", "loc":"org.specs2.guide.UseCommandLineArguments.html"},
{"title":"Skip examples", "text":"The section on  already presents two methods for skipping examples. But this works for individual examples only. In some circumstances you might want to skip a whole specification. For example, your specification needs to access a web service in order to work and this service might not be available on all testing machines. You can skip this specification conditionally with the `skipAllIf` argument:class InactiveSpec extends Specification { def is = skipAllIf(databaseIsDown)  s2\"\"\"  There is a list of customers in the database $e1  One of them is called Eric                   $e2\"\"\"  def e1 = database.getCustomers must not beEmpty  def e2 = database.getCustomers must contain((_:Customer).name === \"Eric\")}There also is a version of `skipAllIf` which reads better for some conditions: `skipAllUnless`.", "tags":"", "loc":"org.specs2.guide.SkipExamples.html"},
{"title":"Selection", "text":"Many specifications are written incrementally. You specify a little bit then you implement the application. When you go through this \"Specify-Implement-Execute\" cycle it is useful to be able to focus on just one example, the one you are currently working on. The `ex` argument is what you need (`ex` stands for \"example\"):sbt> testOnly *MySpecification* -- ex containsThe command above will execute any example which description matches the regular expression `.*contains.*` (which means that you can pass regular expressions in general). If you want to match a few words you will need to use double quotes:sbt> testOnly *MySpecification* -- ex \"contains hello\" sequential Use tagsTags can be used in a Specification to include or exclude some examples or a complete section of fragments from the execution. Let's have a look at one example: class TaggedSpecification extends Specification { def is = s2\"\"\" this is some introductory text  and the first group of examples  example 1 $success                         ${tag(\"feature1\", \"unit\")}  example 2 $success                         ${tag(\"integration\")}  and the second group of examples           ${section(\"checkin\")}  example 3 $success  example 4 $success                         ${section(\"checkin\")}                                             \"\"\"  }In that specification we are defining several tags and sections:* `feature 1` is a tag that is applied to `example1` (the _preceding_ Fragment)* `feature 2` is a tag that is applied to `example2` (the _preceding_ Fragment)* `checkin` marks a section which goes from the Text `and the second group of examples` to `example 4`Armed with this, it is now easy to include or exclude portions of the specification at execution time:* `include feature1` will only include `example 1`* `exclude integration` will include everything except `example 2`* `include checkin,unit` will include anything having either `checkin` OR `unit`: i.e. `example 1` and the second group of examples (`example 3` and `example 4`)* `include feature1 && unit` will include anything having `feature1` AND `unit`: i.e. `example 1`* `include feature1 && unit, checkin` will include anything having `feature1` AND `unit`, OR having `checkin`: i.e. `example 1`, `example 3`, `example4` In a unit specificationA _unit_ specification will accept the same `tag` and `section` methods but the behavior will be slightly different: import org.specs2.mutable._class TaggedSpecification extends Specification {  \"this is some introductory text\" >> {    \"and the first group of examples\" >> {      tag(\"feature 1\", \"unit\")      \"example 1\" in success      \"example 2\" in success    }  }  section(\"checkin\")  \"and the second group of examples\" >> {    \"example 3\" in success    \"example 4\" in success  }  section(\"checkin\")  \"and the last group of examples\" >> {    \"example 5\" in success    \"example 6\" in success  }}For that specification above: * when the `tag` call is inserted on a new line, the tagged fragment is the one just _after_ the tag method call: `example 1` is tagged with `feature1 and unit`, * when the `tag` is appended to an example, it applies to that example: `example 2` is tagged with `integration` * when the `section` call is inserted on a new line, this opens a section for all the following fragments. This should be closed by a corresponding `section` call on a new line. For example, `example 3` and `example 4` are part of the \"checkin\" section * when the `section` call is appended to a block of Fragments on the same line, all the fragments of that block are part of the section: `example 5` and `example 6` are tagged with `slow` `Always` tagSome specifications need to have `Steps` which will always be included whatever tags are specified on the command line. This is the case when defining a  with setup/teardown steps: trait DatabaseSpec extends Specification {  override def map(fs: =>Fragments) =    step(\"startDb\")  tag(AlwaysTag)     fs     step(\"cleanDb\")  tag(AlwaysTag)} Select failed examplesAnother frequent mode of selection is the selection based on previous execution. Generally we want to re-execute only what was broken before. For this, using the `was` argument on the command-line:sbt> testOnly *MyFailedSpecification* -- was xOn the line above `x` is the status of the previous example. Here is a table of all the flags you can use:  Flag | Description ----- | ------------  `+`  | successful example  `x`  | failed example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `1`  | statisticsThis selection works because specs2 stores the state of each specification in a directory after a run (`target/specs2-reports/stats` by default). If you decide that this storing is useless and you want to skip it you can use the `neverstore` argument. Otherwise if you want to make sure that the `stats` directory doesn't become too big over time you can use the `resetstore` argument which will remove the current store before running the specification. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - learn how to  - consult the  for a list of all arguments</div>", "tags":"", "loc":"org.specs2.guide.Selection.html"},
{"title":"For loops", "text":"It is very tempting to use `foreach` to create examples or results from a sequence of values:(1 to 3).foreach(i => \"example \"+i ! { i must_== i })The problem with `foreach` is that the return value of the expression above is `Unit`. So you won't be able to use it in an acceptance specification or a mutable one. A list of examplesWhen we want to create a list of examples we need to return a `Fragments` object. The long-winded way to do so is to use a `foldLeft`:(1 to 3).foldLeft(Fragments.empty)((res, i) => res.append(\"example \"+i ! { i must_== i }))Or, a bit fancier with Scalaz:// Fragments has a Monoid so you can use the foldMap method  (1 to 3).toList.foldMap(i => Fragments(\"example \"+i ! { i must_== i }))Because this is a recurring pattern there are two methods encapsulating it:// when the function only returns a Fragment  Fragment.foreach(1 to 3)(i => \"example \"+i ! { i must_== i }): Fragments  // when the function returns a Fragments object  Fragments.foreach(1 to 3) { i =>    \"examples for \"+i  br    \"1 + \"+i ! { (1 + i) must_== (i + 1) }  br    \"2 + \"+i ! { (2 + i) must_== (i + 2) }  }: FragmentsNow you can create a list of examples inside a \"should\" block in a mutable specification:class MySpec extends mutable.Specification {  \"this block should have lots of examples\" >> {    Fragment.foreach(1 to 1000) { i =>      \"example \"+i ! { i must_== i }    }  }} A list of resultsThe same situation happens when you want to create a list of expectations inside an example:class MySpec extends mutable.Specification {  \"this example has a lot of expectations\" >> {    Result.foreach(1 to 1000) { i =>      i must_== i    }  }}In that case the `Result.foreach` method is the one to use, it returns a `Result` that is the logical `and` of all results. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">   read about theunderstand why the `Result.foreach` method uses the </div>", "tags":"", "loc":"org.specs2.guide.ForLoops.html"},
{"title":"Console output", "text":"You will get a \"console\" output whenever you run a specification from ,  or a . There are arguments you can use to change the output:  Name               | Value format            | Comments ------------------- | ----------------------- | ------------------------------------------------------------------------ `all`               | boolean                 | execute and report linked specifications (default = `false`) `xonly`             | boolean                 | only report failures and errors `showonly`          | String                  | only report some examples based on their status `failtrace`         | boolean                 | show a stack trace for failures `fullstacktrace`    | boolean                 | show a full stack trace `tracefilter`       | regexp-csv/regexp-csv   | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`        | see below               | define the parameters for the `SmartDiffs` instance for differences `diffsclass`        | class name              | use a specific instance of the `Diffs` trait `color`             | boolean                 | use colors `nocolor`           | boolean                 | don't use colors `colors`            | map                     | use different colors `colorsclass`       | class name              | use a specific instance of the `Colors` trait `showtimes`         | boolean                 | show execution times for examples `indentation`       | int                     | number of spaces to use to indent nested examples (default = 2)Some of these arguments deserve further explanations. Show onlyYou can decide what you want to _show_ in the console by using the `showonly` arguments and the following flags:  Flag | Description ----- | ------------  `+`  | successful example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `#`  | title  `1`  | statisticsFor example if you just want to show text and failures you can use `showonly -x`. And the `xonly` argument is actually a shortcut for `showonly #x!`. StackTraceFilterThe `tracefilter` argument uses include/exclude patterns to define an instance of the `org.specs2.control.StackTraceFilter` trait which will filter stacktraces. By default the `DefaultStackTraceFilter` filter will exclude lines matching the following packages: * `org.specs2` * `scalaz\\.` * `scala\\.`, `java\\.` * `sbt\\.`, `com.intellij`, `org.eclipse.jdt`, `org.junit`If this is not what you want, you can either use the `tracefilter` argument with other patterns. For example `tracefilter com.acme\com.acme.impl` will only keep traces of classes in the `com.acme` package but will reject the ones in `com.acme.impl`.Note also that the default filter also truncates the stacktrace in the middle if it is bigger than 1000 lines to avoid reports being filled by out-of-control stacktraces. If you still want to see those lines you can re-run with the `fullstacktrace` argument. DiffsWhen using the equality matcher specs2 tries to display the difference between the expected and the actual values using a class: `org.specs2.main.SmartDiffs`. There are several parameters for that class which you can specify from the command line as:sbt> testOnly -- smartdiffs show,separators,triggerSize,shortenSize,diffRatio,full Parameter          | Description ------------------ | ----------- `show`             | will not show anything (default is true) `separators`       | allows to change the separators used to show the differences (default is \"[]\") `triggerSize`      | controls the size above which the differences must be shown (default is 20) `shortenSize`      | controls the number of characters to display around each difference (default is 5) `diffRatio`        | percentage of differences above which the differences must not be shown (default is 30) `full`             | displays the full original expected and actual strings `seqTriggerSize`   | the minimum size to compute differences on Seq, Set and Maps `seqMaxSize`       | the maximum size to compute differences on Seq, Set and MapsYou can also specify your own enhanced algorithm for displaying the difference by providing an instance of the `org.specs2.main.Diffs` trait:trait Diffs {  /** @return true if the differences must be shown */  def show: Boolean  /** @return true if the differences must be shown for 2 different values */  def show(actual: Any, expected: Any): Boolean  /** @return true if the differences must be shown for 2 different sequences of values */  def showSeq(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): Boolean  /** @return true if the differences must be shown for 2 different maps */  def showMap(actual: Map[Any, Any], expected: Map[Any, Any]): Boolean  /** @return the diffs */  def showDiffs(actual: Any, expected: Any): (String, String)  /** @return the diffs for sequences with missing / added values  */  def showSeqDiffs(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): (Seq[String], Seq[String])  /** @return the diffs for sequences with missing / added values  */  def showMapDiffs(actual: Map[Any, Any], expected: Map[Any, Any]): (Seq[String], Seq[String], Seq[String])  /** @return true if the full strings must also be shown */  def showFull: Boolean} ColorsBy default, the reporting will output colors. If you're running on windows you might either: * use the [following tip](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) to install colors in the DOS console * or pass `nocolor` as a command line argumentIt is possible to set colors by passing the `colors` argument. This argument must be a list of `key:value` pairs (comma-separated) where keys are taken from this table:Property  | Default value |--------- | ------------- |`text`    |  white        |`success` |  green        |`failure` |  yellow       |`error`   |  red          |`pending` |  cyan         |`skipped` |  magenta      |`stats`   |  cyan         |All the available colors are listed here, with their corresponding abbreviation which you can use to refer to them as well: Color   | Abbreviation | ------  | ------------ | white   | w            | green   | g            | yellow  | y            | red     | r            | blue    | be           | cyan    | c            | black   | bk           | magenta | m            |For example you can pass on the command line: `colors text:blue,failure:magenta`to have the text colored in blue and the failures in Magenta.If the `colors` option contains `whitebg` then the default colors are considered to be [`InvertedColors`](https://etorreborre.github.io/specs2/api/SPECS2-3.6.4-20151016053644-0ca99ef/index.html#org.specs2.text.Colors):Property  | Default value |--------- | ------------  |`text`    |  black        |`success` |  green        |`failure` |  magenta      |`error`   |  red          |`pending` |  blue         |`skipped` |  cyan         |`stats`   |  blue         |You can also change the color scheme that's being used on the console by implementing your own [`org.specs2.text.Colors`](https://etorreborre.github.io/specs2/api/SPECS2-3.6.4-20151016053644-0ca99ef/index.html#org.specs2.text.Colors) trait or override values in the existing `ConsoleColors` class and pass this class to the `colorsclass` argument. For example if you want to output magenta everywhere yellow is used you can write:class MyColors extends org.specs2.text.ConsoleColors {  override val failureColor = magenta}and invoke `colorsclass org.acme.MyColors`Finally note that the the color support for sbt on Windows is a bit tricky. You need to follow the instructions [here](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) then add to your script launching sbt:-Djline.terminal=jline.UnsupportedTerminal", "tags":"", "loc":"org.specs2.guide.ConsoleOutput.html"},
{"title":"Selection", "text":"Many specifications are written incrementally. You specify a little bit then you implement the application. When you go through this \"Specify-Implement-Execute\" cycle it is useful to be able to focus on just one example, the one you are currently working on. The `ex` argument is what you need (`ex` stands for \"example\"):sbt> testOnly *MySpecification* -- ex containsThe command above will execute any example which description matches the regular expression `.*contains.*` (which means that you can pass regular expressions in general). If you want to match a few words you will need to use double quotes:sbt> testOnly *MySpecification* -- ex \"contains hello\" sequential Use tagsTags can be used in a Specification to include or exclude some examples or a complete section of fragments from the execution. Let's have a look at one example: class TaggedSpecification extends Specification { def is = s2\"\"\" this is some introductory text  and the first group of examples  example 1 $success                         ${tag(\"feature1\", \"unit\")}  example 2 $success                         ${tag(\"integration\")}  and the second group of examples           ${section(\"checkin\")}  example 3 $success  example 4 $success                         ${section(\"checkin\")}                                             \"\"\"  }In that specification we are defining several tags and sections:* `feature 1` is a tag that is applied to `example1` (the _preceding_ Fragment)* `feature 2` is a tag that is applied to `example2` (the _preceding_ Fragment)* `checkin` marks a section which goes from the Text `and the second group of examples` to `example 4`Armed with this, it is now easy to include or exclude portions of the specification at execution time:* `include feature1` will only include `example 1`* `exclude integration` will include everything except `example 2`* `include checkin,unit` will include anything having either `checkin` OR `unit`: i.e. `example 1` and the second group of examples (`example 3` and `example 4`)* `include feature1 && unit` will include anything having `feature1` AND `unit`: i.e. `example 1`* `include feature1 && unit, checkin` will include anything having `feature1` AND `unit`, OR having `checkin`: i.e. `example 1`, `example 3`, `example4` In a unit specificationA _unit_ specification will accept the same `tag` and `section` methods but the behavior will be slightly different: import org.specs2.mutable._class TaggedSpecification extends Specification {  \"this is some introductory text\" >> {    \"and the first group of examples\" >> {      tag(\"feature 1\", \"unit\")      \"example 1\" in success      \"example 2\" in success    }  }  section(\"checkin\")  \"and the second group of examples\" >> {    \"example 3\" in success    \"example 4\" in success  }  section(\"checkin\")  \"and the last group of examples\" >> {    \"example 5\" in success    \"example 6\" in success  }}For that specification above: * when the `tag` call is inserted on a new line, the tagged fragment is the one just _after_ the tag method call: `example 1` is tagged with `feature1 and unit`, * when the `tag` is appended to an example, it applies to that example: `example 2` is tagged with `integration` * when the `section` call is inserted on a new line, this opens a section for all the following fragments. This should be closed by a corresponding `section` call on a new line. For example, `example 3` and `example 4` are part of the \"checkin\" section * when the `section` call is appended to a block of Fragments on the same line, all the fragments of that block are part of the section: `example 5` and `example 6` are tagged with `slow` `Always` tagSome specifications need to have `Steps` which will always be included whatever tags are specified on the command line. This is the case when defining a  with setup/teardown steps: trait DatabaseSpec extends Specification {  override def map(fs: =>Fragments) =    step(\"startDb\")  tag(AlwaysTag)     fs     step(\"cleanDb\")  tag(AlwaysTag)} Select failed examplesAnother frequent mode of selection is the selection based on previous execution. Generally we want to re-execute only what was broken before. For this, using the `was` argument on the command-line:sbt> testOnly *MyFailedSpecification* -- was xOn the line above `x` is the status of the previous example. Here is a table of all the flags you can use:  Flag | Description ----- | ------------  `+`  | successful example  `x`  | failed example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `1`  | statisticsThis selection works because specs2 stores the state of each specification in a directory after a run (`target/specs2-reports/stats` by default). If you decide that this storing is useless and you want to skip it you can use the `neverstore` argument. Otherwise if you want to make sure that the `stats` directory doesn't become too big over time you can use the `resetstore` argument which will remove the current store before running the specification. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - learn how to  - consult the  for a list of all arguments</div>", "tags":"", "loc":"org.specs2.guide.Selection.html"},
{"title":"Standard results", "text":"The specs2  guide introduces matchers to create expectations but you can use other kinds of predefined results to implement your examples. Boolean resultsThis is the simplest kind of result you can define for an expectation but also the least expressive! It can be useful for simple expectations but a failure will give few information on what went wrong: new mutable.Specification {  \"this example is ok\" >> {    1 == 1  }  \"this one is not\" >> {    // fails with 'the value is false'...    1 == 2  }}Not only that but in unit specification no exception will be thrown so you need to `&&` and `||` operators to connect your assertions if they span several lines. Standard resultsSome other results will give you an additional piece of meaning:`success` when your example is ok`failure` when your example is incorrect`anError` when an exception occurs`skipped` when you want to skip the example. You can add a more specific message with `skipped(\"because it just doesn't work in these conditions\")``pending` usually means \"not implemented yet\", but you can add a more specific message with `pending(\"because I don't have time for this\")`Two additional results are also available to track the progress of features:`done` a `Success` with the message \"DONE\"`todo` a `Pending` with the message \"TODO\" Skipping an exampleIf you already have some code for your example, adding `skipped` at the end to skip it is not very effective: - there is a possibility that the code throws an exception - the code will be executed which will waste resourcesWhat you want in that case in to skip the whole block:s2\" this example *must* be skipped $e1\"  def e1 = skipped {    // whatever code is in there, it will not be executed and the result will be skipped    throw new Exception(\"uh-oh\")    1 === 1  } Setting an example as PendingSimilarly you can mark the example as `Pending`:s2\" this example is pending for now$e1\"  def e1 = pending {    // whatever code is in there, it will not be executed and the result will be pending    throw new Exception(\"uh-oh\")    1 === 1  } Standard `MatchResults`When combining matchers you might be expected to return a `MatchResult[_]`. There are predefined values for those too: * `ok` or `ok(message)` for a successful `MatchResult` * `ko` or `ko(message)` for a failed `MatchResult`", "tags":"", "loc":"org.specs2.guide.StandardResults.html"},
{"title":"Pending until fixed", "text":"Some examples may be temporarily failing but you may not want the entire test suite to fail just for those examples. Instead of commenting them out and then forgetting about those examples when the code is fixed, you can append `pendingUntilFixed` to the example: class SpecificationWithPendingExamples extends mutable.Specification {  \"this example fails for now\" in {    1 must_== 2  }.pendingUntilFixed  // or, with a more specific message  \"this example fails for now\" in {    1 must_== 2  }.pendingUntilFixed(\"ISSUE-123\")}The example above will be reported as `Pending` until it succeeds. Then it is marked as a failure so that you can remember to remove the `pendingUntilFixed` marker.", "tags":"", "loc":"org.specs2.guide.PendingUntilFixedExamples.html"},
{"title":"Execution", "text":" Parallel by defaultspecs2 examples are executed concurrently by default: - this makes the execution faster - it encourages to write independent examples when the result of a given example should not be influenced by othersStarting from this default you can progressively add constraints to get more control over the execution. StepsA `Step` is an action which can be executed anywhere in a specification. When you declare a `Step` like this:class StepSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  ${step(\"stop here for a second\")}  this is example 3 $ok  this is example 4 $ok\"\"\"}Then the specification will:  1. execute examples 1 and 2 in parallel  2. execute the step  3. execute examples 3 and 4 in parallelThere is no \"result\" for a step but if it throws an Exception an `Error` will be reported. This will not however stop the execution of the rest of the specification. Stop the executionYou can still control if the rest of the specification must be executed by adding some constraints on the step. For example:class StepWithStopOnErrorSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  ${step { sys.error(\"sorry!\"); \"stop here for a second\" }.stopOnError}  this is example 3 $ok  this is example 4 $ok\"\"\"}When this specification is executed examples 3 and 4 will be skipped because the step returns an `Error`. An `Error` is likely to be a fatal condition but you can use other methods to stop the execution: - `stopOnFail` stop if there is a failure in the previous examples or in the step - `stopOnSkipped` stop if there is a skipped result in the previous examples or in the step - `stopWhen(Result => Boolean)` stop if the `and`-ed result of the previous examples and the step verifies a given condition SequentialIf your specification is a list of well-ordered examples you can use the `sequential` argument to make sure that they are executed in order:class SequentialSpec extends Specification { def is = sequential  s2\"\"\"  this is example 1 $ok  this is example 2 $ok  this is example 3 $ok  this is example 4 $ok\"\"\"}Thanks to the `sequential` argument the 4 examples above will execute one after the other. ActionFinally if you want to execute \"silent\" actions, like steps, but with no impact on the sequencing of the specification, you can use an `Action`:class ActionSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  // this will only be reported if there is a failure  ${action(\"do something here\")}  this is example 3 $ok  this is example 4 $ok\"\"\"} Now learn how to... {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use  to select the examples to execute - run each example in </div> And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - add  to your specification - consult the  for a list of all arguments</div>", "tags":"", "loc":"org.specs2.guide.Execution.html"},
{"title":"Expectation description", "text":" Enhance failures messagesSome expressions using matchers might not produce very useful messages. For example: val ticketsNumber = 5// will fail with '5' is not equal to '3'ticketsNumber must be_==(3)You can improve this failure message by describing what `ticketsNumber` represents: val ticketsNumber = 5// will fail with \"the number of tickets '5' is not equal to '3'\"ticketsNumber aka \"the number of tickets\" must be_==(3)The `aka` (*also known as*) method has a few variations:* `value.aka` is a shortcut for `value aka value.toString`* `\"a\" post \"is the first letter\"` prints `a is the first letter`* `\"b\" as ((s:String) => \"a\"+s+\"c\")` prints `abc`* `Seq(1, 2, 3, 4).showAs((_:Seq[Int]).filter(isEven).mkString(\"|\"))` prints `2|4`. This one is especially useful to filter out big data structures (lists, maps, xml...) before the displaying the failure message Update the failure messageOn a `Matcher`, a `MatchResult` or a `Result` you can use `updateMessage(f: String => String)` or `setMessage(m: String)` to change the failure message. Describe an expectationAnother way to provide a description for an expectation is to use the `==>` (or `<==>`) operator:s2\"\"\"A byname function can be transformed into a strict one $e1\"\"\"def e1 = {  def byNameFunction(u: =>Unit) {}  var parameter = \"not evaluated\"  toStrictFunction1(byNameFunction){ parameter = \"evaluated\" }  \"The byname function has become a strict one\" ==> (parameter === \"evaluated\")}In the example above, testing if `parameter == \"evaluated\"` is just a way to observe what we wanted to achieve. If that doesn't work, the failure message will be[error] x The byname function has not become a strict one because 'evaluated' is not equal to 'not evaluated'", "tags":"", "loc":"org.specs2.guide.ExpectationDescription.html"},
{"title":"Specification template", "text":"On the  page we saw that there is a way to define an action which will be executed before all examples with the `BeforeAll` trait. You actually might want to create your own trait extending `BeforeAll` in order to reuse this action in more than one specification:trait DatabaseSetup extends BeforeAll {  def beforeAll = println(\"prepare database\")}class DatabaseSpecification1 extends Specification with DatabaseSetup { def is = s2\"\"\"  // do something with the database \"\"\"}How does this work? The `BeforeAll` trait overrides a method called `map` in the `SpecificationStructure` trait (a parent of `Specification`) and adds one `Step` before anything else in the specification:override def map(fs: =>Fragments): Fragments =  super.map(fs).prepend(fragmentFactory.step(beforeAll))The `map` method is indeed called every time the specification returns the list of `Fragment`s defining it. You can leverage this method and define your own \"Specification templates\": - adding some text before/after a Specification - filtering out some undesirable fragments - reformatting all text - ... And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">    You will probably need to learn a bit more about specs2   in order to modify, delete or add new \"Fragments\".</div>", "tags":"", "loc":"org.specs2.guide.SpecificationTemplate.html"},
{"title":"Print execution data", "text":" Print success dataIf an example returns returns a `Success` we just print the example name on the console but it can be interesting to also get some information about the data the example was executed with. In order to do that you can use the `updateExpected` method and pass a non-empty string with your message: \"this is an obvious example\" ! {    val i = 1    (i must_== 1).toResult.updateExpected(\"executed with \"+i)  }Let's use this method now to display the execution time for each example. Print execution timeKnowing that an example succeeded is fine but sometimes you want to display more information, like the time spent executing the example for instance, or some other state before and after each example.This can be done by using the `AroundEach` trait and updating the `Result` of the example execution with whatever you want to display: trait Timed extends AroundEach {  def around[T : AsResult](t: =>T): Result = {    // use `ResultExecution.execute` to catch possible exceptions    val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))    // update the result with a piece of text which will be displayed in the console    result.updateExpected(\"Execution time: \"+timer.time)  }  /** mesure the execution time of a piece of code */  def withTimer[T](t: =>T): (T, SimpleTimer) = {    val timer = (new SimpleTimer).start    val result = t    (result, timer.stop)  }}When you execute a specification mixing the `Timed` trait you should see the timing of each example displayed in the console:[info] TimedExecutionSpecification[info][info] + example 1[info] Execution time: 94 ms[info] + example 2[info] Execution time: 11 msNote that this is just an example. The same functionality is actually accessible with the [`showtimes` argument](). With the example descriptionMore generally, you can both use the example description and the example body to display custom messages. To do this you need to intercept the creation of examples by creating a new `FragmentFactory`: // a trait to create an Around context using the example descriptiontrait TimedContext {  def context(exampleDescription: String) = new Timed(exampleDescription)  case class Timed(exampleDescription: String) extends Around {    def around[T : AsResult](t: =>T): Result = {      val (result, timer) = withTimer(ResultExecution.execute(AsResult(t)))      result.updateExpected(s\"Execution time for example $$exampleDescription: $${timer.time}\")    }    def withTimer[T](t: =>T): (T, SimpleTimer) = {      val timer = (new SimpleTimer).start      val result = t      (result, timer.stop)    }  }}class TimedSpecification extends Specification with TimedContext { def is = s2\"\"\" Example 1 $ok Example 2 $ok\"\"\"  // create a new DefaultFragmentFactory where the body of the example uses  // the current example description  override lazy val fragmentFactory = new DefaultFragmentFactory {    override def example[T : AsResult](description: String, t: =>T): Fragment =      super.example(description, context(description)(AsResult(t)))  }}", "tags":"", "loc":"org.specs2.guide.PrintExecutionData.html"},
{"title":"Pending until fixed", "text":"Some examples may be temporarily failing but you may not want the entire test suite to fail just for those examples. Instead of commenting them out and then forgetting about those examples when the code is fixed, you can append `pendingUntilFixed` to the example: class SpecificationWithPendingExamples extends mutable.Specification {  \"this example fails for now\" in {    1 must_== 2  }.pendingUntilFixed  // or, with a more specific message  \"this example fails for now\" in {    1 must_== 2  }.pendingUntilFixed(\"ISSUE-123\")}The example above will be reported as `Pending` until it succeeds. Then it is marked as a failure so that you can remember to remove the `pendingUntilFixed` marker.", "tags":"", "loc":"org.specs2.guide.PendingUntilFixedExamples.html"},
{"title":"Multiline descriptions", "text":"In a `s2` string the description of an example is taken as all the text having the same indentation before the example body:s2\"\"\"  This is the introduction paragraph  Which presents the examples    the first example has one line $ok    the second example has    more than one line             $ok\"\"\"This printsThis is the introduction paragraphWhich presents the examples  + the first example has one line  + the second example has    more than one lineIf you want the example description to be unevenly aligned you can use a margin `|`:s2\"\"\"  This is the introduction paragraph  Which presents the examples    |this example has a very    | very very    |   specific indentation $ok\"\"\"This printsThis is the introduction paragraphWhich presents the examples  + this example has a very     very very       specific indentation", "tags":"", "loc":"org.specs2.guide.MultilineDescriptions.html"},
{"title":"Lightweight specs", "text":"The default `Specification` class mixes in most of specs2 features in order to make it very easy to write your first specifications without worrying too much about where the feature resides.There at least 2 downsides to this approach:inside a `Specification` you get lots of inherited method names, encumbering the namespacemany of the traits mixed-in the `Specification` class define implicit methods and those methods have a big impact on compilation timesIt is thus possible to use another class, `org.specs2.Spec` (or `org.specs2.mutable.Spec`), which only provides the minimum number of implicits to create specifications.With the `Spec` class you can create examples and expectations with simple matchers. For example:class HelloWorldSpec extends Spec { def is = s2\"\"\" This is a specification to check the 'Hello world' string The 'Hello world' string should   contain 11 characters                                         $e1   start with 'Hello'                                            $e2   end with 'world'                                              $e3                                                                 \"\"\" def e1 = \"Hello world\" must haveSize(11) def e2 = \"Hello world\" must startWith(\"Hello\") def e3 = \"Hello world\" must endWith(\"world\")}Or, for mutable specs:class HelloWorldSpec extends mutable.Spec {  addParagraph(\"This is a specification to check the 'Hello world' string\") \"The 'Hello world' string\" should {   \"contain 11 characters\" in {     \"Hello world\" must haveSize(11)   }   \"start with 'Hello'\" in {     \"Hello world\" must startWith(\"Hello\")   }   \"end with 'world'\" in {     \"Hello world\" must endWith(\"world\")   } }}If you compare those 2 specifications with the \"HelloWorldSpec\" examples using `Specification` you will notice some differences: - you cannot write `\"Hello world\" must have size(11)` - you cannot write `\"This is a specification to check the 'Hello world' string\".txt` to add some text to a mutable specBut not all is lost! For each functionality you might want to use there is a trait which you can mix-in to get it. Adding featuresWhen creating expectations: Feature                                          | Trait                                           | Comment ------------------------------------------------ | ----------------------------------------------- | ---------------------- Use `should` for expectations                    | `org.specs2.matcher.ShouldMatchers`             | Describe expectations with `==>`                 | `org.specs2.matcher.ExpectationsDescription`    | Describe expectations with `aka` and `must`      | `org.specs2.matcher.MustExpectations`           | Use `list must have size(3)`                     | `org.specs2.matcher.TraversableMatchers`        | For each matcher you want to use after `be/have/not`, you need to mix-in the corresponding matchers trait Use matchers in `contain` or `beSome` matchers   | `org.specs2.matcher.ValueChecks`                | Use `===`, `====` to check for equality          | `org.specs2.matcher.TypedEqual`                 | Create matchers from functions                   | `org.specs2.matcher.MatchersCreation`           | Combine `MatchResults` with `and/or`             | `org.specs2.matcher.MatchResultsCombinators`    | Transform a `Matcher[T]` to `Matcher[Seq[T]]`    | `org.specs2.matcher.SequenceMatchersCreation`   | Use `forall(values)(t => t must xxx)`            | `org.specs2.matcher.SequenceMatchersCreation`   | You can combine all matchers features by using the `org.specs2.matcher.MatchersImplicits` trait Set failed expectations as Pending               | `org.specs2.execute.PendingUntilFixed`          |When creating acceptance specifications Feature                                                      | Trait                                                  | Comment ------------------------------------------------------------ | ------------------------------------------------------ | ---------------------- Interpolate anything else than a `Result` in a `s2` string   | `org.specs2.specification.create.S2StringContext`      | Use \"bang\" examples: `\"example\" ! ok`                        | `org.specs2.specification.dsl.ExampleDsl`              | Create and append `Fragments` with ``                       | `org.specs2.specification.dsl.FragmentsDsl`            | Add arguments and a title to `Fragments` with ``            | `org.specs2.specification.dsl.SpecStructureDsl`        | Create a title with `\"A title\".title\"`                       | `org.specs2.specification.dsl.TitleDsl`                | Create references to other specifications                    | `org.specs2.specification.dsl.ReferenceDsl`                 | Create steps and actions                                     | `org.specs2.specification.dsl.ActionDsl`               | Use tags                                                     | `org.specs2.specification.dsl.TagDsl`                  | To use all of the `Dsl` traits use `AcceptanceDsl`When creating mutable specifications Feature                                                      | Trait                                                  | Comment ------------------------------------------------------------ | ------------------------------------------------------ | ---------------------- Use \"bang\" examples: `\"example\" ! ok`                        | `org.specs2.specification.dsl.mutable.ExampleDsl`      | Create a title with `\"A title\".title\"`                       | `org.specs2.specification.dsl.mutable.TitleDsl`        | Set arguments                                                | `org.specs2.specification.dsl.mutable.ArgumentsDsl`    | Create references to other specifications                    | `org.specs2.specification.dsl.mutable.ReferenceDsl`         | Create steps and actions                                     | `org.specs2.specification.dsl.mutable.ActionDsl`       | Add text and paragraphs                                      | `org.specs2.specification.dsl.mutable.TextDsl`         | Use tags                                                     | `org.specs2.specification.dsl.mutable.TagDsl`          | To use all of the `Dsl` traits use `MutableDsl`", "tags":"", "loc":"org.specs2.guide.LightweightSpecs.html"},
{"title":"JUnit XML output", "text":"Many continuous integration servers (like [Jenkins](http://jenkins-ci.org)) accept JUnit XML as their de facto standard for reporting test results. You can output a JUnit XML file by simply using the `junitxml` argument: `testOnly org.acme.MySpec -- junitxml`The JUnit XML file corresponding to the specification will be produced by default in the `target/test-reports` directory. You can change this directory by passing the `junit.outdir` argument like so: `testOnly org.acme.MySpec -- junitxml junit.outdir custom_xml_folder`This will output the xml files in the `custom_xml_folder` in the top level project directory. that using `junitxml` by itself will turn off the console reporting. You need to add `console` to get it back.Note that `sbt test` does not take parameters so the default behavior is to produce the JUnit XML files for all specifications in the default output directoryIn order to change the default output directory of the junit xml files when running the tests with `test`, add the following to your sbt build file: `testOptions in Test += Tests.Argument(\"junitxml\", \"junit.outdir\", \"custom_xml_folder\")`Note that this will suppress the console output, which may be what you want if this is a configuration for a build machine. To re-enable console output, use instead:  testOptions in Test ++= Seq(    Tests.Argument(\"junitxml\", \"junit.outdir\", \"custom_xml_folder\"),    Tests.Argument(\"console\") ) ", "tags":"", "loc":"org.specs2.guide.JUnitXmlOutput.html"},
{"title":"Isolation", "text":"Unit specifications allow to nest blocks, as if they were different contexts, going from the more general to the more specific. It can be very tempting, for some applications, to include some mutable state representing data in more and more specific contexts. However, this can be problematic because: - you have to reset the state for each example in a sequential specification - you will have concurrency issues for a concurrent oneOne way to avoid this is to execute each example in its own instance of the specification. Isolated variablesThe `isolated` argument duplicates the body of each example so that it is executed in a brand new instance of the Specification: class IsolatedSpec extends mutable.Specification {  isolated  \"Java Properties can store configuration properties\" >> {    // empty properties context    val props = new Properties    \"we can add a property\" >> {      props.setProperty(\"p1\", \"v1\")      props.getProperty(\"p1\") must_== \"v1\"    }    \"we can get all the properties names\" >> {      props.setProperty(\"p1\", \"v1\")      props.setProperty(\"p2\", \"v2\")      props.propertyNames.toList must_== List(\"p1\", \"p2\")    }    \"Properties can be stored\" >> {      // non-empty properties context      props.setProperty(\"p1\", \"v1\")      props.setProperty(\"p2\", \"v2\")      \"to an OutputStream\" >> {        val out = new ByteArrayOutputStream        props.store(out, \"to stream\")        out.size() must be_>(0)      }      \"to a Writer\" >> {        val out = new ByteArrayOutputStream        val writer = new PrintWriter(out)        props.store(writer, \"to writer\")        out.size() must be_>(0)      }    }  }}Since there is a new Specification for each example, then all the variables accessible to the example will be seen as new. InstantiationIf the specification has a constructor with parameters, they need themselves to be instantiable with a no-args constructor. For example `class AkkaSpec(system: AkkaSystem) extends Specification` can not be instantiated because `AkkaSystem` doesn't have a 0-args constructor.", "tags":"", "loc":"org.specs2.guide.Isolation.html"},
{"title":"Html output", "text":"specs2 can be used to produce HTML documentation to either: - report the execution of specifications - provide a user guide like this oneIf Markdown notation is used in the specification text and you have [Pandoc](http://johnmacfarlane.net/pandoc) installed on the command line then it will rendered in the final output. Create Html filesWhen you execute a specification with the `html` command-line argument an HTML report is created in the `target/specs2-reports` directory. It will show the status of examples (success, failure,...) and stack traces if there are any errors.You can use the following arguments to change the HTML generation: Name                         | Default value                                 | Description ---------------------------- | --------------------------------------------- | ------------------------------ `all`                        | `false`                                       | execute and report linked specifications `html.outdir`                | `target/specs2-reports`                       | output directory `html.template`              | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`             | `Map[String, String]()`                       | those variables will be replaced during template evaluation `html.nostats`               | `false`                                       | if true no stats are displayed `html.search`                | `false`                                       | add a search box to the generated files `html.toc`                   | `false`                                       | add a table of contents to the generated files `html.toc.entrymaxsize`      | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs`      | `true`                                        | report \"see\" references which do not correspond to any generated file Use Pandoc for Markdown[Markdown](http://commonmark.org) text is supported if [Pandoc](http://johnmacfarlane.net/pandoc) is available on the command line and if the `!pandoc` boolean flag is not set._NOTE!!!_: the currently supported version of Pandoc is 1.13.2. Name                    | Default value                                                                     | Description ----------------------- | --------------------------------------------------------------------------------- | ------------------------------ `pandoc`                | `true`                                                                            | set to `false` by passing `!pandoc` `pandoc.exec`           | `pandoc`                                                                          | path to the Pandoc executable `pandoc.inputformat`    | `markdown+pipe_tables+auto_identifiers+header_attributes+inline_code_attributes`  | pandoc arguments (see the Pandoc [user guide](http://johnmacfarlane.net/pandoc/README.html)) `pandoc.outputformat`   | `html`                                                                            | Use a different templateYou can change the overall structure of the html page for a specification by providing a different template with the `html.template` variable. When using your custom template the following variables will be replaced: Name                    | Description ----------------------- | ------------------------------ `$title$`             | specification title `$issues$`            | true if there are issues in the specification `$body$`              | the specification bodyYou can also pass your own variables by passing a map `name1=value1,name2=value2,...` to the `html.variables` argument. Those variables can then be used in the template: - by enclosing them in `$`: `$myVariable$` - by using the `if/else/endif` construct:$if(issues)$<h1>Failed! $title$$else$<h1>$title$</h1>$endif$ Use other CSS/Javascript filesCustom CSS and JavaScript files can be used without changing the template. In order to do this just put your own `specs2-user.css` file in `src/test/resources/css` or your own `specs2-user.js` file in `src/test/resources/javascript`. Create an indexHere is something you can do to automatically create an index page for your specifications: import org.specs2._import specification.core._import runner.SpecificationsFinder._class index extends Specification { def is =  examplesLinks(\"Example specifications\")  // see the SpecificationsFinder trait for the parameters of the 'specifications' method  def examplesLinks(t: String) =    t.title     Fragments.foreach(specifications())(s => link(s)  br)}The specification above creates an index.html file in the `target/specs2-reports` directory. The specifications method creates specifications using the following parameters: Name                    | Default                                       | Description ----------------------- | --------------------------------------------  | ---------------- `glob`                  | `**/*.scala`                                  | glob pattern to filter specification files `pattern`               | `.*Spec`                                      | pattern to use when trying to retrieve the specification names from the source files `filter`                | `(name: String) => true`                      | function to keep only some specifications depending on their name `basePath`              | `src/test/scala`                              | the path where to start the search `verbose`               | `false`                                       | boolean indicating if information about finding files and specifications must be printed `classLoader`           | `Thread.currentThread.getContextClassLoader`  | classloader used to load the specification classes `filePathReader`        | `org.specs2.io.FileSystem`                    | object used to read source files", "tags":"", "loc":"org.specs2.guide.HtmlOutput.html"},
{"title":"For loops", "text":"It is very tempting to use `foreach` to create examples or results from a sequence of values:(1 to 3).foreach(i => \"example \"+i ! { i must_== i })The problem with `foreach` is that the return value of the expression above is `Unit`. So you won't be able to use it in an acceptance specification or a mutable one. A list of examplesWhen we want to create a list of examples we need to return a `Fragments` object. The long-winded way to do so is to use a `foldLeft`:(1 to 3).foldLeft(Fragments.empty)((res, i) => res.append(\"example \"+i ! { i must_== i }))Or, a bit fancier with Scalaz:// Fragments has a Monoid so you can use the foldMap method  (1 to 3).toList.foldMap(i => Fragments(\"example \"+i ! { i must_== i }))Because this is a recurring pattern there are two methods encapsulating it:// when the function only returns a Fragment  Fragment.foreach(1 to 3)(i => \"example \"+i ! { i must_== i }): Fragments  // when the function returns a Fragments object  Fragments.foreach(1 to 3) { i =>    \"examples for \"+i  br    \"1 + \"+i ! { (1 + i) must_== (i + 1) }  br    \"2 + \"+i ! { (2 + i) must_== (i + 2) }  }: FragmentsNow you can create a list of examples inside a \"should\" block in a mutable specification:class MySpec extends mutable.Specification {  \"this block should have lots of examples\" >> {    Fragment.foreach(1 to 1000) { i =>      \"example \"+i ! { i must_== i }    }  }} A list of resultsThe same situation happens when you want to create a list of expectations inside an example:class MySpec extends mutable.Specification {  \"this example has a lot of expectations\" >> {    Result.foreach(1 to 1000) { i =>      i must_== i    }  }}In that case the `Result.foreach` method is the one to use, it returns a `Result` that is the logical `and` of all results. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">   read about theunderstand why the `Result.foreach` method uses the </div>", "tags":"", "loc":"org.specs2.guide.ForLoops.html"},
{"title":"Example description", "text":"[\"Don't repeat yourself\"](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself) mandates that the same information is not repeated twice.However this situation happens when part of an example description is reused in the example body: s2\"\"\"  1971-01-01 is a correct date $correct\"\"\"  def correct = { \"1971-01-01\" must beCorrect } Use the example descriptionYou can avoid this by creating the example body as a function using the description string: s2\"\"\" 1971-01-01 is a correct date $correct\"\"\"  def correct = { date: String =>    date.split(\" \")(0) must beCorrect  } Parse the example description Delimited valuesWe can reuse the `StepParsers` presented in the  to extract the values we wish to use: s2\"\"\" {1971-01-01} is a correct date $correct {1} plus {1} is {2}            $addition\"\"\"  import org.specs2.specification.script.StepParsers._  def correct = extract { date: String =>    date must beCorrect  }  def addition = extract { (a: String, b: String, c: String) =>    a.toInt + b.toInt must_== c.toInt  }The values to be extracted are delimited by `{}` and those curly braces will not be displayed when the specification is reported. Standard delimited parsersWhen you parse values with `extract` you get only Strings which you have to transform into `Int` for example. specs2 comes up with a few predefined parsers to help you with that: s2\"\"\" {1} plus {1} is {2}            $addition\"\"\"  import org.specs2.specification.script.StandardDelimitedStepParsers._  def addition = threeInts.map { case (a, b, c) =>    a + b must_== c  }The other parsers are: parser        | description ------------- | ----------- `anInt`       | return a `Int` `twoInts`     | return a pair `(Int, Int)` `threeInts`   | return a triple `(Int, Int, Int)` `aDouble`     | return a `Double` `twoDoubles`  | return a pair `(Double, Double)` `threeDoubles`| return a triple `(Double, Double, Double)` `aString`     | return a `String` `twoStrings`  | return a pair `(String, String)` `threeStrings`| return a triple `(String, String, String)` Regular expressionsAnother way to extract values is to use regular expressions to extract similar groups of values. In that case no delimiters are required. For example: s2\"\"\" 1971-01-01 is a correct date $correct 1 plus 1 is 2                $addition\"\"\"  import org.specs2.specification.script.StepParsers._  // groupAs is equivalent to running 'regexp findAllIn text'  // and getting one argument per match group found  def correct = groupAs(\"[ ]+\").and { date: String =>    date must beCorrect  }  def addition = groupAs(\"\\d+\").and { (a: String, b: String, c: String) =>    a.toInt + b.toInt must_== c.toInt  } Standard regexp parsersSimilarly to delimited parsers, there are some predefined regexp parsers: s2\"\"\" 1 plus 1 is 2            $addition\"\"\"  import org.specs2.specification.script.StandardRegexStepParsers._  def addition = threeInts.map { case (a, b, c) =>    a + b must_== c  }", "tags":"", "loc":"org.specs2.guide.ExampleDescription.html"},
{"title":"Expectation description", "text":" Enhance failures messagesSome expressions using matchers might not produce very useful messages. For example: val ticketsNumber = 5// will fail with '5' is not equal to '3'ticketsNumber must be_==(3)You can improve this failure message by describing what `ticketsNumber` represents: val ticketsNumber = 5// will fail with \"the number of tickets '5' is not equal to '3'\"ticketsNumber aka \"the number of tickets\" must be_==(3)The `aka` (*also known as*) method has a few variations:* `value.aka` is a shortcut for `value aka value.toString`* `\"a\" post \"is the first letter\"` prints `a is the first letter`* `\"b\" as ((s:String) => \"a\"+s+\"c\")` prints `abc`* `Seq(1, 2, 3, 4).showAs((_:Seq[Int]).filter(isEven).mkString(\"|\"))` prints `2|4`. This one is especially useful to filter out big data structures (lists, maps, xml...) before the displaying the failure message Update the failure messageOn a `Matcher`, a `MatchResult` or a `Result` you can use `updateMessage(f: String => String)` or `setMessage(m: String)` to change the failure message. Describe an expectationAnother way to provide a description for an expectation is to use the `==>` (or `<==>`) operator:s2\"\"\"A byname function can be transformed into a strict one $e1\"\"\"def e1 = {  def byNameFunction(u: =>Unit) {}  var parameter = \"not evaluated\"  toStrictFunction1(byNameFunction){ parameter = \"evaluated\" }  \"The byname function has become a strict one\" ==> (parameter === \"evaluated\")}In the example above, testing if `parameter == \"evaluated\"` is just a way to observe what we wanted to achieve. If that doesn't work, the failure message will be[error] x The byname function has not become a strict one because 'evaluated' is not equal to 'not evaluated'", "tags":"", "loc":"org.specs2.guide.ExpectationDescription.html"},
{"title":"Execution", "text":" Parallel by defaultspecs2 examples are executed concurrently by default: - this makes the execution faster - it encourages to write independent examples when the result of a given example should not be influenced by othersStarting from this default you can progressively add constraints to get more control over the execution. StepsA `Step` is an action which can be executed anywhere in a specification. When you declare a `Step` like this:class StepSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  ${step(\"stop here for a second\")}  this is example 3 $ok  this is example 4 $ok\"\"\"}Then the specification will:  1. execute examples 1 and 2 in parallel  2. execute the step  3. execute examples 3 and 4 in parallelThere is no \"result\" for a step but if it throws an Exception an `Error` will be reported. This will not however stop the execution of the rest of the specification. Stop the executionYou can still control if the rest of the specification must be executed by adding some constraints on the step. For example:class StepWithStopOnErrorSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  ${step { sys.error(\"sorry!\"); \"stop here for a second\" }.stopOnError}  this is example 3 $ok  this is example 4 $ok\"\"\"}When this specification is executed examples 3 and 4 will be skipped because the step returns an `Error`. An `Error` is likely to be a fatal condition but you can use other methods to stop the execution: - `stopOnFail` stop if there is a failure in the previous examples or in the step - `stopOnSkipped` stop if there is a skipped result in the previous examples or in the step - `stopWhen(Result => Boolean)` stop if the `and`-ed result of the previous examples and the step verifies a given condition SequentialIf your specification is a list of well-ordered examples you can use the `sequential` argument to make sure that they are executed in order:class SequentialSpec extends Specification { def is = sequential  s2\"\"\"  this is example 1 $ok  this is example 2 $ok  this is example 3 $ok  this is example 4 $ok\"\"\"}Thanks to the `sequential` argument the 4 examples above will execute one after the other. ActionFinally if you want to execute \"silent\" actions, like steps, but with no impact on the sequencing of the specification, you can use an `Action`:class ActionSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  // this will only be reported if there is a failure  ${action(\"do something here\")}  this is example 3 $ok  this is example 4 $ok\"\"\"} Now learn how to... {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use  to select the examples to execute - run each example in </div> And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - add  to your specification - consult the  for a list of all arguments</div>", "tags":"", "loc":"org.specs2.guide.Execution.html"},
{"title":"Debug statements", "text":"When quick and hacky `println` statements are what you want, the `Debug` trait, mixed in every `Specification`, provides useful methods: * `pp` or \"print and pass\", prints a value to the console, then returns it to be used in the rest of the expression: `graph.pp must haveSize(3)` * `pp(condition)` prints a value if a condition holds * `pp(f: T => Boolean)` prints a value if a condition on that value holds", "tags":"", "loc":"org.specs2.guide.DebugStatements.html"},
{"title":"Console output", "text":"You will get a \"console\" output whenever you run a specification from ,  or a . There are arguments you can use to change the output:  Name               | Value format            | Comments ------------------- | ----------------------- | ------------------------------------------------------------------------ `all`               | boolean                 | execute and report linked specifications (default = `false`) `xonly`             | boolean                 | only report failures and errors `showonly`          | String                  | only report some examples based on their status `failtrace`         | boolean                 | show a stack trace for failures `fullstacktrace`    | boolean                 | show a full stack trace `tracefilter`       | regexp-csv/regexp-csv   | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`        | see below               | define the parameters for the `SmartDiffs` instance for differences `diffsclass`        | class name              | use a specific instance of the `Diffs` trait `color`             | boolean                 | use colors `nocolor`           | boolean                 | don't use colors `colors`            | map                     | use different colors `colorsclass`       | class name              | use a specific instance of the `Colors` trait `showtimes`         | boolean                 | show execution times for examples `indentation`       | int                     | number of spaces to use to indent nested examples (default = 2)Some of these arguments deserve further explanations. Show onlyYou can decide what you want to _show_ in the console by using the `showonly` arguments and the following flags:  Flag | Description ----- | ------------  `+`  | successful example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `#`  | title  `1`  | statisticsFor example if you just want to show text and failures you can use `showonly -x`. And the `xonly` argument is actually a shortcut for `showonly #x!`. StackTraceFilterThe `tracefilter` argument uses include/exclude patterns to define an instance of the `org.specs2.control.StackTraceFilter` trait which will filter stacktraces. By default the `DefaultStackTraceFilter` filter will exclude lines matching the following packages: * `org.specs2` * `scalaz\\.` * `scala\\.`, `java\\.` * `sbt\\.`, `com.intellij`, `org.eclipse.jdt`, `org.junit`If this is not what you want, you can either use the `tracefilter` argument with other patterns. For example `tracefilter com.acme\com.acme.impl` will only keep traces of classes in the `com.acme` package but will reject the ones in `com.acme.impl`.Note also that the default filter also truncates the stacktrace in the middle if it is bigger than 1000 lines to avoid reports being filled by out-of-control stacktraces. If you still want to see those lines you can re-run with the `fullstacktrace` argument. DiffsWhen using the equality matcher specs2 tries to display the difference between the expected and the actual values using a class: `org.specs2.main.SmartDiffs`. There are several parameters for that class which you can specify from the command line as:sbt> testOnly -- smartdiffs show,separators,triggerSize,shortenSize,diffRatio,full Parameter          | Description ------------------ | ----------- `show`             | will not show anything (default is true) `separators`       | allows to change the separators used to show the differences (default is \"[]\") `triggerSize`      | controls the size above which the differences must be shown (default is 20) `shortenSize`      | controls the number of characters to display around each difference (default is 5) `diffRatio`        | percentage of differences above which the differences must not be shown (default is 30) `full`             | displays the full original expected and actual strings `seqTriggerSize`   | the minimum size to compute differences on Seq, Set and Maps `seqMaxSize`       | the maximum size to compute differences on Seq, Set and MapsYou can also specify your own enhanced algorithm for displaying the difference by providing an instance of the `org.specs2.main.Diffs` trait:trait Diffs {  /** @return true if the differences must be shown */  def show: Boolean  /** @return true if the differences must be shown for 2 different values */  def show(actual: Any, expected: Any): Boolean  /** @return true if the differences must be shown for 2 different sequences of values */  def showSeq(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): Boolean  /** @return true if the differences must be shown for 2 different maps */  def showMap(actual: Map[Any, Any], expected: Map[Any, Any]): Boolean  /** @return the diffs */  def showDiffs(actual: Any, expected: Any): (String, String)  /** @return the diffs for sequences with missing / added values  */  def showSeqDiffs(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): (Seq[String], Seq[String])  /** @return the diffs for sequences with missing / added values  */  def showMapDiffs(actual: Map[Any, Any], expected: Map[Any, Any]): (Seq[String], Seq[String], Seq[String])  /** @return true if the full strings must also be shown */  def showFull: Boolean} ColorsBy default, the reporting will output colors. If you're running on windows you might either: * use the [following tip](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) to install colors in the DOS console * or pass `nocolor` as a command line argumentIt is possible to set colors by passing the `colors` argument. This argument must be a list of `key:value` pairs (comma-separated) where keys are taken from this table:Property  | Default value |--------- | ------------- |`text`    |  white        |`success` |  green        |`failure` |  yellow       |`error`   |  red          |`pending` |  cyan         |`skipped` |  magenta      |`stats`   |  cyan         |All the available colors are listed here, with their corresponding abbreviation which you can use to refer to them as well: Color   | Abbreviation | ------  | ------------ | white   | w            | green   | g            | yellow  | y            | red     | r            | blue    | be           | cyan    | c            | black   | bk           | magenta | m            |For example you can pass on the command line: `colors text:blue,failure:magenta`to have the text colored in blue and the failures in Magenta.If the `colors` option contains `whitebg` then the default colors are considered to be [`InvertedColors`](https://etorreborre.github.io/specs2/api/SPECS2-3.6.4-20151016053644-0ca99ef/index.html#org.specs2.text.Colors):Property  | Default value |--------- | ------------  |`text`    |  black        |`success` |  green        |`failure` |  magenta      |`error`   |  red          |`pending` |  blue         |`skipped` |  cyan         |`stats`   |  blue         |You can also change the color scheme that's being used on the console by implementing your own [`org.specs2.text.Colors`](https://etorreborre.github.io/specs2/api/SPECS2-3.6.4-20151016053644-0ca99ef/index.html#org.specs2.text.Colors) trait or override values in the existing `ConsoleColors` class and pass this class to the `colorsclass` argument. For example if you want to output magenta everywhere yellow is used you can write:class MyColors extends org.specs2.text.ConsoleColors {  override val failureColor = magenta}and invoke `colorsclass org.acme.MyColors`Finally note that the the color support for sbt on Windows is a bit tricky. You need to follow the instructions [here](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) then add to your script launching sbt:-Djline.terminal=jline.UnsupportedTerminal", "tags":"", "loc":"org.specs2.guide.ConsoleOutput.html"},
{"title":"Capture snippets", "text":"It is possible to include pieces of code in your documentation with the `org.specs2.specification.Snippets` trait using the `snippet` method to capture a block code with marker comments to delimit the parts you want to show.What does this look like? SnippetHere is an example of using the `snippet` method:s2\"\"\"This is a multi-line string with a code snippet: ${ snippet {def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))factorial(3) == 6}}\"\"\"When you use the `snippet` method, the reports will show:This is a multi-line string with a code snippet:def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))factorial(3) == 6 CutsSince snippets are compiled code, you might have to include many declarations, like imports or variables definitions to make the code compile. This can make your documentation more verbose than necessary so you can hide those definitions by delimiting the code to show with some comments of the form `// 8<--`:s2\"\"\"This is a snippet of code with one relevant line: ${ snippet {// 8<--def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))// 8<--factorial(3) == 6// 8<--}}\"\"\"The snippet above will only show `factorial(3) == 6`. You can repeat this pattern several times:s2\"\"\"This is a snippet of code with 2 relevant lines: ${ snippet {// 8<--def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))// 8<--factorial(3) == 6// 8<--val n = 4// 8<--factorial(n) == 24}}\"\"\"This just displays:factorial(3) == 6factorial(n) == 24 EvaluationBy default the last value of a Snippet is not shown but you can display it with the `eval` method:s2\"\"\"This is a snippet of code with a result: ${ snippet {factorial(3)}.eval}\"\"\"This displays:factorial(3)> 6 OffsetsIt is possible to adjust the margin of captured source code by adding or removing whitespace:s2\"\"\"This is a snippet of code with a negative offset to align the code to the border of the screen: ${ snippet {   def factorial(n: Int): Int = if (n == 1) n else (n * factorial(n - 1))   factorial(3)}.offsetIs(-3)}\"\"\"This displays:factorial(3) ParametersAll of the settings above: cuts, offset,... are coming from an implicit `SnippetParams` object that is changing the behavior of the created Snippets. You can choose, for a given scope, to replace these parameters with other ones and simply shadow the default parameters with your own, for example to always evaluate the snippets results:implicit snippetParams = SnippetParams(eval = true)The parameters you can set are:name              | description----------------- | ---------------- `trimExpression` | function that is trimming the expression from newlines or accolades `cutter`         | function to remove parts which must not be shown `asCode`         | function to render the resulting text (as Markdown for example) `prompt`         | function to display the evaluated result with a prompt `eval`           | boolean indicating if a snippet must be evaluated `verify`         | function checking the snippet value", "tags":"", "loc":"org.specs2.guide.CaptureSnippets.html"},
{"title":"Scopes", "text":" ScopeThe techniques described in  are not always applicable to unit specifications where we want examples to be a \"block\" of code described by some text. Instead of creating a case class we can instantiate a trait which will hold a \"fresh\" state:class ContextSpec extends mutable.Specification {  \"this is the first example\" in new trees {    tree.removeNodes(2, 3) must have size(2)  }  \"this is the first example\" in new trees {    tree.removeNodes(2, 3, 4) must have size(1)  }}/** the `trees` context */trait trees extends Scope {  val tree = new Tree(1, 2, 3, 4)}Each example of that specification gets a new instance of the `trees` trait. So it will have a brand new `tree` variable and even if this data is mutated by an example, other examples will be isolated from these changes.Now you might wonder why the `trees` trait is extending the `org.specs2.specification.Scope` trait? The reason is that the body of an Example only accepts objects which are convertible to a `Result`. By extending `Scope` we can take advantage of an implicit conversion provided by the `Specification` trait to convert our context object to a `Result`. Before / AfterIt is also possible to extend Scopes with `Before`, `After`, `BeforeAfter` traits but they need to be `org.specs2.mutable.Before`, `org.specs2.mutable.After` and `org.specs2.mutable.BeforeAfter` traits. This is necessary because those traits extend the Scala `DelayedInit` trait allowing to insert code around the execution of the body of an object.<img src=\"images/icon_failure_sml.gif\"/> Do not use an abstract class instead of a trait when using `Before`, `After` or `BeforeAfter`. This will lead to the [execution of a the \"delayed init\" code twice](http://stackoverflow.com/questions/21154941/specs2-after-method-runs-before-the-example)! And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - \"isolate\" examples using the  - print </div>", "tags":"", "loc":"org.specs2.guide.Scopes.html"},
{"title":"Context objects", "text":"In the  section we have seen how to create contexts for each example in a specification. Whilst you generally want to group all the examples having the same kind of setup in the same specification, this is not always the case. So if you have a situation where you just need to create a \"local\" context for just a few examples here is what you can do. Use case classesIn an acceptance specification you can simply use case classes to get a \"fresh\" context on some examples: class ContextSpec extends Specification { def is = s2\"\"\"  this is the first example                          ${trees().e1}  this is the second example                         ${trees().e2}\"\"\"  case class trees() {    val tree = createATreeWith4Nodes    // each example has access to a brand new tree object    def e1 = tree.removeNodes(2, 3) must have size(2)    def e2 = tree.removeNodes(2, 3, 4) must have size(1)  }}If you also want to include some setup/cleanup behavior you can use the `Before` or `After` traits (or `BeforeAfter` or `Around`): class ContextSpec extends Specification { def is = s2\"\"\"  this is the first example                          ${trees().e1}  this is the second example                         ${trees().e2}\"\"\"  case class trees() extends specification.After {    lazy val tree = getATreeWith4NodesFromTheDatabase    // you need to define the \"after\" method    def after = cleanupDB()    // this is equivalent to: def e1 = this.apply { ... }    def e1 = this { tree.removeNodes(2, 3) must have size(2) }    def e2 = this { tree.removeNodes(2, 3, 4) must have size(1) }  }}As you can see the `Before`, `After`,... traits are very similar to their `BeforeEach`, `AfterEach`,... counterparts. One good thing about this technique is that each example has access to the current state being set (a bit like when using the `ForEach` trait). Context objectA slightly different technique consists in creating an object extending `Before`, `After`, `BeforeAfter` or `Around` so that you can reuse it independently of examples:object http extends Around {  def around[T : AsResult](t: =>T) = openHttpSession(\"test\") {    AsResult(t)  // execute t inside a http session  }}s2\"\"\"this is a first example where the code executes inside a http session ${http(e1)}and another one                                                       ${http(e2)}\"\"\"def e1 = ok // do somethingdef e2 = ok // here tooThis works because each \"context\" object has an `apply` method taking `R : AsResult` and returning `Result`.Finally a last kind of \"context\" object, a `Fixture` can be used to inject some state:val evenNumbers = new Fixture[Int] {  def apply[R : AsResult](f: Int => R) = {    // test f with 1, 2, 3    Seq(1, 2, 3).foldLeft(Success(): Result) { (res, i) =>      res and AsResult(f(i))    }  }}s2\"even numbers can be divided by 2  $e1\"def e1 = evenNumbers { i: Int => i % 2 === 0 }", "tags":"", "loc":"org.specs2.guide.ContextObjects.html"},
{"title":"Run in shell", "text":"It is not necessary to use a build tool to run a specification. You just need to have the right dependencies on the classpath and use of of specs2 \"runners\". DependenciesWhen you use a build tool you generally only need to specify the main dependencies then the transitive dependencies will be fetched for you. In addition to the scala jars and  you might need the following jars (in sbt notation): Dependency                                                                             | Comment -------------------------------------------------------------------------------------- | --------------------------- `\"org.scalaz\" %% \"scalaz-core\" % \"7.1.1\"`                                              | mandatory `\"org.scalaz\" %% \"scalaz-concurrent\" % \"7.1.1\"`                                        | mandatory `\"org.scalaz.stream\" %% \"scalaz-stream\" % \"0.6a\"`                                      | mandatory `\"com.chuusai\" %% \"shapeless\" % \"2.0.0\"`                                               | if you use the GWT trait `\"org.scalacheck\" %% \"scalacheck\" % \"1.12.1\"`                                          | if using ScalaCheck `\"org.mockito\" % \"mockito-core\" % \"1.9.5\"`                                             | if using Mockito. Note: specs2.jar must be placed before mockito.jar on the classpath `\"org.hamcrest\" % \"hamcrest-core\" % \"1.3\"`                                             | if using Hamcrest matchers with Mockito `\"junit\" % \"junit\" % \"4.11\"`                                                           | if using JUnit `\"org.specs2\" % \"classycle\" % \"1.4.1\"`                                                 | if using the `org.specs2.specification.Analysis` trait `\"org.scala-lang\" % \"scala-reflect\" % \"2.10.4\"`                                        | if using interpolated specifications and/or macro matchers `compilerPlugin(\"org.scalamacros\" %% \"paradise\" % \"2.0.0\" cross CrossVersion.full)`    | if using macro matchers and Scala 2.10 `\"org.scalamacros\" %% \"quasiquotes\" % \"2.0.0\"`                                         | if using macro matchers and Scala 2.10 Resolvers                                                                              | Comment -------------------------------------------------------------------------------------- | --------------------------- `Resolver.sonatypeRepo(\"releases\")`                                                    | for other Scala libraries From the shellThe `specs2.run` object can be used to run a specification from the shell. The first argument is expected to be the class name:home> java -cp ... specs2.run org.acme.MySpec xonly From the scala consoleThe `specs2.run` object also has an `apply` method to execute specifications from the Scala console:scala> specs2.run(spec1, spec2)If you want to pass specific arguments you can import the `specs2.arguments` object member functions:scala> import specs2.arguments._scala> specs2.run(spec1)(nocolor)Or you can set implicit arguments which will be used for any specification execution:scala> import specs2.arguments._scala> implicit val myargs = nocolorscala> specs2.run(spec1) Files RunnerThe `specs2.files` object will, by default, select and execute all Specifications found in the test source directory according to the following parameters:Name                    | Default value       | Description----------------------- | ------------------- | -----------`filesrunner.basepath`  | `src/test/scala`    | source directory for test files`filesrunner.path`      | `**/*.scala`        | glob pattern for the file paths`filesrunner.pattern`   | `.*Spec`            | regular expression for the specification class/object name OutputsBy default the `specs2.run` and `specs2.files` runners will output their results to the console but you can also use other printers as described in the  section.", "tags":"", "loc":"org.specs2.guide.RunInShell.html"},
{"title":"Run in IDE", "text":" Intellij IDEA[IntelliJ IDEA](http://www.jetbrains.com/idea/features/scala.html) is the IDE with the best specs2 integration for now. You can: * execute a specification by selecting its name and pressing `CTRL+SHIFT+F10` * execute a single example by selecting its description and pressing `CTRL+SHIFT+F10` ![specs2 in Intellij](https://etorreborre.github.io/specs2/guide/SPECS2-3.6.4-20151016053644-0ca99ef/images/intellij.png)However passing arguments needs to be done through system properties for now. So if you need to use the `xonly` argument you need to pass `-Dspecs2.xonly`. ScalaIDEThere is no integration of specs2 in [ScalaIDE](http://scala-ide.org) yet, but it is possible to execute specifications as JUnit tests:import org.specs2.runner.JUnitRunnerimport org.junit.runner.RunWith@RunWith(classOf[JUnitRunner])class MySpecification extends org.specs2.Specification { def is = s2\"\"\"  Define your specification as usual here ...\"\"\"}[*some [tricks](http://code.google.com/p/specs/wiki/RunningSpecs#Run_your_specification_with_JUnit4_in_Eclipse) described on the specs website can still be useful there when ScalaIDE struggles to find the specification classes*]", "tags":"", "loc":"org.specs2.guide.RunInIDE.html"},
{"title":"Execution", "text":" Parallel by defaultspecs2 examples are executed concurrently by default: - this makes the execution faster - it encourages to write independent examples when the result of a given example should not be influenced by othersStarting from this default you can progressively add constraints to get more control over the execution. StepsA `Step` is an action which can be executed anywhere in a specification. When you declare a `Step` like this:class StepSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  ${step(\"stop here for a second\")}  this is example 3 $ok  this is example 4 $ok\"\"\"}Then the specification will:  1. execute examples 1 and 2 in parallel  2. execute the step  3. execute examples 3 and 4 in parallelThere is no \"result\" for a step but if it throws an Exception an `Error` will be reported. This will not however stop the execution of the rest of the specification. Stop the executionYou can still control if the rest of the specification must be executed by adding some constraints on the step. For example:class StepWithStopOnErrorSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  ${step { sys.error(\"sorry!\"); \"stop here for a second\" }.stopOnError}  this is example 3 $ok  this is example 4 $ok\"\"\"}When this specification is executed examples 3 and 4 will be skipped because the step returns an `Error`. An `Error` is likely to be a fatal condition but you can use other methods to stop the execution: - `stopOnFail` stop if there is a failure in the previous examples or in the step - `stopOnSkipped` stop if there is a skipped result in the previous examples or in the step - `stopWhen(Result => Boolean)` stop if the `and`-ed result of the previous examples and the step verifies a given condition SequentialIf your specification is a list of well-ordered examples you can use the `sequential` argument to make sure that they are executed in order:class SequentialSpec extends Specification { def is = sequential  s2\"\"\"  this is example 1 $ok  this is example 2 $ok  this is example 3 $ok  this is example 4 $ok\"\"\"}Thanks to the `sequential` argument the 4 examples above will execute one after the other. ActionFinally if you want to execute \"silent\" actions, like steps, but with no impact on the sequencing of the specification, you can use an `Action`:class ActionSpec extends Specification { def is = s2\"\"\"  this is example 1 $ok  this is example 2 $ok  // this will only be reported if there is a failure  ${action(\"do something here\")}  this is example 3 $ok  this is example 4 $ok\"\"\"} Now learn how to... {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - use  to select the examples to execute - run each example in </div> And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - add  to your specification - consult the  for a list of all arguments</div>", "tags":"", "loc":"org.specs2.guide.Execution.html"},
{"title":"Selection", "text":"Many specifications are written incrementally. You specify a little bit then you implement the application. When you go through this \"Specify-Implement-Execute\" cycle it is useful to be able to focus on just one example, the one you are currently working on. The `ex` argument is what you need (`ex` stands for \"example\"):sbt> testOnly *MySpecification* -- ex containsThe command above will execute any example which description matches the regular expression `.*contains.*` (which means that you can pass regular expressions in general). If you want to match a few words you will need to use double quotes:sbt> testOnly *MySpecification* -- ex \"contains hello\" sequential Use tagsTags can be used in a Specification to include or exclude some examples or a complete section of fragments from the execution. Let's have a look at one example: class TaggedSpecification extends Specification { def is = s2\"\"\" this is some introductory text  and the first group of examples  example 1 $success                         ${tag(\"feature1\", \"unit\")}  example 2 $success                         ${tag(\"integration\")}  and the second group of examples           ${section(\"checkin\")}  example 3 $success  example 4 $success                         ${section(\"checkin\")}                                             \"\"\"  }In that specification we are defining several tags and sections:* `feature 1` is a tag that is applied to `example1` (the _preceding_ Fragment)* `feature 2` is a tag that is applied to `example2` (the _preceding_ Fragment)* `checkin` marks a section which goes from the Text `and the second group of examples` to `example 4`Armed with this, it is now easy to include or exclude portions of the specification at execution time:* `include feature1` will only include `example 1`* `exclude integration` will include everything except `example 2`* `include checkin,unit` will include anything having either `checkin` OR `unit`: i.e. `example 1` and the second group of examples (`example 3` and `example 4`)* `include feature1 && unit` will include anything having `feature1` AND `unit`: i.e. `example 1`* `include feature1 && unit, checkin` will include anything having `feature1` AND `unit`, OR having `checkin`: i.e. `example 1`, `example 3`, `example4` In a unit specificationA _unit_ specification will accept the same `tag` and `section` methods but the behavior will be slightly different: import org.specs2.mutable._class TaggedSpecification extends Specification {  \"this is some introductory text\" >> {    \"and the first group of examples\" >> {      tag(\"feature 1\", \"unit\")      \"example 1\" in success      \"example 2\" in success    }  }  section(\"checkin\")  \"and the second group of examples\" >> {    \"example 3\" in success    \"example 4\" in success  }  section(\"checkin\")  \"and the last group of examples\" >> {    \"example 5\" in success    \"example 6\" in success  }}For that specification above: * when the `tag` call is inserted on a new line, the tagged fragment is the one just _after_ the tag method call: `example 1` is tagged with `feature1 and unit`, * when the `tag` is appended to an example, it applies to that example: `example 2` is tagged with `integration` * when the `section` call is inserted on a new line, this opens a section for all the following fragments. This should be closed by a corresponding `section` call on a new line. For example, `example 3` and `example 4` are part of the \"checkin\" section * when the `section` call is appended to a block of Fragments on the same line, all the fragments of that block are part of the section: `example 5` and `example 6` are tagged with `slow` `Always` tagSome specifications need to have `Steps` which will always be included whatever tags are specified on the command line. This is the case when defining a  with setup/teardown steps: trait DatabaseSpec extends Specification {  override def map(fs: =>Fragments) =    step(\"startDb\")  tag(AlwaysTag)     fs     step(\"cleanDb\")  tag(AlwaysTag)} Select failed examplesAnother frequent mode of selection is the selection based on previous execution. Generally we want to re-execute only what was broken before. For this, using the `was` argument on the command-line:sbt> testOnly *MyFailedSpecification* -- was xOn the line above `x` is the status of the previous example. Here is a table of all the flags you can use:  Flag | Description ----- | ------------  `+`  | successful example  `x`  | failed example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `1`  | statisticsThis selection works because specs2 stores the state of each specification in a directory after a run (`target/specs2-reports/stats` by default). If you decide that this storing is useless and you want to skip it you can use the `neverstore` argument. Otherwise if you want to make sure that the `stats` directory doesn't become too big over time you can use the `resetstore` argument which will remove the current store before running the specification. And if you want to know more {.ribbon .both-ribbon}<div class=\"ribbon-content\">     - learn how to  - consult the  for a list of all arguments</div>", "tags":"", "loc":"org.specs2.guide.Selection.html"},
{"title":"Custom output", "text":"You can implement your own reporting of specs2 specifications: - using the `Notifier` trait which acts like a listener - using a `Printer` which gives you more flexibility for reporting exactly what you want - using a `Reporter` which allow you to even change the default flow for reporting specifications: selection -> execution -> printing NotifierThe `org.specs2.reporter.Notifier` trait can be used to report execution events. It notifies of the following: Event                | Description -------------------- | ----------- specification start  | the beginning of a specification, with its name specification end    | the end of a specification, with its name context start        | the beginning of a sub-level when the specification is seen as a tree or Fragments context end          | the end of a sub-level when the specification is seen as a tree or Fragments text                 | any Text fragment that needs to be displayed example start        | the beginning of an example example result       | `success / failure / error / skipped / pending`All those notifications come with a location (to trace back to the originating fragment in the Specification) and a duration when relevant (i.e. for examples).You can then using the `notifier` argument to pass the name of your custom notifier:sbt> testOnly *BinarySpec* -- notifier org.acme.reporting.FtpNotifier PrinterThe `org.specs2.reporter.Printer` trait defines how to output each fragment of the specification. The only method to implement is:def fold(env: Env, spec: SpecStructure): Fold[Fragment]So what you need to create is a `Fold` over the executing specification. What is it? A `Fold` is composed of 5 operations:trait Fold[Fragment] {  type S  def prepare: Task[Unit]  def init: S  def sink: Sink[Task, (Fragment, S)]  def fold: (Fragment, S) => S  def last(s: S): Task[Unit]} * `prepare` is a `Task` which can \"prepare\" the reporting, like creating a directory * `init` is an initial state of type `S`. By using some state you can accumulate information about the execution of the whole specification * `sink` is a scalaz-stream `Sink` which can output each `Fragment` and possibly the current state * `fold` is the function calculating the next state based on the current `Fragment` and the previous state * `last` take the last state and returns a `Task` doing the last action like reporting the final statisticsOnce you've defined your `Printer` trait you can use the `printer` argument like so:sbt> testOnly *BinarySpec* -- printer org.acme.reporting.LatexPrinter ReporterThe `org.specs2.reporter.Reporter` trait defines the full lifecycle for running specifications:// prepare the environment before any reportingdef prepare(env: Env, printers: List[Printer]): List[SpecStructure] => Action[Unit]// finalize the reporting (to save overall statistics for example)def finalize(env: Env, printers: List[Printer]): List[SpecStructure] => Action[Unit]/** * report a spec structure with the given printers * * The default implementation selects fragments to execute, executes them and uses the printers to * display results */def report(env: Env, printers: List[Printer]): SpecStructure => Action[Unit] TroubleshootingIf your custom `Notifier` or `Printer` fails to be instantiated you can re-run the execution with the `verbose` argument in order to get an error message and a stack trace.", "tags":"", "loc":"org.specs2.guide.CustomOutput.html"},
{"title":"Custom output", "text":"You can implement your own reporting of specs2 specifications: - using the `Notifier` trait which acts like a listener - using a `Printer` which gives you more flexibility for reporting exactly what you want - using a `Reporter` which allow you to even change the default flow for reporting specifications: selection -> execution -> printing NotifierThe `org.specs2.reporter.Notifier` trait can be used to report execution events. It notifies of the following: Event                | Description -------------------- | ----------- specification start  | the beginning of a specification, with its name specification end    | the end of a specification, with its name context start        | the beginning of a sub-level when the specification is seen as a tree or Fragments context end          | the end of a sub-level when the specification is seen as a tree or Fragments text                 | any Text fragment that needs to be displayed example start        | the beginning of an example example result       | `success / failure / error / skipped / pending`All those notifications come with a location (to trace back to the originating fragment in the Specification) and a duration when relevant (i.e. for examples).You can then using the `notifier` argument to pass the name of your custom notifier:sbt> testOnly *BinarySpec* -- notifier org.acme.reporting.FtpNotifier PrinterThe `org.specs2.reporter.Printer` trait defines how to output each fragment of the specification. The only method to implement is:def fold(env: Env, spec: SpecStructure): Fold[Fragment]So what you need to create is a `Fold` over the executing specification. What is it? A `Fold` is composed of 5 operations:trait Fold[Fragment] {  type S  def prepare: Task[Unit]  def init: S  def sink: Sink[Task, (Fragment, S)]  def fold: (Fragment, S) => S  def last(s: S): Task[Unit]} * `prepare` is a `Task` which can \"prepare\" the reporting, like creating a directory * `init` is an initial state of type `S`. By using some state you can accumulate information about the execution of the whole specification * `sink` is a scalaz-stream `Sink` which can output each `Fragment` and possibly the current state * `fold` is the function calculating the next state based on the current `Fragment` and the previous state * `last` take the last state and returns a `Task` doing the last action like reporting the final statisticsOnce you've defined your `Printer` trait you can use the `printer` argument like so:sbt> testOnly *BinarySpec* -- printer org.acme.reporting.LatexPrinter ReporterThe `org.specs2.reporter.Reporter` trait defines the full lifecycle for running specifications:// prepare the environment before any reportingdef prepare(env: Env, printers: List[Printer]): List[SpecStructure] => Action[Unit]// finalize the reporting (to save overall statistics for example)def finalize(env: Env, printers: List[Printer]): List[SpecStructure] => Action[Unit]/** * report a spec structure with the given printers * * The default implementation selects fragments to execute, executes them and uses the printers to * display results */def report(env: Env, printers: List[Printer]): SpecStructure => Action[Unit] TroubleshootingIf your custom `Notifier` or `Printer` fails to be instantiated you can re-run the execution with the `verbose` argument in order to get an error message and a stack trace.", "tags":"", "loc":"org.specs2.guide.CustomOutput.html"},
{"title":"Markdown output", "text":" Markdown printerThere is a simple printer for creating Markdown files based on your specifications. You simply invoke it by passing the `markdown` argument on the command line. ArgumentsThe following arguments are available to fine-tune the generation of Markdown pages Name                     | Default                         | Description ------------------------ | ------------------------------- | ----------- `markdown.outdir`        | `target/specs2-reports`         | output directory for Markdown files `markdown.ext`           | `md`                            | extension for Markdown files", "tags":"", "loc":"org.specs2.guide.MarkdownOutput.html"},
{"title":"Html output", "text":"specs2 can be used to produce HTML documentation to either: - report the execution of specifications - provide a user guide like this oneIf Markdown notation is used in the specification text and you have [Pandoc](http://johnmacfarlane.net/pandoc) installed on the command line then it will rendered in the final output. Create Html filesWhen you execute a specification with the `html` command-line argument an HTML report is created in the `target/specs2-reports` directory. It will show the status of examples (success, failure,...) and stack traces if there are any errors.You can use the following arguments to change the HTML generation: Name                         | Default value                                 | Description ---------------------------- | --------------------------------------------- | ------------------------------ `all`                        | `false`                                       | execute and report linked specifications `html.outdir`                | `target/specs2-reports`                       | output directory `html.template`              | `target/specs2-reports/templates/specs2.html` | copied from the `resources/templates` directory `html.variables`             | `Map[String, String]()`                       | those variables will be replaced during template evaluation `html.nostats`               | `false`                                       | if true no stats are displayed `html.search`                | `false`                                       | add a search box to the generated files `html.toc`                   | `false`                                       | add a table of contents to the generated files `html.toc.entrymaxsize`      | `18`                                          | maximum number of characters for an entry in the table of contents `html.warn.missingrefs`      | `true`                                        | report \"see\" references which do not correspond to any generated file Use Pandoc for Markdown[Markdown](http://commonmark.org) text is supported if [Pandoc](http://johnmacfarlane.net/pandoc) is available on the command line and if the `!pandoc` boolean flag is not set._NOTE!!!_: the currently supported version of Pandoc is 1.13.2. Name                    | Default value                                                                     | Description ----------------------- | --------------------------------------------------------------------------------- | ------------------------------ `pandoc`                | `true`                                                                            | set to `false` by passing `!pandoc` `pandoc.exec`           | `pandoc`                                                                          | path to the Pandoc executable `pandoc.inputformat`    | `markdown+pipe_tables+auto_identifiers+header_attributes+inline_code_attributes`  | pandoc arguments (see the Pandoc [user guide](http://johnmacfarlane.net/pandoc/README.html)) `pandoc.outputformat`   | `html`                                                                            | Use a different templateYou can change the overall structure of the html page for a specification by providing a different template with the `html.template` variable. When using your custom template the following variables will be replaced: Name                    | Description ----------------------- | ------------------------------ `$title$`             | specification title `$issues$`            | true if there are issues in the specification `$body$`              | the specification bodyYou can also pass your own variables by passing a map `name1=value1,name2=value2,...` to the `html.variables` argument. Those variables can then be used in the template: - by enclosing them in `$`: `$myVariable$` - by using the `if/else/endif` construct:$if(issues)$<h1>Failed! $title$$else$<h1>$title$</h1>$endif$ Use other CSS/Javascript filesCustom CSS and JavaScript files can be used without changing the template. In order to do this just put your own `specs2-user.css` file in `src/test/resources/css` or your own `specs2-user.js` file in `src/test/resources/javascript`. Create an indexHere is something you can do to automatically create an index page for your specifications: import org.specs2._import specification.core._import runner.SpecificationsFinder._class index extends Specification { def is =  examplesLinks(\"Example specifications\")  // see the SpecificationsFinder trait for the parameters of the 'specifications' method  def examplesLinks(t: String) =    t.title     Fragments.foreach(specifications())(s => link(s)  br)}The specification above creates an index.html file in the `target/specs2-reports` directory. The specifications method creates specifications using the following parameters: Name                    | Default                                       | Description ----------------------- | --------------------------------------------  | ---------------- `glob`                  | `**/*.scala`                                  | glob pattern to filter specification files `pattern`               | `.*Spec`                                      | pattern to use when trying to retrieve the specification names from the source files `filter`                | `(name: String) => true`                      | function to keep only some specifications depending on their name `basePath`              | `src/test/scala`                              | the path where to start the search `verbose`               | `false`                                       | boolean indicating if information about finding files and specifications must be printed `classLoader`           | `Thread.currentThread.getContextClassLoader`  | classloader used to load the specification classes `filePathReader`        | `org.specs2.io.FileSystem`                    | object used to read source files", "tags":"", "loc":"org.specs2.guide.HtmlOutput.html"},
{"title":"JUnit XML output", "text":"Many continuous integration servers (like [Jenkins](http://jenkins-ci.org)) accept JUnit XML as their de facto standard for reporting test results. You can output a JUnit XML file by simply using the `junitxml` argument: `testOnly org.acme.MySpec -- junitxml`The JUnit XML file corresponding to the specification will be produced by default in the `target/test-reports` directory. You can change this directory by passing the `junit.outdir` argument like so: `testOnly org.acme.MySpec -- junitxml junit.outdir custom_xml_folder`This will output the xml files in the `custom_xml_folder` in the top level project directory. that using `junitxml` by itself will turn off the console reporting. You need to add `console` to get it back.Note that `sbt test` does not take parameters so the default behavior is to produce the JUnit XML files for all specifications in the default output directoryIn order to change the default output directory of the junit xml files when running the tests with `test`, add the following to your sbt build file: `testOptions in Test += Tests.Argument(\"junitxml\", \"junit.outdir\", \"custom_xml_folder\")`Note that this will suppress the console output, which may be what you want if this is a configuration for a build machine. To re-enable console output, use instead:  testOptions in Test ++= Seq(    Tests.Argument(\"junitxml\", \"junit.outdir\", \"custom_xml_folder\"),    Tests.Argument(\"console\") ) ", "tags":"", "loc":"org.specs2.guide.JUnitXmlOutput.html"},
{"title":"Console output", "text":"You will get a \"console\" output whenever you run a specification from ,  or a . There are arguments you can use to change the output:  Name               | Value format            | Comments ------------------- | ----------------------- | ------------------------------------------------------------------------ `all`               | boolean                 | execute and report linked specifications (default = `false`) `xonly`             | boolean                 | only report failures and errors `showonly`          | String                  | only report some examples based on their status `failtrace`         | boolean                 | show a stack trace for failures `fullstacktrace`    | boolean                 | show a full stack trace `tracefilter`       | regexp-csv/regexp-csv   | comma-separated include patterns separated by `/` with exclude patterns `smartdiffs`        | see below               | define the parameters for the `SmartDiffs` instance for differences `diffsclass`        | class name              | use a specific instance of the `Diffs` trait `color`             | boolean                 | use colors `nocolor`           | boolean                 | don't use colors `colors`            | map                     | use different colors `colorsclass`       | class name              | use a specific instance of the `Colors` trait `showtimes`         | boolean                 | show execution times for examples `indentation`       | int                     | number of spaces to use to indent nested examples (default = 2)Some of these arguments deserve further explanations. Show onlyYou can decide what you want to _show_ in the console by using the `showonly` arguments and the following flags:  Flag | Description ----- | ------------  `+`  | successful example  `!`  | error example  `o`  | skipped example  `*`  | pending example  `-`  | text  `#`  | title  `1`  | statisticsFor example if you just want to show text and failures you can use `showonly -x`. And the `xonly` argument is actually a shortcut for `showonly #x!`. StackTraceFilterThe `tracefilter` argument uses include/exclude patterns to define an instance of the `org.specs2.control.StackTraceFilter` trait which will filter stacktraces. By default the `DefaultStackTraceFilter` filter will exclude lines matching the following packages: * `org.specs2` * `scalaz\\.` * `scala\\.`, `java\\.` * `sbt\\.`, `com.intellij`, `org.eclipse.jdt`, `org.junit`If this is not what you want, you can either use the `tracefilter` argument with other patterns. For example `tracefilter com.acme\com.acme.impl` will only keep traces of classes in the `com.acme` package but will reject the ones in `com.acme.impl`.Note also that the default filter also truncates the stacktrace in the middle if it is bigger than 1000 lines to avoid reports being filled by out-of-control stacktraces. If you still want to see those lines you can re-run with the `fullstacktrace` argument. DiffsWhen using the equality matcher specs2 tries to display the difference between the expected and the actual values using a class: `org.specs2.main.SmartDiffs`. There are several parameters for that class which you can specify from the command line as:sbt> testOnly -- smartdiffs show,separators,triggerSize,shortenSize,diffRatio,full Parameter          | Description ------------------ | ----------- `show`             | will not show anything (default is true) `separators`       | allows to change the separators used to show the differences (default is \"[]\") `triggerSize`      | controls the size above which the differences must be shown (default is 20) `shortenSize`      | controls the number of characters to display around each difference (default is 5) `diffRatio`        | percentage of differences above which the differences must not be shown (default is 30) `full`             | displays the full original expected and actual strings `seqTriggerSize`   | the minimum size to compute differences on Seq, Set and Maps `seqMaxSize`       | the maximum size to compute differences on Seq, Set and MapsYou can also specify your own enhanced algorithm for displaying the difference by providing an instance of the `org.specs2.main.Diffs` trait:trait Diffs {  /** @return true if the differences must be shown */  def show: Boolean  /** @return true if the differences must be shown for 2 different values */  def show(actual: Any, expected: Any): Boolean  /** @return true if the differences must be shown for 2 different sequences of values */  def showSeq(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): Boolean  /** @return true if the differences must be shown for 2 different maps */  def showMap(actual: Map[Any, Any], expected: Map[Any, Any]): Boolean  /** @return the diffs */  def showDiffs(actual: Any, expected: Any): (String, String)  /** @return the diffs for sequences with missing / added values  */  def showSeqDiffs(actual: Seq[Any], expected: Seq[Any], ordered: Boolean): (Seq[String], Seq[String])  /** @return the diffs for sequences with missing / added values  */  def showMapDiffs(actual: Map[Any, Any], expected: Map[Any, Any]): (Seq[String], Seq[String], Seq[String])  /** @return true if the full strings must also be shown */  def showFull: Boolean} ColorsBy default, the reporting will output colors. If you're running on windows you might either: * use the [following tip](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) to install colors in the DOS console * or pass `nocolor` as a command line argumentIt is possible to set colors by passing the `colors` argument. This argument must be a list of `key:value` pairs (comma-separated) where keys are taken from this table:Property  | Default value |--------- | ------------- |`text`    |  white        |`success` |  green        |`failure` |  yellow       |`error`   |  red          |`pending` |  cyan         |`skipped` |  magenta      |`stats`   |  cyan         |All the available colors are listed here, with their corresponding abbreviation which you can use to refer to them as well: Color   | Abbreviation | ------  | ------------ | white   | w            | green   | g            | yellow  | y            | red     | r            | blue    | be           | cyan    | c            | black   | bk           | magenta | m            |For example you can pass on the command line: `colors text:blue,failure:magenta`to have the text colored in blue and the failures in Magenta.If the `colors` option contains `whitebg` then the default colors are considered to be [`InvertedColors`](https://etorreborre.github.io/specs2/api/SPECS2-3.6.4-20151016053644-0ca99ef/index.html#org.specs2.text.Colors):Property  | Default value |--------- | ------------  |`text`    |  black        |`success` |  green        |`failure` |  magenta      |`error`   |  red          |`pending` |  blue         |`skipped` |  cyan         |`stats`   |  blue         |You can also change the color scheme that's being used on the console by implementing your own [`org.specs2.text.Colors`](https://etorreborre.github.io/specs2/api/SPECS2-3.6.4-20151016053644-0ca99ef/index.html#org.specs2.text.Colors) trait or override values in the existing `ConsoleColors` class and pass this class to the `colorsclass` argument. For example if you want to output magenta everywhere yellow is used you can write:class MyColors extends org.specs2.text.ConsoleColors {  override val failureColor = magenta}and invoke `colorsclass org.acme.MyColors`Finally note that the the color support for sbt on Windows is a bit tricky. You need to follow the instructions [here](http://www.marioawad.com/2010/11/16/ansi-command-line-colors-under-windows) then add to your script launching sbt:-Djline.terminal=jline.UnsupportedTerminal", "tags":"", "loc":"org.specs2.guide.ConsoleOutput.html"},
{"title":"Mutable specification syntax", "text":"The  page presents one syntax for declaring examples in a mutable specification:class MySpecification extends org.specs2.mutable.Specification {  \"this is my specification\" >> {    \"where example 1 must be true\" >> {      1 must_== 1    }    \"where example 2 must be true\" >> {      2 must_== 2    }  }}You can also use the `should/in` syntax:class MySpecification extends org.specs2.mutable.Specification {  \"this is my specification\" should {    \"have one example\" in {      1 must_== 1    }    \"and another one\" in {      2 must_== 2    }  }}<img src=\"images/icon_failure_sml.gif\"/> You might get clashes with `should` which can also be used to declare expectations on strings:class MySpecification extends org.specs2.mutable.Specification {  \"this\" should {    \"will not compile because should is overloaded\" in  {      \"a string\" should not be empty    }  }}The easiest work around in that case is to use `must` for the expectation:class MySpecification extends org.specs2.mutable.Specification {  \"this\" should {    \"compile now\" in {      \"a string\" must not be empty    }  }}", "tags":"", "loc":"org.specs2.guide.MutableSpecSyntax.html"}]};
     
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <style type="text/css" media="all">
        @import url('./../css/maven-base.css');
        @import url('./../css/maven-theme.css');
      </style>
      <link href="./../css/prettify.css" type="text/css" rel="stylesheet" />
      <script type="text/javascript" src="./../css/prettify.js"></script>
      <link rel="stylesheet" href="./../css/print.css" type="text/css" media="print" />
      <link href="./../css/tooltip.css" rel="stylesheet" type="text/css" />
      <link href="./../css/specs2-user.css" type="text/css" rel="stylesheet" />

      <script type="text/javascript" src="./../css/jquery.js"></script>
      <script type="text/javascript" src="./../css/jquery.cookie.js"></script>
      <script type="text/javascript" src="./../css/jquery.hotkeys.js"></script>
      <script type="text/javascript" src="./../css/jquery.jstree.js"></script>
      <script type="text/javascript" src="./../css/tooltip.js"></script>
      <script type="text/javascript" src="./../js/specs2-user.js"></script>
      <script language="javascript">$.getScript("./../js/specs2-user.js", initUserScript(document));</script>
      <script language="javascript">
      function init() {  prettyPrint(); };
      /* found on : http://www.tek-tips.com/faqs.cfm?fid=6620 */
      String.prototype.endsWith = function(str) { return (this.match(str+'$') == str) };
      function changeWidth(id,width) {  document.getElementById(id).style.width = width; };
      function changeMarginLeft(id, margin) { document.getElementById(id).style.marginLeft = margin; };
      function toggleImage(image) {
        if (image.src.endsWith('images/expanded.gif')) 
          image.src = image.src.replace('expanded', 'collapsed');
        else 
          image.src = image.src.replace('collapsed', 'expanded');
      };
      function showHide(id) {
        element = document.getElementById(id);
        element.style.display = (element.style.display == 'block')? 'none' : 'block';
      };
      function showHideByClass(name) {
        var elements = document.getElementsByClassName(name);
        for (i = 0; i < elements.length; i++) {
          elements[i].style.display = (elements[i].style.display == 'none') ? elements[i].style.display = '': 'none';
        }
      };
      function showByClass(name) {
        var elements = document.getElementsByClassName(name);
        for (i = 0; i < elements.length; i++) {
          elements[i].style.display = 'block';
        }
      };
      function hideByClass(name) {
        var elements = document.getElementsByClassName(name);
        for (i = 0; i < elements.length; i++) {
          elements[i].style.display = 'none';
        }
      };
      function showById(id) {
        document.getElementById(id).style.display = ''
      };
      function hideById(id) {
        document.getElementById(id).style.display = 'none'
      };
    </script>
      <script language="javascript">window.onload=init;</script>
      <!-- the tabber.js file must be loaded after the onload function has been set, in order to run the
           tabber code, then the init code -->
      <script type="text/javascript" src="./../css/tabber.js"></script>
      <link rel="stylesheet" href="./../css/tabber.css" type="text/css" media="screen" />
      <title>Matchers</title>
    </head><body><div id="breadcrumbs"><a href="../guide/org.specs2.guide.UserGuide.html">UserGuide</a><t> / </t><a href="../guide/org.specs2.guide.Matchers.html">Matchers</a></div><div class="colmask threecol">
            <div class="colmid">
              <div class="colleft">
                <div class="col1"><div id="central"><html><title>Matchers</title><a name="Matchers"><h2 specId="2046015986">Matchers</h2></a><status class="ok"><div style="display: show; text-indent:0px;"><p>There are many ways to define expectations in <strong><em>specs2</em></strong>. You can define expectations with anything that returns a <code class="prettyprint">Result</code>:</p>
<ul>
  <li>Boolean</li>
  <li>Standard result</li>
  <li>Matcher result</li>
  <li>Scalacheck property</li>
  <li>Mock expectation</li>
  <li>DataTable</li>
  <li>Forms</li>
</ul><a name="Boolean+results"><h3>Boolean results</h3></a><p>This is the simplest kind of result you can define for an expectation but also the least expressive!</p><p>Here's an example: <code class="prettyprint">&quot;This is hopefully true&quot; ! (1 != 2)</code></p><p>This can be useful for simple expectations but a failure will give few information on what went wrong: <code class="prettyprint">&quot;This is hopefully true&quot; ! (2 != 2)</code></p><a name="Standard+results"><h3>Standard results</h3></a><p>Some standard results can be used when you need specific result meanings:</p>
<ul>
  <li><code class="prettyprint">success</code>: the example is ok</li>
  <li><code class="prettyprint">failure</code>: there is a non-met expectation</li>
  <li><code class="prettyprint">anError</code>: a non-expected exception occurred</li>
  <li><code class="prettyprint">skipped</code>: the example is skipped possibly at runtime because some conditions are not met. A more specific message can<br />be created with <code class="prettyprint">Skipped(&quot;my message&quot;)</code></li>
  <li><code class="prettyprint">pending</code>: usually means &quot;not implemented yet&quot;, but a specific message can be created with <code class="prettyprint">Pending(&quot;my message&quot;)</code></li>
</ul><p>Two additional results are also available to track the progress of features:</p>
<ul>
  <li><code class="prettyprint">done</code>: a <code class="prettyprint">Success</code> with the message &quot;DONE&quot;</li>
  <li><code class="prettyprint">todo</code>: a <code class="prettyprint">Pending</code> with the message &quot;TODO&quot;</li>
</ul><a name="Combinators"><h4>Combinators</h4></a><p>Logical combinators like <code class="prettyprint">and</code>, <code class="prettyprint">or</code>, <code class="prettyprint">not</code> can be used to combine results. You can also use the <code class="prettyprint">eventually</code> method to retry a Result until it is ok (this will actually work with anything convertible to a Result).</p><a name="Match+results"><h3>Match results</h3></a><p>This is by far the largest category of Results in <strong><em>specs2</em></strong>. They cover many data types, can be composed and adapted to create new ones or be created from scratch by the user.</p><a name="Out+of+the+box"><h4>Out of the box</h4></a><p>The most common matchers are automatically available when extending the <code class="prettyprint">Specification</code> trait:</p></div></status><status class="ok"><form><table class="dataTable"><tr><th colspan="101">Specification Matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="Equality"><form><table class="dataTable"><tr><td class="none" style="info"><p>The most common type of matcher is <strong><em><code class="prettyprint">beEqualTo</code></em></strong> to test for equality. There are different ways to use this matcher:</p>
<table>
  <thead>
    <tr>
      <th>Matcher </th>
      <th>Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="prettyprint">1 must beEqualTo(1)</code></td>
      <td>the normal way</td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 must be_==(1)</code></td>
      <td>with a shorter matcher</td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 must_== 1</code></td>
      <td>my favorite!</td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 mustEqual 1</code></td>
      <td>if you dislike underscores</td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 should_== 1</code></td>
      <td>for should lovers</td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 === 1</code></td>
      <td>the ultimate shortcut</td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 must be equalTo(1)</code></td>
      <td>with a literate style</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr>
      <th><em>with a negation</em> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="prettyprint">1 must not be equalTo(2)</code></td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 must_!= 2</code></td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 mustNotEqual 2</code></td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 must be_!=(2)</code></td>
    </tr>
    <tr>
      <td><code class="prettyprint">1 !== 2</code></td>
    </tr>
  </tbody>
</table><p>For some other types of equality:</p>
<table>
  <thead>
    <tr>
      <th>Matcher </th>
      <th>Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="prettyprint">be_===</code></td>
      <td>same as <code class="prettyprint">be_==</code> but can be used with some combinators like <code class="prettyprint">^^^</code> or <code class="prettyprint">toSeq</code> because the parameter type is kept</td>
    </tr>
    <tr>
      <td><code class="prettyprint">be_==~</code></td>
      <td>checks if <code class="prettyprint">(a:A) == (b:A)</code> when there is an implicit conversion from B (the type of b) to A (the type of a)</td>
    </tr>
    <tr>
      <td><code class="prettyprint">beTheSameAs</code></td>
      <td>checks if <code class="prettyprint">a eq b</code> (<code class="prettyprint">a must be(b)</code> also works)</td>
    </tr>
    <tr>
      <td><code class="prettyprint">beTrue, beFalse</code></td>
      <td>shortcuts for Boolean equality</td>
    </tr>
    <tr>
      <td><code class="prettyprint">a ==== b</code></td>
      <td>similar to <code class="prettyprint">a === b</code> but will not typecheck if <code class="prettyprint">a</code> and <code class="prettyprint">b</code> don't have the same type</td>
    </tr>
  </tbody>
</table><p>Note: the <code class="prettyprint">beEqualTo</code> matcher is using the regular <code class="prettyprint">==</code> Scala equality. However in the case of <code class="prettyprint">Arrays</code>, Scala <code class="prettyprint">==</code> is just using reference equality, <code class="prettyprint">eq</code>, for <code class="prettyprint">Arrays</code>. So the <code class="prettyprint">beEqualTo</code> matcher has been adapted to transform <code class="prettyprint">Arrays</code> to <code class="prettyprint">Seqs</code> before checking for equality, so that <code class="prettyprint">Array(1, 2, 3) === Array(1, 2, 3)</code> (despite the fact that <code class="prettyprint">Array(1, 2, 3) != Array(1, 2, 3)</code>).</p></td></tr></table></form></div><div class="tabbertab" title="Any"><form><table class="dataTable"><tr><td class="none" style="info"><p>These matchers can be used with <code class="prettyprint">Any</code> objects:</p>
<ul>
  <li><code class="prettyprint">beLike { case exp =&gt; ok }</code>: to check if an object is like a given pattern (<code class="prettyprint">ok</code> is a predefined value, <code class="prettyprint">ko</code> is the opposite)</li>
  <li><code class="prettyprint">beLike { case exp =&gt; exp must beXXX }</code>: to check if an object is like a given pattern, and verifies a condition</li>
  <li><code class="prettyprint">beNull</code></li>
  <li><code class="prettyprint">beAsNullAs</code>: when 2 objects must be null at the same time if one of them is null</li>
  <li><code class="prettyprint">beOneOf(a, b, c)</code>: to check if an object is one of a given list</li>
  <li><code class="prettyprint">haveClass</code>: to check the class of an object</li>
  <li><code class="prettyprint">haveSuperclass</code>: to check if the class of an object as another class as one of its ancestors</li>
  <li><code class="prettyprint">haveInterface</code>: to check if an object is implementing a given interface</li>
  <li><code class="prettyprint">beAssignableFrom</code>: to check if a class is assignable from another</li>
  <li><code class="prettyprint">beAnInstanceOf[T]</code>: to check if an object is an instance of type <code class="prettyprint">T</code></li>
</ul></td></tr></table></form></div><div class="tabbertab" title="Option/Either"><form><table class="dataTable"><tr><td class="none" style="info"><p>There are several matchers to check Option and Either instances:</p>
<ul>
  <li><code class="prettyprint">beSome</code> checks if an element is <code class="prettyprint">Some(_)</code></li>
  <li><code class="prettyprint">beSome(exp)</code> checks if an element is <code class="prettyprint">Some(exp)</code></li>
  <li><code class="prettyprint">beSome(matcher)</code> checks if an element is <code class="prettyprint">Some(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beSome(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Some(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br />(note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Some</code> you need to use a matcher: <code class="prettyprint">beSome(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beSome.which(function)</code> checks if an element is <code class="prettyprint">Some(_</code>) and satisfies a function returning a boolean</li>
  <li><code class="prettyprint">beSome.like(partial function)</code> checks if an element is <code class="prettyprint">Some(_)</code> and satisfies a partial function returning a <code class="prettyprint">MatchResult</code></li>
  <li><code class="prettyprint">beNone</code> checks if an element is <code class="prettyprint">None</code></li>
  <li><code class="prettyprint">beAsNoneAs</code> checks if 2 values are equal to <code class="prettyprint">None</code> at the same time</li>
  <li><p><code class="prettyprint">beRight</code> checks if an element is <code class="prettyprint">Right(_)</code></p></li>
  <li><code class="prettyprint">beRight(exp)</code> checks if an element is `Right(exp)</li>
  <li><code class="prettyprint">beRight(matcher)</code> checks if an element is <code class="prettyprint">Right(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beRight(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Right(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br />(note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Right</code> you need to use a matcher: <code class="prettyprint">beRight(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beRight.like(partial function)</code> checks if an element is <code class="prettyprint">Right(_)</code> and satisfies a partial function returning a <code class="prettyprint">MatchResult</code></li>
  <li><p><code class="prettyprint">beLeft</code> checks if an element is <code class="prettyprint">Left(_)</code></p></li>
  <li><code class="prettyprint">beLeft(exp)</code> checks if an element is <code class="prettyprint">Left(exp)</code></li>
  <li><code class="prettyprint">beLeft(matcher)</code> checks if an element is <code class="prettyprint">Left(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beLeft(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Left(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br />(note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Left</code> you need to use a matcher: <code class="prettyprint">beLeft(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beLeft.like(partial function)</code> checks if an element is <code class="prettyprint">Left(_)</code> and satisfies a partial function returning a <code class="prettyprint">MatchResult</code></li>
</ul></td></tr></table></form></div><div class="tabbertab" title="Try"><form><table class="dataTable"><tr><td class="none" style="info"><p>There are several matchers to check Try instances:</p>
<ul>
  <li><code class="prettyprint">beSuccessfulTry</code> checks if an element is <code class="prettyprint">Success(_)</code></li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(exp)</code> checks if an element is <code class="prettyprint">Success(_)</code></li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(matcher)</code> checks if an element is <code class="prettyprint">Success(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Success(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br />(note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Success</code> you need to use a matcher: <code class="prettyprint">beSuccessfulTry.withValue(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beSuccessfulTry.which(function)</code> checks if an element is <code class="prettyprint">Success(_)</code> and satisfies a function returning a boolean</li>
  <li><code class="prettyprint">beSuccessfulTry.like(partial function)</code> checks if an element is <code class="prettyprint">Success(_)</code> and satisfies a partial function returning a <code class="prettyprint">MatchResult</code></li>
  <li><code class="prettyprint">beFailedTry</code> checks if an element is <code class="prettyprint">Failure(_)</code></li>
  <li><code class="prettyprint">beFailedTry.withThrowable[T]</code> checks if an element is <code class="prettyprint">Failure(t: T)</code></li>
  <li><code class="prettyprint">beFailedTry.withThrowable[T](message)</code> checks if an element is <code class="prettyprint">Failure(t: T)</code> and <code class="prettyprint">t.getMessage</code> matches <code class="prettyprint">message</code></li>
</ul></td></tr></table></form></div><div class="tabbertab" title="String"><form><table class="dataTable"><tr><td class="none" style="info"><p>Matching on strings is very common. Here are the matchers which can help you:</p>
<ul>
  <li><code class="prettyprint">beMatching</code> (or <code class="prettyprint">be matching</code>) checks if a string matches a regular expression</li>
  <li><code class="prettyprint">=~(s)</code> is a shortcut for <code class="prettyprint">beMatching(&quot;(.|\\s)*&quot;+s+&quot;(.|\\s)*&quot;)</code></li>
  <li><code class="prettyprint">find(exp).withGroups(a, b, c)</code> checks if some groups are found in a string</li>
  <li><code class="prettyprint">have length</code> checks the length of a string</li>
  <li><code class="prettyprint">have size</code> checks the size of a string (seen as an <code class="prettyprint">Iterable[Char]</code>)</li>
  <li><code class="prettyprint">be empty</code> checks if a string is empty</li>
  <li><code class="prettyprint">beEqualTo(b).ignoreCase</code> checks if 2 strings are equal regardless of casing</li>
  <li><code class="prettyprint">beEqualTo(b).ignoreSpace</code> checks if 2 strings are equal when you <code class="prettyprint">replaceAll(&quot;\\s&quot;, &quot;&quot;)</code></li>
  <li><code class="prettyprint">beEqualTo(b).trimmed</code> checks if 2 strings are equal when trimmed</li>
  <li><code class="prettyprint">beEqualTo(b).ignoreSpace.ignoreCase</code> you can compose them</li>
  <li><code class="prettyprint">contain(b)</code> checks if a string contains another one</li>
  <li><code class="prettyprint">startWith(b)</code> checks if a string starts with another one</li>
  <li><code class="prettyprint">endWith(b)</code> checks if a string ends with another one</li>
</ul></td></tr></table></form></div><div class="tabbertab" title="Numeric"><form><table class="dataTable"><tr><td class="none" style="info"><p>Less often you need to do comparisons on Numerical values:</p>
<ul>
  <li><p><code class="prettyprint">beLessThanOrEqualTo</code> compares any Ordered type with <code class="prettyprint">&lt;=</code><br />    <code class="prettyprint">1 must be_&lt;=(2)</code><br />    <code class="prettyprint">1 must beLessThanOrEqualTo(2)</code></p></li>
  <li><p><code class="prettyprint">beLessThan</code> compares any Ordered type with <code class="prettyprint">&lt;</code><br />    <code class="prettyprint">1 must be_&lt;(2)</code><br />    <code class="prettyprint">1 must beLessThan(2)</code></p></li>
  <li><p><code class="prettyprint">beGreaterThanOrEqualTo</code> compares any Ordered type with <code class="prettyprint">&gt;=</code><br />    <code class="prettyprint">2 must be_&gt;=(1)</code><br />    <code class="prettyprint">2 must beGreaterThanOrEqualTo(1)</code></p></li>
  <li><p><code class="prettyprint">beGreaterThan</code> compares any Ordered type with <code class="prettyprint">&gt;</code><br />    <code class="prettyprint">2 must be_&gt;(1)</code><br />    <code class="prettyprint">2 must beGreaterThan(1)</code></p></li>
  <li><p><code class="prettyprint">beCloseTo</code> checks if 2 Numerics are close to each other<br />    <code class="prettyprint">1.0 must beCloseTo(1, 0.5)</code><br />    <code class="prettyprint">4 must be ~(5 +/- 2)</code></p></li>
  <li><p><code class="prettyprint">beBetween</code> checks if a value is between 2 others<br />    <code class="prettyprint">5 must beBetween(3, 6)</code><br />    <code class="prettyprint">5 must beBetween(3, 6).excludingEnd</code><br />    <code class="prettyprint">5 must beBetween(4, 6).excludingStart</code><br />    <code class="prettyprint">5 must beBetween(4, 6).excludingBounds</code><br />    <code class="prettyprint">// with brackets notation</code><br />    <code class="prettyprint">5 must (</code>be[<code class="prettyprint">(4, 7)</code>]<code class="prettyprint">)</code></p></li>
</ul></td></tr></table></form></div><div class="tabbertab" title="Exception"><form><table class="dataTable"><tr><td class="none" style="info"><p><strong><em>specs2</em></strong> offers very compact ways of checking that some exceptions are thrown:</p>
<ul>
  <li><code class="prettyprint">throwA[ExceptionType]</code> checks if a block of code throws an exception of the given type</li>
  <li><code class="prettyprint">throwA[ExceptionType](message = &quot;boom&quot;)</code> additionally checks if the exception message is as expected</li>
  <li><code class="prettyprint">throwA(exception)</code> or <code class="prettyprint">throwAn(exception)</code> checks if a block of code throws an exception of the same type, with the<br />  same message</li>
  <li><code class="prettyprint">throwA[ExceptionType].like { case e =&gt; e must matchSomething }</code> or<br />  <code class="prettyprint">throwA(exception).like { case e =&gt; e must matchSomething }</code> allow to verify that the thrown exception satisfies a property</li>
  <li><code class="prettyprint">throwA[ExceptionType](me.like { case e =&gt; e must matchSomething }</code> or<br />  <code class="prettyprint">throwA(exception).like { case e =&gt; e must matchSomething }</code> allow to verify that the thrown exception satisfies a property</li>
</ul><p>For all the above matchers you can use <code class="prettyprint">throwAn</code> instead of <code class="prettyprint">throwA</code> if the exception name starts with a vowel for better<br />readability.</p></td></tr></table></form></div><div class="tabbertab" title="Traversable"><form><table class="dataTable"><tr><td class="none" style="info"><p>Traversables can be checked with several matchers.</p><p>If you want to check the size of a <code class="prettyprint">Traversable</code></p>
<ul>
  <li><p>to check if it is empty<br />  <code class="prettyprint">Seq() must be empty</code><br />  <code class="prettyprint">Seq(1, 2, 3) must not be empty</code></p></li>
  <li><p>to check its size<br />  <code class="prettyprint">Seq(1, 2) must have size(2)</code><br />  <code class="prettyprint">Seq(1, 2) must have length(2)</code> // equivalent to size</p></li>
  <li><p>to check its ordering (works with any type <code class="prettyprint">T</code> which has an <code class="prettyprint">Ordering</code>)<br />  <code class="prettyprint">Seq(1, 2, 3) must beSorted</code></p></li>
</ul><p>Then you can check the elements which are contained in the Traversable</p>
<ul>
  <li><p>if a simple value is contained<br />  <code class="prettyprint">Seq(1, 2, 3) must contain(2)</code></p></li>
  <li><p>if a value matching a specific matcher is contained<br />  <code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;=(2))</code></p></li>
  <li><p>if a value passing a function returning a <code class="prettyprint">Result</code> is contained (<code class="prettyprint">MatchResult</code>, ScalaCheck <code class="prettyprint">Prop</code>,...)<br />  <code class="prettyprint">Seq(1, 2, 3) must contain((i: Int) =&gt; i must be_&gt;=(2))</code></p></li>
  <li><p>note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in another you need to use a matcher<br />  <code class="prettyprint">Seq(Seq(1)) must contain(===(Seq(1)))</code></p></li>
  <li><p>there are also 2 specialized matchers to check the string representation of the elements<br />  <code class="prettyprint">Seq(1234, 6237) must containMatch(&quot;23&quot;)</code> <code class="prettyprint">// matches with &quot;.*23.*&quot;</code><br />  <code class="prettyprint">Seq(1234, 6234) must containPattern(&quot;.*234&quot;)</code> <code class="prettyprint">// matches with !.*234&quot;</code></p></li>
</ul><p>For each of the checks above you can indicate how many times the check should be satisfied:</p>
<ul>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).forall</code> // this will stop after the first failure</li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).foreach</code> // this will report all failures</li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).atLeastOnce</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).atMostOnce</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).exactly(1.times)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).exactly(1)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(1)).between(1.times, 2.times)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(1)).between(1, 2)</code></li>
</ul><p>The other types of checks involve comparing the Traversable elements to other elements (values, matchers, function returning a <code class="prettyprint">Result</code>)</p>
<ul>
  <li><p>with a set of values<br />  <code class="prettyprint">Seq(1, 2, 3, 4) must contain(2, 4)</code><br />  which is the same thing as<br />  <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(2, 4))</code></p></li>
  <li><p>with a set of matchers<br />  <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(be_&gt;(0), be_&gt;(1)))</code></p></li>
  <li><p>checking that the order is satisfied<br />  <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(be_&gt;(0), be_&gt;(1)).inOrder)</code></p></li>
</ul><p>Note that when you use don't specify <code class="prettyprint">inOrder</code>, <code class="prettyprint">contain</code> is going to try the checks one by one, but will consume them greedily and not try all possible combinations of input value and check.</p><p>The <code class="prettyprint">allOf</code> method above can be replaced by <code class="prettyprint">atLeast</code>, <code class="prettyprint">atMost</code>, <code class="prettyprint">exactly</code> to be more specific on the number of elements which you expect to be correctly checked.</p><p>Finally, if you want to get the differences between 2 traversables:</p><p><code class="prettyprint">Seq(2, 4, 1) must containTheSameElementsAs(Seq(1, 4, 2))</code></p></td></tr></table></form></div><div class="tabbertab" title="Map"><form><table class="dataTable"><tr><td class="none" style="info"><p>Maps have their own matchers as well, to check keys and values:</p>
<ul>
  <li><p><code class="prettyprint">haveKey</code> checks if a Map has a given key<br />    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must haveKey(1)</code></p></li>
  <li><p><code class="prettyprint">haveKeys</code> checks if a Map has several keys<br />    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;, 2 -&gt; &quot;2&quot;) must haveKeys(1, 2)</code></p></li>
  <li><p><code class="prettyprint">haveValue</code> checks if a Map has a given value<br />    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must haveValue(&quot;1&quot;)</code></p></li>
  <li><p><code class="prettyprint">haveValues</code> checks if a Map has several values<br />    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;, 2 -&gt; &quot;2&quot;) must haveValue(&quot;1&quot;, &quot;2&quot;)</code></p></li>
  <li><p><code class="prettyprint">havePair</code> checks if a Map has a given pair of values<br />    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must havePair(1 -&gt; &quot;1&quot;)</code></p></li>
  <li><p><code class="prettyprint">havePairs</code> checks if a Map has some pairs of values<br />    <code class="prettyprint">Map(1-&gt;&quot;1&quot;, 2-&gt;&quot;2&quot;, 3-&gt;&quot;3&quot;) must havePairs(1-&gt;&quot;1&quot;, 2-&gt;&quot;2&quot;)</code></p></li>
</ul><p>But Maps are also Partial Functions, so:</p>
<ul>
  <li><p><code class="prettyprint">beDefinedAt</code> checks if a PartialFunction is defined for a given value<br />    <code class="prettyprint">partial must beDefinedAt(1)</code></p></li>
  <li><p><code class="prettyprint">beDefinedBy</code> checks if a PartialFunction is defined for a given value<br />  and returns another one<br />    <code class="prettyprint">partial</code> must beDefinedBy(1 -&gt; true)</p></li>
</ul></td></tr></table></form></div></div></td></tr></table></form></status><status class="ok"><div style="display: show; text-indent:0px;"><p>The examples above show how to use matchers:</p>
<ul>
  <li>the general form for using a matcher is: <code class="prettyprint">a must matcher</code></li>
  <li>but can use <code class="prettyprint">should</code> instead of <code class="prettyprint">must</code> if you prefer</li>
  <li>for most matchers you can use a form where the <code class="prettyprint">be</code> word (or the <code class="prettyprint">have</code> word) is detached</li>
  <li>you can as well negate a matcher by adding <code class="prettyprint">not</code> before it (or after it, as a method call)</li>
</ul><a name="Optional"><h4>Optional</h4></a><p>These other matchers need to be selectively added to the specification by adding a new trait:</p></div></status><status class="ok"><form><table class="dataTable"><tr><th colspan="101">Optional Matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="Result"><form><table class="dataTable"><tr><td class="none" style="info"><p>That's only if you want to match the result of other matchers! </p>
<pre><code class="prettyprint">// you need to extend the ResultMatchers trait
class MatchersSpec extends Specification with matcher.ResultMatchers { def is =
  &quot;beMatching is using a regexp&quot; ! {
    (&quot;Hello&quot; must beMatching(&quot;h.*&quot;)) must beSuccessful
  }
}
</code></pre></td></tr></table></form></div><div class="tabbertab" title="Xml"><form><table class="dataTable"><tr><td class="none" style="info"><p>It is very useful to have literal Xml in Scala, it is even more useful to have matchers for it!</p>
<ul>
  <li><p><code class="prettyprint">beEqualToIgnoringSpace</code> compares 2 Nodes, without considering spaces<br />  <code class="prettyprint">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; must ==/(&lt;a&gt; &lt;b/&gt;&lt;/a&gt;)</code><br />  <code class="prettyprint">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; must beEqualToIgnoringSpace(&lt;a&gt; &lt;b/&gt;&lt;/a&gt;)</code></p></li>
  <li><p><code class="prettyprint">beEqualToIgnoringSpace</code> can also do an ordered comparison<br />  <code class="prettyprint"><a><c></c> <b></b></a> must ==/(<a> <c></c><b></b></a>).ordered</code></p></li>
  <li><p>on the other hand <code class="prettyprint">beEqualToIgnoringSpace</code> will not check attributes order<br />  <code class="prettyprint"><n b="2" a="1"></n> must ==/(<n a="1" b="2"></n>)</code></p></li>
  <li><p><code class="prettyprint">\</code> is an XPath-like matcher matching if a node is a direct child of another<br />  <code class="prettyprint"><a><b></b></a> must \(&quot;b&quot;)</code></p></li>
  <li><p>You can also check attribute names<br />  <code class="prettyprint"><a><b name="value"></b></a> must \(&quot;b&quot;, &quot;name&quot;)</code></p></li>
  <li><p>And attribute names and values as well (values are checked using a regular expression, use the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#quote(java.lang.String)">quote method</a> if you want an exact match)<br />  <code class="prettyprint"><a><b n3="v3" n2="v2" n="v"></b></a> must \(&quot;b&quot;, &quot;n&quot;-&gt;&quot;v&quot;, &quot;n2&quot;-&gt;&quot;v\d&quot;)</code></p></li>
  <li><p>Or the content of a <code class="prettyprint">Text</code> node<br />  <code class="prettyprint"><a>hello</a> must \(&quot;a&quot;) \&gt; &quot;hello&quot;</code> (alias <code class="prettyprint">textIs</code>)<br />  <code class="prettyprint"><a>hello</a> must \(&quot;a&quot;) \&gt;~ &quot;h.*&quot;</code> (alias <code class="prettyprint">textMatches</code>)</p></li>
  <li><p>The equivalent of <code class="prettyprint">\</code> for a &quot;deep&quot; match is simply <code class="prettyprint">\\</code><br />  <code class="prettyprint"><a><s><c></c></s></a> must \\(&quot;c&quot;)</code></p></li>
</ul></td></tr></table></form></div><div class="tabbertab" title="Json"><form><table class="dataTable"><tr><td class="none" style="info"><p><a href="http://www.json.org">Json</a> is a simple data format essentially modeling recursive key-values. There are 2 matchers which can be used to verify the presence of appropriate values in Strings representing Json documents:</p>
<ul>
  <li><p><code class="prettyprint">/(value)</code> checks if a value is present at the root of the document. This can only be the case if that document is an Array</p></li>
  <li><p><code class="prettyprint">/(regex)</code> checks if a value matching the regex is present at the root of the document. This can only be the case if that document is an Array</p></li>
  <li><p><code class="prettyprint">/(key -&gt; value)</code> checks if a pair is present at the root of the document. This can only be the case if that document is a Map</p></li>
  <li><p><code class="prettyprint">*/(value)</code> checks if a value is present anywhere in the document, either as an entry in an Array, or as the value for a key in a Map</p></li>
  <li><p><code class="prettyprint">*/(key -&gt; value)</code> checks if a pair is present anywhere in a Map of the document</p></li>
  <li><p><code class="prettyprint">/#(i)</code> selects the ith element in a 0-based indexed Array or a Map and allow further checks on that element</p></li>
</ul><p>Now the interesting part comes from the fact that those matchers can be chained to search specific paths in the Json document. For example, for the following document: </p>
<pre><code class="prettyprint">// taken from an example in the Lift project
val person = &quot;&quot;&quot;{
  &quot;person&quot;: {
    &quot;name&quot;: &quot;Joe&quot;,
    &quot;age&quot;: 35,
    &quot;spouse&quot;: {
      &quot;person&quot;: {
        &quot;name&quot;: &quot;Marilyn&quot;,
        &quot;age&quot;: 33
      }
    }
  }
}
&quot;&quot;&quot;
</code></pre><p>You can use these combinations: <code class="prettyprint">person must /(&quot;person&quot;) */(&quot;person&quot;) /(&quot;age&quot; -&gt; 33.0)</code></p><p>You can as well use regular expressions or String matchers instead of values to verify the presence of keys or elements. For example: </p>
<pre><code class="prettyprint">person must /(&quot;p.*&quot;.r) */ &quot;.*on&quot;.r /(&quot;age&quot; -&gt; &quot;\\d+\\.\\d&quot;.r)
person must /(&quot;p.*&quot;.r) */ &quot;.*on&quot;.r /(&quot;age&quot; -&gt; startWith(&quot;3&quot;))
person must /(&quot;p.*&quot;.r) */ &quot;.*on&quot;.r /(&quot;age&quot; -&gt; (be_&gt;(30) ^^ ((_:String).toInt)))
</code></pre><p>Finally you can access some records by their index: <code class="prettyprint">person must /(&quot;person&quot;) /# 2 / &quot;person&quot;</code></p></td></tr></table></form></div><div class="tabbertab" title="File"><form><table class="dataTable"><tr><td class="none" style="info"><p>The Java api for files is more or less mimicked as matchers which can operate on strings denoting paths or on Files (with the <code class="prettyprint">org.specs2.matcher.FileMatchers</code> trait)</p>
<ul>
  <li><code class="prettyprint">beEqualToIgnoringSep</code> checks if 2 paths are the same regardless of their separators<br />  <code class="prettyprint">&quot;c:\temp\hello&quot; must beEqualToIgnoringSep(&quot;c:/temp/hello&quot;)</code></li>
  <li><code class="prettyprint">beAnExistingPath</code> checks if a path exists</li>
  <li><code class="prettyprint">beAReadablePath</code> checks if a path is readable</li>
  <li><code class="prettyprint">beAWritablePath</code> checks if a path is writable</li>
  <li><code class="prettyprint">beAnAbsolutePath</code> checks if a path is absolute</li>
  <li><code class="prettyprint">beAHiddenPath</code> checks if a path is hidden</li>
  <li><code class="prettyprint">beAFilePath</code> checks if a path is a file</li>
  <li><code class="prettyprint">beADirectoryPath</code> checks if a path is a directory</li>
  <li><code class="prettyprint">havePathName</code> checks if a path has a given name</li>
  <li><code class="prettyprint">haveAsAbsolutePath</code> checks if a path has a given absolute path</li>
  <li><code class="prettyprint">haveAsCanonicalPath</code> checks if a path has a given canonical path</li>
  <li><code class="prettyprint">haveParentPath</code> checks if a path has a given parent path</li>
  <li><code class="prettyprint">listPaths</code> checks if a path has a given list of children</li>
  <li><code class="prettyprint">exist</code> checks if a file existsy</li>
  <li><p><code class="prettyprint">beReadable</code> checks if a file is readable</p></li>
  <li><code class="prettyprint">beWritable</code> checks if a file is writable</li>
  <li><code class="prettyprint">beAbsolute</code> checks if a file is absolute</li>
  <li><code class="prettyprint">beHidden</code> checks if a file is hidden</li>
  <li><code class="prettyprint">beAFile</code> checks if a file is a file</li>
  <li><code class="prettyprint">beADirectory</code> checks if a file is a directory</li>
  <li><code class="prettyprint">haveName</code> checks if a file has a given name</li>
  <li><code class="prettyprint">haveAbsolutePath</code> checks if a file has a given absolute path</li>
  <li><code class="prettyprint">haveCanonicalPath</code> checks if afile has a given canonical path</li>
  <li><code class="prettyprint">haveParent</code> checks if a file has a given parent path</li>
  <li><code class="prettyprint">haveList</code> checks if a file has a given list of children</li>
</ul></td></tr></table></form></div><div class="tabbertab" title="Content"><form><table class="dataTable"><tr><td class="none" style="info"><a name="File+contents"><h5>File contents</h5></a><p>The matchers from the <code class="prettyprint">org.specs2.matcher.ContentMatchers</code> trait can help us check the contents of files. For example we can check that 2 text files have the same lines: </p>
<pre><code class="prettyprint">(file1, file2) must haveSameLines
file1 must haveSameLinesAs(file2)
</code></pre><p>We can check that the content of one file is contained in another one: <code class="prettyprint">file1 must containLines(file2)</code></p><p>If the files are binary files we can also check that they have the same MD5 hash: </p>
<pre><code class="prettyprint">(file1, file2) must haveSameMD5
 file1 must haveSameMD5As(file2)
</code></pre><p><strong><em>Order</em></strong></p><p>It is possible to relax the constraint by requiring the equality or containment to be true regardless of the order of lines: </p>
<pre><code class="prettyprint">(file1, file2) must haveSameLines.unordered
 file1 must haveSameLinesAs(file2).unordered
 file1 must containLines(file2).unordered
</code></pre><p><strong><em>Missing only</em></strong></p><p>By default, <code class="prettyprint">(file1, file2) must haveSameLines</code> will report misplaced lines if any, that is, lines of <code class="prettyprint">f1</code> which appear in <code class="prettyprint">f2</code> but not at the right position. However if <code class="prettyprint">file2</code> is big, this search might degrade the performances. In that case you can turn it off with <code class="prettyprint">missingOnly</code>: <code class="prettyprint">(file1, file2) must haveSameLines.missingOnly</code></p><p><strong><em>Show less differences</em></strong></p><p>If there are too many differences, you can specify that you only want the first 10: <code class="prettyprint">(file1, file2) must haveSameLines.showOnly(10.differences).unordered</code></p><p>In the code above <code class="prettyprint">10.differences</code> builds a <code class="prettyprint">DifferenceFilter</code> which is merely a filtering function: <code class="prettyprint">(lines1: Seq[String], lines2: Seq[String]) =&gt; (Seq[String], Seq[String])</code>. The parameter <code class="prettyprint">lines1</code> is the sequence of lines not found in the second content while <code class="prettyprint">lines2</code> is the sequence of lines not found in the first content.</p><a name="Directories+contents"><h5>Directories contents</h5></a><p>We can compare the contents of 2 directories. We can for example check if no files are missing and none has been added: </p>
<pre><code class="prettyprint">actualDir must haveSamePathsAs(expectedDir)
// with a file filter applied to both the actual and expected directories
actualDir must haveSamePathsAs(expectedDir).withFilter((file: File) =&gt; !file.isHidden)
</code></pre><p>Once we know that all files are present we can check their content: </p>
<pre><code class="prettyprint">// the default comparison expects that files are text files and that comparison must be done line by line
actualDir must haveSameFilesAs(expectedDir)

// with a file filter applied to both the actual and expected directories
actualDir must haveSameFilesAs(expectedDir).withFilter((file: File) =&gt; !file.isHidden)

// with a MD5 matcher for binary files
actualDir must haveSameFilesAs(expectedDir).withMatcher(haveSameMD5)

// it is also possible to only check the content of actual files when they exist in the expected directory
actualDir must haveSameFilesContentAs(expectedDir)
</code></pre><a name="Lines+contents"><h5>Lines contents</h5></a><p>Files are not the only possible source of lines and it is useful to be able to check the content of a <code class="prettyprint">File</code> with a <code class="prettyprint">Seq[String]</code>: <code class="prettyprint">file1 must haveSameLinesAs(Seq(line1, line2, line3))</code></p><p>This is because those 2 types implement the <code class="prettyprint">org.specs2.text.LinesContent</code> trait, defining:</p>
<ul>
  <li>a name for the overall content</li>
  <li>a method for returning the lines</li>
  <li>a default method for computing the differences of 2 sequences of lines (in case you need to override this logic)</li>
</ul><p>So if you have a specific type <code class="prettyprint">T</code> which you can represent as a <code class="prettyprint">Seq[String]</code>, you can create an implicit <code class="prettyprint">LinesContent</code> and then you'll be able to use the <code class="prettyprint">ContentMatchers</code>: </p>
<pre><code class="prettyprint">implicit def linesforMyType[T]: LinesContent[T] = new LinesContent[T] {
  def name(t: T) = &quot;My list of lines&quot;
  def lines(t: T): Seq[String] = Seq()// your implementation goes here
}
</code></pre></td></tr></table></form></div><div class="tabbertab" title="Scala Interpreter"><form><table class="dataTable"><tr><td class="none" style="info"><p>In the rare case where you want to use the Scala interpreter and execute a script: </p>
<pre><code class="prettyprint">class ScalaInterpreterMatchersSpec extends mutable.Specification with ScalaInterpreterMatchers {
  def interpret(s: String): String = &quot;&quot; // you have to provide your own Scala interpreter here

  &quot;A script&quot; can {
    &quot;be interpreted&quot; in {
      &quot;1 + 1&quot; &gt;| &quot;2&quot;
    }
  }
}
</code></pre></td></tr></table></form></div><div class="tabbertab" title="Parser"><form><table class="dataTable"><tr><td class="none" style="info"><p>Scala provides a parsing library using <a href="http://www.scala-lang.org/api/current/scala/util/parsing/combinator/Parsers.html">parser combinators</a>.</p><p>You can specify your own parsers by:</p>
<ul>
  <li>extending the <code class="prettyprint">ParserMatchers</code> trait</li>
  <li>associating the <code class="prettyprint">val parsers</code> variable with your parsers definition</li>
  <li>using the <code class="prettyprint">beASuccess</code>, <code class="prettyprint">beAFailure</code>, <code class="prettyprint">succeedOn</code>, <code class="prettyprint">failOn</code>, <code class="prettyprint">errorOn</code> matchers to specify the results of parsing input<br />  strings. <code class="prettyprint">beAPartialSuccess</code>, <code class="prettyprint">be aPartialSuccess</code>, <code class="prettyprint">succeedOn.partially</code> will allow a successful match only on part of the input</li>
  <li>using <code class="prettyprint">haveSuccessResult</code> and <code class="prettyprint">haveFailureMsg</code> to specify what happens <em>only</em> on success or failure. Those matchers accept<br />  a String or a matcher so that<br />  . <code class="prettyprint">haveSuccessResult(&quot;r&quot;) &lt;==&gt; haveSuccessResult(beMatching(&quot;.*r.*&quot;) ^^ ((_:Any).toString)</code><br />  . <code class="prettyprint">haveFailingMsg(&quot;m&quot;) &lt;==&gt; haveFailingMsg(beMatching(&quot;.*r.*&quot;))</code></li>
</ul><p>For example, specifying a Parser for numbers could look like this: </p>
<pre><code class="prettyprint">import util.parsing.combinator.RegexParsers
import NumberParsers.{number, error}

class ParserSpec extends Specification with matcher.ParserMatchers {  def is = s2&quot;&quot;&quot;
  Parsers for numbers

    beASuccess and succeedOn check if the parse succeeds
    ${ number(&quot;1&quot;) must beASuccess }
    ${ number(&quot;1i&quot;) must beAPartialSuccess }
    ${ number must succeedOn(&quot;12&quot;) }
    ${ number must succeedOn(&quot;12ab&quot;).partially }
    ${ number must succeedOn(&quot;12&quot;).withResult(12) }
    ${ number must succeedOn(&quot;12&quot;).withResult(equalTo(12)) }
    ${ number(&quot;1&quot;) must haveSuccessResult(&quot;1&quot;) }

    beAFailure and failOn check if the parse fails
    ${ number must failOn(&quot;abc&quot;) }
    ${ number must failOn(&quot;abc&quot;).withMsg(&quot;string matching regex.*expected&quot;) }
    ${ number must failOn(&quot;abc&quot;).withMsg(matching(&quot;.*string matching regex.*expected.*&quot;)) }
    ${ number(&quot;i&quot;) must beAFailure }
    ${ number(&quot;i&quot;) must haveFailureMsg(&quot;i' found&quot;) }

    beAnError and errorOn check if the parser errors out completely
    ${ error must errorOn(&quot;&quot;) }
    ${ error(&quot;&quot;) must beAnError }
                                                                                &quot;&quot;&quot;

  val parsers = NumberParsers
}

object NumberParsers extends RegexParsers {
  /** parse a number with any number of digits */
  val number: Parser[Int] = &quot;\\d+&quot;.r ^^ {_.toInt}
  /** this parser returns an error */
  val error: Parser[String] = err(&quot;Error&quot;)
}
</code></pre></td></tr></table></form></div><div class="tabbertab" title="Termination"><form><table class="dataTable"><tr><td class="none" style="info"><p>Sometimes you just want to specify that a block of code is going to terminate. The <code class="prettyprint">org.specs2.matcher.TerminationMatchers</code> trait is here to help. If you mix in that trait, you can write: </p>
<pre><code class="prettyprint">Thread.sleep(100) must terminate

// the default is retries=0, sleep=100.millis
Thread.sleep(100) must terminate(retries=1, sleep=60.millis)
</code></pre><p>Note that the behaviour of this matcher is a bit different from the <code class="prettyprint">eventually</code> operator. In this case, we let the current Thread sleep during the given <code class="prettyprint">sleep</code> time and then we check if the computation is finished, then, we retry for the given number of <code class="prettyprint">retries</code>.</p><p>In a further scenario, we might want to check that triggering another action is able to unblock the first one: </p>
<pre><code class="prettyprint">action1 must terminate.when(action2)
action1 must terminate.when(&quot;starting the second action&quot;, action2)
action1 must terminate(retries=3, sleep=100.millis).when(action2)
</code></pre><p>When a second action is specified like that, <code class="prettyprint">action1</code> will be started and <code class="prettyprint">action2</code> will be started on the first retry. Otherwise, if you want to specify that <code class="prettyprint">action1</code> can <em>only</em> terminate when <code class="prettyprint">action2</code> is started, you write: <code class="prettyprint">action1 must terminate.onlyWhen(action2)</code></p></td></tr></table></form></div><div class="tabbertab" title="Dependency Matchers"><form><table class="dataTable"><tr><td class="none" style="info"><p>It is highly desirable to have acyclic dependencies between the packages of a project. This often leads to describing the packages structure as &quot;layered&quot;: each package on a layer can only depend on a package on a lower layer. <strong><em>specs2</em></strong> helps you enforce this design property with specific matchers.</p><p><strong><em>Layers definition</em></strong></p><p>First you need to define the packages and their expected dependencies. Mix-in the <code class="prettyprint">org.specs2.specification.Analysis</code> trait and define, (taking <strong><em>specs2</em></strong> as an example): </p>
<pre><code class="prettyprint">layers (
  &quot;runner&quot;,
  &quot;reporter&quot;,
  &quot;specification mutable&quot;,
  &quot;mock      form&quot;,
  &quot;matcher&quot;,
  &quot;execute&quot;,
  &quot;reflect    xml  time html&quot;,
  &quot;collection control io text main data&quot;).withPrefix(&quot;org.specs2&quot;)
</code></pre><p>The above expression defines layers as an ordered list of <code class="prettyprint">String</code>s containing space-separated package names. It is supplemented by a <code class="prettyprint">withPrefix</code> declaration to factor out the common package prefix between all these packages.</p><p>By default, the packages are supposed to correspond to directories in the <code class="prettyprint">src/target/scala-&lt;version&gt;/classes</code> directory. If your project has a different layout you can declare another target directory: <code class="prettyprint">layers(&quot;...&quot;).inTargetDir(&quot;out/classes&quot;)</code></p><p><strong>Inclusion/Exclusion</strong></p><p>Every rule has exceptions :-). In some rare cases, it might be desirable to exclude a class from being checked on a given layer. To do this, you can use the <code class="prettyprint">include/exclude</code> methods on the <code class="prettyprint">Layer</code> class: </p>
<pre><code class="prettyprint">layers (
  &quot;runner&quot;,
  &quot;reporter&quot;,
  &quot;specification mutable&quot;.exclude(&quot;mutable.SpecificationWithJUnit&quot;),
  &quot;mock      form&quot;,
  &quot;matcher&quot;,
  &quot;execute&quot;,
  &quot;reflect  xml  time html&quot;,
  &quot;collection control io text main data&quot;).withPrefix(&quot;org.specs2&quot;)
</code></pre><p>The <code class="prettyprint">include/exclude</code> methods accept a list of regular expressions to:</p>
<ul>
  <li>exclude fully qualified class names (generally, only <code class="prettyprint">exclude</code> will be necessary)</li>
  <li>re-include fully qualified class names if the exclusion list is to big</li>
</ul><p><strong><em>Verification</em></strong></p><p>Now you've defined layers, you can use the <code class="prettyprint">beRespected</code> matcher to check if all the dependencies are verified: </p>
<pre><code class="prettyprint">val design = layers(&quot;...&quot;)
design must beRespected
</code></pre><p>If some dependencies are not respected:</p>
<pre><code class="prettyprint">those dependencies are not satisfied:
org.specs2.main x-&gt; org.specs2.io because org.specs2.io.FileSystem -&gt; org.specs2.main.Arguments
org.specs2.main x-&gt; org.specs2.io because org.specs2.io.FileSystem -&gt; org.specs2.main.ArgumentsArgs
</code></pre><p><strong><em>Layers as an <code class="prettyprint">Example</code></em></strong></p><p>The <code class="prettyprint">org.specs2.specification.Analysis</code> trait allows to directly embed the layers definition in a <code class="prettyprint">Specification</code> and turn it into an <code class="prettyprint">Example</code>: </p>
<pre><code class="prettyprint">class DependenciesSpec extends Specification with specification.Analysis { def is =
  &quot;this is the application design&quot; ^
    layers(
      &quot;gui commandline&quot;,
      &quot;controller&quot;,
      &quot;backend&quot;
    )
}
</code></pre><p><strong><em>Alternative implementation</em></strong></p><p>Another implementation of the same functionality is available through the <code class="prettyprint">org.specs2.analysis.CompilerDependencyFinder</code> trait. This implementation uses the compiler dependency analysis functionality but needs more time, since it recompiles the sources.</p><p>The source files are taken from the <code class="prettyprint">src/main/scala</code> directory by default but you can change this value by using the <code class="prettyprint">Layers.inSourceDir</code> method.</p><p>While this implementation is slower than the Classycle one, it might retrieve more dependencies, for example when constants are inlined in class files.</p><p>Note: since this functionality relies on the scala compiler library, so you need to add it to your build file:</p>
<pre><code class="prettyprint">// use sbt's scalaVersion Setting to define the scala-compiler library version
libraryDependencies &lt;&lt;= scalaVersion { scala_version =&gt; Seq(
  &quot;org.specs2&quot; %% &quot;specs2&quot; % 2.3.5 % &quot;test&quot;,
  &quot;org.scala-lang&quot; % &quot;scala-compiler&quot; % scala_version % &quot;test&quot;)
}
</code></pre></td></tr></table></form></div></div></td></tr></table></form></status><status class="ok"><div style="display: show; text-indent:0px;"><a name="Custom"><h4>Custom</h4></a><p>There are many ways to create matchers for your specific usage. The simplest way is to reuse the existing ones:</p>
<ul>
  <li>using logical operators</li>
</ul>
<pre><code class="prettyprint">def beBetween(i: Int, j: Int) = be_&gt;=(i) and be_&lt;=(j)

// create a Seq Matcher from a Matcher
def allBeGreaterThan2: Matcher[Seq[Int]]   = be_&gt;=(2).forall     // fail after the first failure
def allBeGreaterThan3: Matcher[Seq[Int]]   = be_&gt;=(2).foreach    // like forall but execute all matchers and collect the results
def haveOneGreaterThan2: Matcher[Seq[Int]] = be_&gt;=(2).atLeastOnce
</code></pre>
<ul>
  <li>using <code class="prettyprint">zip</code> operators for to match tuples</li>
</ul>
<pre><code class="prettyprint">type T = (String, String, String, Seq[(String, Double)])

val t1: T = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, Seq((&quot;d&quot;, 1.01), (&quot;e&quot;, 2.02)))
val t2: T = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, Seq((&quot;d&quot;, 1.00), (&quot;e&quot;, 2.00)))

// create a matcher by zipping matchers to the expected value
def beMatching(expected: T) = expected.zip(startWith, ===, ===, matchSequence)
// match the elements of a sequence with a zipped matcher using string equality for the first field and
// approximate Double equality for the second field
def matchSequence(expected: =&gt;Seq[(String, Double)]) = expected.contain(_.zip(===, ==~)).inOrder

/** type inference doesn't work if this matcher, specialised to Double, is not defined */
def ==~(d: =&gt;Double) = beCloseTo(d +/- 0.1)

t1 must beMatching(t2)
</code></pre>
<ul>
  <li>adapting the actual value</li>
</ul>
<pre><code class="prettyprint">// This matcher adapts the existing `be_&lt;=` matcher to a matcher applicable to `Any`
def beShort1 = be_&lt;=(5) ^^ { (t: Any) =&gt; t.toString.size }
def beShort2 = be_&lt;=(5) ^^ { (t: Any) =&gt; t.toString.size aka &quot;the string size&quot; }

// !!! use a BeTypedEqualTo matcher when using aka and equality !!!
def beFive = be_===(5) ^^ { (t: Any) =&gt; t.toString.size aka &quot;the string size&quot; }

// The adaptation can also be done the other way around when it's more readable
def haveExtension(extension: =&gt;String) = ((_:File).getPath) ^^ endWith(extension)
</code></pre>
<ul>
  <li>adapting the actual and expected values. This matcher compares 2 <code class="prettyprint">Human</code> objects but set their <code class="prettyprint">wealth</code> field to 0<br />    so that the equals method will not fail on that field:</li>
</ul>
<pre><code class="prettyprint">def beMostlyEqualTo = (be_==(_:Human)) ^^^ ((_:Human).copy(wealth = 0))
// then
Human(age = 20, wealth=1000) must beMostlyEqualTo(Human(age = 20, wealth=1)) toResult // success
</code></pre>
<ul>
  <li>using <code class="prettyprint">eventually</code> to try a match a number of times until it succeeds:</li>
</ul>
<pre><code class="prettyprint">val iterator = List(1, 2, 3).iterator
iterator.next must be_==(3).eventually
// Use eventually(retries, n.millis) to use another number of tries and waiting time
</code></pre>
<ul>
  <li>using <code class="prettyprint">await</code> to create a matcher that will match on <code class="prettyprint">Matcher[Future[T]]</code>:</li>
</ul>
<pre><code class="prettyprint">future(1) must be_&gt;(0).await
future { Thread.sleep(100); 1 } must be_&gt;(0).await(retries = 2, timeout = 100.millis)
</code></pre>
<ul>
  <li>using <code class="prettyprint">when</code> or <code class="prettyprint">unless</code> to apply a matcher only if a condition is satisfied:</li>
</ul>
<pre><code class="prettyprint">1 must be_==(2).when(false)                        // will return a success
1 must be_==(2).unless(true)                       // same thing

1 must be_==(2).when(false, &quot;don't check this&quot;)    // will return a success
1 must be_==(2).unless(true, &quot;don't check this&quot;)   // same thing
</code></pre>
<ul>
  <li>using <code class="prettyprint">iff</code> to say that a matcher must succeed if and only if a condition is satisfied:</li>
</ul>
<pre><code class="prettyprint">1 must be_==(1).iff(true)                        // will return a success
1 must be_==(2).iff(true)                        // will return a failure
1 must be_==(2).iff(false)                       // will return a success
1 must be_==(1).iff(false)                       // will return a failure
</code></pre>
<ul>
  <li>using <code class="prettyprint">orSkip</code> to return a <code class="prettyprint">Skipped</code> result instead of a Failure if the condition is not met</li>
</ul>
<pre><code class="prettyprint">1 must be_==(2).orSkip
1 must be_==(2).orSkip(&quot;Precondition failed&quot;)    // prints &quot;Precondition failed: '1' is not equal to '2'&quot;
1 must be_==(2).orSkip((ko:String) =&gt; &quot;BAD &quot;+ko) // prints &quot;BAD '1' is not equal to '2'&quot;
</code></pre>
<ul>
  <li>using <code class="prettyprint">orPending</code> to return a <code class="prettyprint">Pending</code> result instead of a Failure if the condition is not met</li>
</ul>
<pre><code class="prettyprint">1 must be_==(2).orPending
1 must be_==(2).orPending(&quot;Precondition failed&quot;)    // prints &quot;Precondition failed: '1' is not equal to '2'&quot;
1 must be_==(2).orPending((ko:String) =&gt; &quot;BAD &quot;+ko) // prints &quot;BAD '1' is not equal to '2'&quot;
</code></pre>
<ul>
  <li><p>using <code class="prettyprint">mute</code> to change a Matcher so that it returns MatchResults with no messages. This is used in Forms to create<br />    properties showing no messages when they fail</p></li>
  <li><p>using <code class="prettyprint">updateMessage(f: String =&gt; String)</code> or <code class="prettyprint">setMessage(m: String)</code> to change the failure message</p></li>
  <li><p>using <code class="prettyprint">&lt;==&gt;</code> or <code class="prettyprint">==&gt;</code> to provide a meaning for the expectation when the failure message would not be clear </p></li>
</ul>
<pre><code class="prettyprint">// when failing, this displays:
// The byname function has not become a strict one because 'evaluated' is not equal to 'not evaluated'
&quot;The byname function has become a strict one&quot; &lt;==&gt; (parameter === &quot;evaluated&quot;)
</code></pre><p>Note that the sentence describing the expectation is negated when there is a failure. This functionality is provided by the <code class="prettyprint">org.specs2.text.Sentences::negateSentence</code> trait. You can override this method if you want/need to provide a better behavior for this feature.</p><a name="From+functions"><h5>From functions</h5></a><p>Another easy way to create matchers, is to use some implicit conversions from functions to Matchers: </p>
<pre><code class="prettyprint">val m: Matcher[String]  = ((_: String).startsWith(&quot;hello&quot;), &quot;doesn't start with hello&quot;)
val m1: Matcher[String] = ((_: String).startsWith(&quot;hello&quot;), &quot;starts with hello&quot;, &quot;doesn't start with hello&quot;)
val m2: Matcher[String] = ((_: String).startsWith(&quot;hello&quot;), (s:String) =&gt; s+ &quot; doesn't start with hello&quot;)
val m3: Matcher[String] = ((_: String).startsWith(&quot;hello&quot;), (s:String) =&gt; s+ &quot; starts with hello&quot;, (s:String) =&gt; s+ &quot; doesn't start with hello&quot;)
val m4: Matcher[String] = (s: String) =&gt; (s.startsWith(&quot;hello&quot;), s+&quot; doesn't start with hello&quot;)
val m5: Matcher[String] = (s: String) =&gt; (s.startsWith(&quot;hello&quot;), s+ &quot;starts with hello&quot;, s+ &quot; doesn't start with hello&quot;)
</code></pre><p>And if you want absolute power over matching, you can define your own matcher: </p>
<pre><code class="prettyprint">class MyOwn extends Matcher[String] {
  def apply[S &lt;: String](s: Expectable[S]) = {
    result(s.value.isEmpty,
           s.description + &quot; is empty&quot;,
           s.description + &quot; is not empty&quot;,
           s)
  }
}
</code></pre><p>In the code above you have to:</p>
<ul>
  <li><p>define the <code class="prettyprint">apply</code> method (and its somewhat complex signature)</p></li>
  <li><p>use the protected <code class="prettyprint">result</code> method to return: a Boolean condition, a message when the match is ok, a message when the<br />    match is not ok, the &quot;expectable&quot; value. Note that if you change the expectable value you need to use the <code class="prettyprint">map</code> method<br />    on the <code class="prettyprint">s</code> expectable (<code class="prettyprint">s.map(other)</code>). This way you preserve the ability of the Expectable to throw an Exception if<br />    a subsequent match fails</p></li>
  <li><p>you can use the <code class="prettyprint">description</code> method on the <code class="prettyprint">Expectable</code> class to return the full description of the expectable including<br />    the optional description you setup using the <code class="prettyprint">aka</code> method</p></li>
</ul><a name="From+Hamcrest"><h5>From Hamcrest</h5></a><p>If you have Hamcrest matchers in your project and you want to reuse them as specs2 matchers, you can mix-in the <code class="prettyprint">org.specs2.matcher.Hamcrest</code> trait: </p>
<pre><code class="prettyprint">class HamcrestSpec extends Specification with Grouped with Hamcrest { def is = s2&quot;&quot;&quot;

  Hamcrest matchers can be used as specs2 matchers by mixing in the Hamcrest trait
  for example a beEven Hamcrest matcher can be used in a 'must' expression              ${g1.e1}
    the failure message must contain the matched value and the Hamcrest failure message ${g1.e2}
                                                                                        &quot;&quot;&quot;

  new g1 {
    e1 := 2 must beEven
    e2 := (3 must beEven).message === &quot;&lt;3&gt; is odd&quot;
  }

  // a Hamcrest matcher for even numbers
  object beEven extends BaseMatcher[Int] {
    def matches(item: Object): Boolean       = item.toString.toInt % 2 == 0
    def describeTo(description: Description) { description.appendText(&quot; is odd&quot;) }
  }

}
</code></pre><a name="With+sequences"><h4>With sequences</h4></a><p>If you have the same &quot;MatchResult&quot; expression that you'd like to verify for different values you can write one of the following: </p></div></status><status class="ok"><div style="display: show; text-indent:0px;"><pre><code class="prettyprint">// stop after the first failure
((_:Int) must be_&gt;(2)).forall(Seq(3, 4, 5))
forall(Seq(3, 4, 5)) ((_:Int) must be_&gt;(2))
// check only the elements defined for the partial function
forallWhen(Seq(3, 10, 15)) { case a if a &gt; 3 =&gt; a must be_&gt;(5) }

// try to match all values and collect the results
((_:Int) must be_&gt;(2)).foreach(Seq(3, 4, 5))
foreach(Seq(3, 4, 5)) ((_:Int) must be_&gt;(2))
// check only the elements defined for the partial function
foreachWhen(Seq(3, 10, 15)) { case a if a &gt; 3 =&gt; a must be_&gt;(5) }

// succeeds after the first success
((_:Int) must be_&gt;(2)).atLeastOnce(Seq(3, 4, 5))
atLeastOnce(Seq(3, 4, 5)) ((_:Int) must be_&gt;(2))
// check only the elements defined for the partial function
atLeastOnceWhen(Seq(3, 4, 10)) { case a if a &gt; 3 =&gt; a must be_&gt;(5) }
</code></pre></div></status><status class="ok"><div style="display: show; text-indent:0px;"><a name="ScalaCheck"><h3>ScalaCheck</h3></a><p>A clever way of creating expectations in <strong><em>specs2</em></strong> is to use the <a href="http://code.google.com/p/scalacheck">ScalaCheck</a> library.</p><p>To declare ScalaCheck properties you first need to extend the <code class="prettyprint">ScalaCheck</code> trait. Then you can pass functions returning any kind of <code class="prettyprint">Result</code> (<code class="prettyprint">Boolean</code>, <code class="prettyprint">Result</code>, <code class="prettyprint">MatchResult</code>) to the <code class="prettyprint">prop</code> method and use the resulting <code class="prettyprint">Prop</code> as your example body: <code class="prettyprint">&quot;addition and multiplication are related&quot; ! prop { (a: Int) =&gt; a + a == 2 * a }</code></p><p>The function that is checked can either return: </p>
<pre><code class="prettyprint">// a Boolean
&quot;addition and multiplication are related&quot; ! prop { (a: Int) =&gt; a + a == 2 * a }

// a MatchResult
&quot;addition and multiplication are related&quot; ! prop { (a: Int) =&gt; a + a must_== 2 * a }

// a Prop
&quot;addition and multiplication are related&quot; ! prop { (a: Int) =&gt; (a &gt; 0) ==&gt; (a + a must_== 2 * a) }
</code></pre><p>Note that if you pass functions using <code class="prettyprint">MatchResult</code>s you will get better failure messages so you are encouraged to do so.</p><p>By default the properties created with <code class="prettyprint">prop</code> will be shrinking counter-examples. If you want to avoid this, you can use <code class="prettyprint">propNoShrink</code> instead.</p><a name="Arbitrary+instances"><h4>Arbitrary instances</h4></a><p>By default ScalaCheck uses <code class="prettyprint">Arbitrary</code> instances taken from the surrounding example scope. However you'll certainly need to generate your own data from time to time. In that case you can create an <code class="prettyprint">Arbitrary</code> instance and make sure it is in the scope of the function you're testing: </p>
<pre><code class="prettyprint">// this arbitrary will be used for all the examples
implicit def a = Arbitrary { for { a &lt;- Gen.oneOf(&quot;a&quot;, &quot;b&quot;); b &lt;- Gen.oneOf(&quot;a&quot;, &quot;b&quot;) } yield a+b }

&quot;a simple property&quot; ! ex1

def ex1 = check((s: String) =&gt; s must contain(&quot;a&quot;) or contain(&quot;b&quot;))
</code></pre><p>You can also be very specific if you want to use an <code class="prettyprint">Arbitrary</code> instance only on one example. In that case, just replace the <code class="prettyprint">check</code> method with the name of your <code class="prettyprint">Arbitrary</code> instance: </p>
<pre><code class="prettyprint">&quot;a simple property&quot;       ! ex1
&quot;a more complex property&quot; ! ex2

implicit def abStrings = Arbitrary { for { a &lt;- Gen.oneOf(&quot;a&quot;, &quot;b&quot;); b &lt;- Gen.oneOf(&quot;a&quot;, &quot;b&quot;) } yield a+b }
def ex1 = abStrings((s: String) =&gt; s must contain(&quot;a&quot;) or contain(&quot;b&quot;))

// use a tuple if there are several parameters to your function
def ex2 = (abStrings, abStrings)((s1: String, s2: String) =&gt; (s1+s2) must contain(&quot;a&quot;) or contain(&quot;b&quot;))
</code></pre><a name="With+Generators"><h4>With Generators</h4></a><p>ScalaCheck also allows to create <code class="prettyprint">Prop</code>s directly with the <code class="prettyprint">Prop.forAll</code> method accepting <code class="prettyprint">Gen</code> instances: </p>
<pre><code class="prettyprint">&quot;a simple property&quot;       ! ex1
&quot;a more complex property&quot; ! ex2

def abStrings = for { a &lt;- Gen.oneOf(&quot;a&quot;, &quot;b&quot;); b &lt;- Gen.oneOf(&quot;a&quot;, &quot;b&quot;) } yield a+b

def ex1 = Prop.forAll(abStrings) { (s: String) =&gt; s must contain(&quot;a&quot;) or contain(&quot;b&quot;) }
def ex2 = Prop.forAll(abStrings, abStrings) { (s1: String, s2: String) =&gt; (s1+s2) must contain(&quot;a&quot;) or contain(&quot;b&quot;) }
</code></pre><a name="Test+properties"><h4>Test properties</h4></a><p>ScalaCheck test generation can be tuned with a few properties. If you want to change the default settings, you have to use implicit values: </p>
<pre><code class="prettyprint">implicit val params = Parameters(minTestsOk = 20) // add &quot;verbose = true&quot; to get additional console printing
</code></pre><p>It is also possible to specifically set the execution parameters on a given property: </p>
<pre><code class="prettyprint">&quot;this is a specific property&quot; ! prop { (a: Int, b: Int) =&gt;
  (a + b) must_== (b + a)
}.set(minTestsOk = 200, workers = 3)
</code></pre><p>The parameters you can modify are:</p>
<ul>
  <li><code class="prettyprint">minTestsOk</code>: minimum of tests which must be ok before the property is ok (default = 100)</li>
  <li><code class="prettyprint">maxDiscardRatio</code>: if the data generation discards too many values, then the property can't be proven (default = 5)</li>
  <li><code class="prettyprint">minSize</code>: minimum size for the &quot;sized&quot; data generators, like list generators (default = 0)</li>
  <li><code class="prettyprint">maxSize</code>: maximum size for the &quot;sized&quot; data generators (default = 100)</li>
  <li><code class="prettyprint">workers</code>: number of threads checking the property (default = 1)</li>
  <li><code class="prettyprint">rng</code>: the random number generator (default = <code class="prettyprint">new java.util.Random</code>)</li>
  <li><code class="prettyprint">callback</code>: a ScalaCheck TestCallback (see the ScalaCheck documentation)</li>
  <li><code class="prettyprint">loader</code>: a custom classloader (see the ScalaCheck documentation)</li>
</ul><p>You can also set the random generator that is used in all the ScalaCheck generators: </p></div></status><status class="ok"><div style="display: show; text-indent:0px;"><pre><code class="prettyprint">case class MyRandomGenerator() extends java.util.Random {
  // implement a deterministic generator for example
}

&quot;this is a specific property&quot; ! prop { (a: Int, b: Int) =&gt;
  (a + b) must_== (b + a)
}.set(rng = MyRandomGenerator(), minTestsOk = 200, workers = 3)
</code></pre><a name="Expectations"><h4>Expectations</h4></a><p>By default, a successful example using a <code class="prettyprint">Prop</code> will be reported as 1 success and 100 (or <code class="prettyprint">minTestsOk</code>) expectations. If you don't want the number of expectations to appear in the specification statistics just mix-in your specification the <code class="prettyprint">org.specs2.matcher.OneExpectationPerProp</code> trait.</p></div></status><status class="ok"><div style="display: show; text-indent:0px;"><a name="Mock+expectations"><h3>Mock expectations</h3></a><p>At the moment only the <a href="http://mockito.org">Mockito</a> library is supported.</p><p>Mockito allows to specify stubbed values and to verify that some calls are expected on your objects. In order to use those functionalities, you need to extend the <code class="prettyprint">org.specs2.mock.Mockito</code> trait: </p>
<pre><code class="prettyprint">import org.specs2.mock._
class MockitoSpec extends Specification { def is = s2&quot;&quot;&quot;

  A java list can be mocked
    You can make it return a stubbed value                                     ${c().stub}
    You can verify that a method was called                                    ${c().verify}
    You can verify that a method was not called                                ${c().verify2}
  &quot;&quot;&quot;
case class c() extends Mockito {
  val m = mock[java.util.List[String]] // a concrete class would be mocked with: mock[new java.util.LinkedList[String]]
  def stub = {
    m.get(0) returns &quot;one&quot;             // stub a method call with a return value
    m.get(0) must_== &quot;one&quot;             // call the method
  }
  def verify = {
    m.get(0) returns &quot;one&quot;             // stub a method call with a return value
    m.get(0)                           // call the method
    there was one(m).get(0)            // verify that the call happened
  }
  def verify2 = there was no(m).get(0) // verify that the call never happened
  }
}
</code></pre><a name="Creation+and+settings"><h5>Creation and settings</h5></a><p>Mockito offers the possibility to provide specific settings for the mock being created:</p>
<ul>
  <li>its name</li>
</ul><p><code class="prettyprint">val m = mock[List[String]].as(&quot;list1&quot;)</code></p>
<ul>
  <li>&quot;smart&quot; return values</li>
</ul><p><code class="prettyprint">val m = mock[List[String]].smart</code></p>
<ul>
  <li>&quot;verbose&quot; enables Mockito's verbose logging</li>
</ul><p><code class="prettyprint">val m = mock[List[String]].verbose</code></p>
<ul>
  <li>specific return values</li>
</ul><p><code class="prettyprint">val m = mock[List[String]].defaultReturn(10)</code></p>
<ul>
  <li>specific answers</li>
</ul>
<pre><code class="prettyprint">// a function InvocationOnMock =&gt; V is used in place of the org.mockito.stubbing.Answer type for better conciseness
val helloObject = (p1: InvocationOnMock) =&gt; &quot;hello &quot;+p1.toString
val m = mock[List[String]].defaultAnswer(helloObject)
</code></pre>
<ul>
  <li>extra interfaces</li>
</ul>
<pre><code class="prettyprint">val m1 = mock[List[String]].extraInterface[Cloneable]
val m2 = mock[List[String]].extraInterfaces[Cloneable, Serializable]
</code></pre><p>Now, if you want to combine several of those settings together you need to call the <code class="prettyprint">settings</code> method: </p>
<pre><code class="prettyprint">val m1 = mock[List[String]].settings(name = &quot;list1&quot;,
defaultReturn = 10,
extraInterfaces = classesOf[Cloneable, Serializable])
// or
val m2 = mock[List[String]].settings(smart = true,
extraInterface = classOf[Cloneable])
</code></pre><p>Finally, in case the Mockito library gets new settings, you can declare the following: </p>
<pre><code class="prettyprint">val settings = org.mockito.Mockito.withSettings
val m = mock[List[String]](settings)
</code></pre><a name="Stubbing"><h5>Stubbing</h5></a><p>Stubbing values is as simple as calling a method on the mock and declaring what should be returned or thrown: </p>
<pre><code class="prettyprint">m.get(1) returns &quot;one&quot;
m.get(2) throws new RuntimeException(&quot;forbidden&quot;)
</code></pre><p>You can specify different consecutive returned values by appending thenReturns or thenThrows: </p>
<pre><code class="prettyprint">m.get(1) returns &quot;one&quot; thenReturns &quot;two&quot;
m.get(2) throws new RuntimeException(&quot;forbidden&quot;) thenReturns &quot;999&quot;
</code></pre><a name="Mocking+and+Stubbing+at+the+same+time"><h6>Mocking and Stubbing at the same time</h6></a><p>It is also possible to create a mock while stubbing one of its methods, provided that you declare the type of the expected mock: </p>
<pre><code class="prettyprint">val mocked: java.util.List[String] = mock[java.util.List[String]].contains(&quot;o&quot;) returns true
mocked.contains(&quot;o&quot;) must beTrue
</code></pre><a name="With+matchers"><h5>With matchers</h5></a><p>The built-in Mockito argument matchers can be used to specify the method arguments for stubbing: </p>
<pre><code class="prettyprint">m.get(anyInt()) returns &quot;element&quot;
m.get(999) must_== &quot;element&quot;
</code></pre><p><strong><em>specs2</em></strong> matchers can also be passed directly as arguments: <code class="prettyprint">m.get(===(123)) returns &quot;one&quot;</code></p><a name="Callbacks"><h5>Callbacks</h5></a><p>In some rare cases, it is necessary to have the return value depend on the parameters passed to the mocked method: <code class="prettyprint">m.get(anyInt) answers { i =&gt; &quot;The parameter is &quot; + i.toString</code></p><p>The function passed to <code class="prettyprint">answers</code> will be called with each parameter passed to the stubbed method: </p>
<pre><code class="prettyprint">m.get(0)    // returns &quot;The parameter is 0&quot;
m.get(1)    // the second call returns a different value: &quot;The parameter is 1&quot;
</code></pre><a name="Parameters+for+the+answers+function"><h6>Parameters for the <code class="prettyprint">answers</code> function</h6></a><p>Because of the use of reflection the function passed to answers will receive only instances of the <code class="prettyprint">java.lang.Object</code> type.</p><p>More precisely, it will:</p>
<ul>
  <li>pass the mock object if both the method has no parameters and the function has one parameter:<br /><code class="prettyprint">mock.size answers { mock =&gt; mock.hashCode }</code></li>
  <li>pass the parameter if both the method and the function have one parameter:<br /><code class="prettyprint">mock.get(0) answers { i =&gt; i.toString }</code></li>
  <li>pass the parameter and the mock object if the method has 1 parameter and the function has 2:<br /><code class="prettyprint">mock.get(0) answers { (i, mock) =&gt; i.toString + &quot; for mock &quot; + mock.toString }</code></li>
</ul><p>In any other cases, if <code class="prettyprint">f</code> is a function of 1 parameter, the array of the method parameters will be passed and if the function has 2 parameters, the second one will be the mock.</p><a name="Verification"><h5>Verification</h5></a><p>By default Mockito doesn't expect any method to be called. However if your writing interaction-based specifications you want to specify that some methods are indeed called: </p>
<pre><code class="prettyprint">there was one(m).get(0)              // one call only to get(0)
there was no(m).get(0)               // no calls to get(0)

// were can also be used
there were two(m).get(0)             // 2 calls exactly to get(0)
there were three(m).get(0)           // 3 calls exactly to get(0)
there were 4.times(m).get(0)         // 4 calls exactly to get(0)

there was atLeastOne(m).get(0)       // at least one call to get(0)
there was atLeastTwo(m).get(0)       // at least two calls to get(0)
there was atLeastThree(m).get(0)     // at least three calls to get(0)
there was atLeast(4)(m).get(0)       // at least four calls to get(0)

there was atMostOne(m).get(0)        // at most one call to get(0)
there was atMostTwo(m).get(0)        // at most two calls to get(0)
there was atMostThree(m).get(0)      // at most three calls to get(0)
there was atMost(4)(m).get(0)        // at most four calls to get(0)

// the combinators above, except `atMost`, can also be used with a timeout
there was after(10.millis).one(m).get(0)
there was after(2.seconds).two(m).get(0)
</code></pre><p>It is also possible to add all verifications inside a block, when several mocks are involved: </p>
<pre><code class="prettyprint">got {
one(m).get(0)
two(m).get(1)
}
</code></pre><a name="Order+of+calls"><h6>Order of calls</h6></a><p>The order of method calls can be checked by creating calls and chaining them with <code class="prettyprint">andThen</code>: </p>
<pre><code class="prettyprint">val m1 = mock[List[String]]
val m2 = mock[List[String]]

m1.get(0)
m1.get(0)
m2.get(0)

there was one(m1).get(0) andThen one(m1).get(1)
</code></pre><p>when several mocks are involved, the expected order must be specified as an implicit value: </p>
<pre><code class="prettyprint">val m1 = mock[List[String]]
val m2 = mock[List[String]]
</code></pre><a name="Ignoring+stubs"><h6>Ignoring stubs</h6></a><p>When specifying the behavior of an object in relation to others you may want to verify that some mocks have been called as collaborators and you don't really want to specify what happens to other mocks because they are just playing the role of stubs.</p><p>In this case the <code class="prettyprint">ignoreStubs</code> method can be used: </p>
<pre><code class="prettyprint">val (stub1, stub2) = (mock[AStub], mock[AStub])
there were noMoreCallsTo(ignoreStubs(stub1, stub2))
</code></pre><p>This method is also available with the <code class="prettyprint">inOrder</code> method: </p>
<pre><code class="prettyprint">val (list1, list2) = (&quot;&quot;, &quot;&quot;)
</code></pre><p>For more documentation about this Mockito functionality, please read <a href="http://docs.mockito.googlecode.com/hg/1.9.0/org/mockito/Mockito.html#25">here</a>.</p><a name="Spies"><h6>Spies</h6></a><p>Spies can be used in order to do some &quot;partial mocking&quot; of real objects: </p>
<pre><code class="prettyprint">val spiedList = spy(new LinkedList[String])

// methods can be stubbed on a spy
spiedList.size returns 100

// other methods can also be used
spiedList.add(&quot;one&quot;)
spiedList.add(&quot;two&quot;)

// and verification can happen on a spy
there was one(spiedList).add(&quot;one&quot;)
</code></pre><p>However, working with spies can be tricky: </p>
<pre><code class="prettyprint">// if the list is empty, this will throws an IndexOutOfBoundsException
spiedList.get(0) returns &quot;one&quot;
</code></pre><p>As advised in the Mockito documentation, doReturn must be used in that case: </p>
<pre><code class="prettyprint">org.mockito.Mockito.doReturn(&quot;one&quot;).when(spiedList).get(0)
</code></pre><a name="Functions%2FPartialFunctions"><h6>Functions/PartialFunctions</h6></a><p>It is possible to verify method calls where parameters are functions by specifying how the passed function will react to a given set of arguments. Given the following mock:</p>
<pre><code class="prettyprint">trait Amount {
// a method showing an amount precision
def show(display: Function2[Double, Int, String]) = ???
}
val amount = mock[Amount]
</code></pre><p>If the mock is called with this function: </p>
<pre><code class="prettyprint">amount.show((amount: Double, precision: Int) =&gt; &quot;%2.&quot;+precision+&quot;f&quot; format amount)
</code></pre><p>Then it is possible to verify how the mock was called: </p>
<pre><code class="prettyprint">// with sample arguments for the function and the expected result
there was one(amount).show((32.4456, 2) -&gt; &quot;32.45&quot;)

// with a matcher for the result
there was one(amount).show((32.4456, 2) -&gt; endWith(&quot;45&quot;))

// with any Function2[A, B, R]
there was one(amount).show(anyFunction2)
</code></pre><a name="Auto-boxing"><h6>Auto-boxing</h6></a><p>Auto-boxing might interfere with the mocking of PartialFunctions. Please have a look at <a href="https://groups.google.com/d/topic/specs2-users/_bK8lCCjZ4c/discussion">this</a> for a discussion.</p><a name="Byname"><h6>Byname</h6></a><p>Byname parameters can be verified but this will not work if the specs2 jar is not put first on the classpath, before the mockito jar. Indeed specs2 redefines a Mockito class for intercepting method calls so that byname parameters are properly handled.</p><a name="DataTables"><h3>DataTables</h3></a><p>DataTables are a very effective way of grouping several similar examples into one. For example, here is how to specify the addition of integers by providing one example on each row of a table: </p></div></status><status class="ok"><div style="display: show; text-indent:0px;"><pre><code class="prettyprint">class DataTableSpec extends Specification with matcher.DataTables { def is =
  &quot;adding integers should just work in scala&quot;  ! e1

  def e1 =
    &quot;a&quot;   | &quot;b&quot; | &quot;c&quot; |                                   // the header of the table, with `|` separated strings
     2    !  2  !  4  |                                   // an example row
     1    !  1  !  2  |&gt; {                                // the &gt; operator to &quot;execute&quot; the table
     (a, b, c) =&gt;  a + b must_== c                        // the expectation to check on each row
    }
}
</code></pre><a name="Implicit+%21"><h4>Implicit !</h4></a><p>There may be an implicit definition conflict when the first parameter of a row is a String, because examples can also be created by using the <code class="prettyprint">!</code> operator after a String. In that case, depending on which kind of specification you use, you can either:</p>
<ul>
  <li>with an acceptance specification: use the <code class="prettyprint">!!</code> operator to disambiguate (and <code class="prettyprint">||</code> in the header for good visual balance)</li>
  <li>with a unit specification: use the <code class="prettyprint">org.specs2.mutable.Tables</code> trait instead of <code class="prettyprint">org.specs2.matcher.DataTables</code> trait. This will &quot;deactivate&quot; the implicit used to create examples with <code class="prettyprint">!</code></li>
</ul><a name="Forms"><h3>Forms</h3></a><p>Forms are a way to represent domain objects or service, and declare expected values in a tabular format. They are supposed to be used with the HtmlRunner to get human-readable documentation.</p><p>Forms can be designed as reusable pieces of specification where complex forms can be built out of simple ones.</p></div></status><subtoc specId="1202070435"></subtoc><status class="ok"><div style="display: show; text-indent:0px;"><img src="./../images/icon_success_sml.gif" /> Here's <a href="../guide/org.specs2.guide.FormsPage.html" tooltip="">how to use Forms</a></div></status><status class="ok"><div style="display: show; text-indent:0px;"><a name="Outside+specs2"><h3>Outside specs2</h3></a><p>The <strong><em>specs2</em></strong> matchers are a well-delimited piece of functionality that you should be able to reuse in your own test framework. You can reuse the following traits:</p>
<ul>
  <li><p><code class="prettyprint">org.specs2.matcher.MustMatchers</code> (or <code class="prettyprint">org.specs2.matcher.ShouldMatchers</code>) to write anything like <code class="prettyprint">1 must be_==(1)</code> and<br />    get a <code class="prettyprint">Result</code> back</p></li>
  <li><p>You can also use the side-effecting version of that trait called <code class="prettyprint">org.specs2.matcher.MustThrownMatchers</code> (or <code class="prettyprint">org.specs2.matcher.ShouldThrownMatchers</code>).<br />    It throws a <code class="prettyprint">FailureException</code> as soon as an expectation is failing. Those traits can also be used in a regular<br />    Specification if you have several expectations per example and if you don't want to chain them with <code class="prettyprint">and</code>.</p></li>
  <li><p>Finally, in a JUnit-like library you can use the <code class="prettyprint">org.specs2.matcher.JUnitMustMatchers</code> trait which throws<br />    <code class="prettyprint">AssertionFailureError</code>s</p></li>
</ul><a name="Without+any+dependency+on+specs2"><h4>Without any dependency on specs2</h4></a><p>The <a href="https://github.com/spray/spray/wiki/Testing">Testing</a> page of the <strong><em>spray</em></strong> project explains how you can define a testing trait in your library which can be used with specs2 or scalatest or any framework defining the following methods:</p>
<ul>
  <li><code class="prettyprint">fail(msg: String): Nothing</code></li>
  <li><code class="prettyprint">skip(msg: String): Nothing</code></li>
</ul><p>In specs2, those 2 methods are defined by the <code class="prettyprint">org.specs2.matcher.ThrownMessages</code> trait</p>
<pre><code class="prettyprint">trait ThrownMessages { this: ThrownExpectations =&gt;
  def fail(m: String): Nothing = failure(m)
  def skip(m: String): Nothing = skipped(m)
}
</code></pre>
<hr /></div></status><status class="ok"><p></p></status><status class="ok"><br /></status><table class="dataTable">
        <tr><th colSpan="2">Total for specification Matchers</th></tr>
        <tr><td>Finished in</td><td class="info">1 second, 389 ms</td></tr>
        <tr><td>Results</td><td class="success">47 examples, 539 expectations, 0 failure, 0 error</td></tr>
      </table></html></div></div>
                <div class="col2"><div id="leftcolumn"><div id="tree">
      <ul><li id="195980865"><a href="../guide/org.specs2.guide.UserGuide.html#User+Guide">User Guide</a>
            <ul><li id="2096757315"><a href="../guide/org.specs2.guide.QuickStart.html#Quick+Start">Quick Start</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.QuickStart.html#Unit">Unit</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.QuickStart.html#Acceptance">Acceptance</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.QuickStart.html#Execution">Execution</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.QuickStart.html#And+much+more%21">And much more!</a>
            
          </li></ul>
          </li><li id="518748733"><a href="../guide/org.specs2.guide.Structure.html#Structure">Structure</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Declare+examples">Declare examples</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Styles">Styles</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Acceptance+specification">Acceptance specification</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Unit+specification">Unit specification</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Results">Results</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Standard">Standard</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Matchers">Matchers</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Expectations">Expectations</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Functional">Functional</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Thrown">Thrown</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#All">All</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Short-circuit">Short-circuit</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Auto-Examples">Auto-Examples</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#G+%2F+W+%2FT">G / W /T</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#DataTables">DataTables</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Example+groups">Example groups</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Isolation">Isolation</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Tags">Tags</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Selection">Selection</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Formatting">Formatting</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Contexts">Contexts</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Isolation_1">Isolation</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Scope">Scope</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Isolated+variables">Isolated variables</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Case+classes">Case classes</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Contexts+inheritance">Contexts inheritance</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Before%2FAfter">Before/After</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#In+a+mutable+specification">In a mutable specification</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#In+an+acceptance+specification">In an acceptance specification</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Around">Around</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Outside">Outside</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#AroundOutside">AroundOutside</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Fixture">Fixture</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#BeforeExample">BeforeExample</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Implicit+context">Implicit context</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Composition">Composition</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Combinations">Combinations</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Composition_1">Composition</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Steps%2FActions">Steps/Actions</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Steps">Steps</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Actions">Actions</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Template">Template</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Global+setup%2Fteardown">Global setup/teardown</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#For+fragments">For fragments</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Links">Links</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Inclusion">Inclusion</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Inline">Inline</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Html+link">Html link</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Html+Link">Html Link</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Reference">Reference</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Markdown+url">Markdown url</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Execution">Execution</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Unit+specifications">Unit specifications</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Structure.html#Methods">Methods</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Structure.html#Full+example">Full example</a>
            <ul><li id="1280362687"><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Fragments+API">Fragments API</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Rules">Rules</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Formatting+fragments">Formatting fragments</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Separating+groups+of+examples">Separating groups of examples</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Reset+the+levels">Reset the levels</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Changing+the+indentation+level">Changing the indentation level</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Combinations">Combinations</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.structure.FragmentsApi.html#Unit+specification">Unit specification</a>
            
          </li></ul>
          </li><li id="119365343"><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Given+When+Then_1">Given When Then</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Given+When+Then">Given When Then</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Parsing">Parsing</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Delimited+parsers">Delimited parsers</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Regex+parsers">Regex parsers</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Standard+parsers">Standard parsers</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Scenario">Scenario</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.structure.GivenWhenThenPage.html#Tagging">Tagging</a>
            
          </li></ul>
          </li></ul>
          </li></ul>
          </li></ul>
          </li></ul>
          </li><li id="2046015986"><a href="../guide/org.specs2.guide.Matchers.html#Matchers">Matchers</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Boolean+results">Boolean results</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Standard+results">Standard results</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Combinators">Combinators</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Match+results">Match results</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Out+of+the+box">Out of the box</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Optional">Optional</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#File+contents">File contents</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Directories+contents">Directories contents</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Lines+contents">Lines contents</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Custom">Custom</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#From+functions">From functions</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#From+Hamcrest">From Hamcrest</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#With+sequences">With sequences</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#ScalaCheck">ScalaCheck</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Arbitrary+instances">Arbitrary instances</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#With+Generators">With Generators</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Test+properties">Test properties</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Expectations">Expectations</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Mock+expectations">Mock expectations</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Creation+and+settings">Creation and settings</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Stubbing">Stubbing</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Mocking+and+Stubbing+at+the+same+time">Mocking and Stubbing at the same time</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#With+matchers">With matchers</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Callbacks">Callbacks</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Parameters+for+the+answers+function">Parameters for the answers function</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Verification">Verification</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Order+of+calls">Order of calls</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Ignoring+stubs">Ignoring stubs</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Spies">Spies</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Functions%2FPartialFunctions">Functions/PartialFunctions</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Auto-boxing">Auto-boxing</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Byname">Byname</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#DataTables">DataTables</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Implicit+%21">Implicit !</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Forms">Forms</a>
            <ul><li id="1202070435"><a href="../guide/org.specs2.guide.FormsPage.html#FormsPage">FormsPage</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Fields">Fields</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Effects">Effects</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Properties">Properties</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Styles">Styles</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Simple+form">Simple form</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Adding+several+rows+at+once">Adding several rows at once</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Nesting+into+another+Form">Nesting into another Form</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Nesting+into+an+Effect+or+a+Prop">Nesting into an Effect or a Prop</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Using+tabs">Using tabs</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Aggregating+forms">Aggregating forms</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Lazy+cells">Lazy cells</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Xml+cells">Xml cells</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#1-n+relationships">1-n relationships</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Subset">Subset</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Subsequence">Subsequence</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Set">Set</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Sequence">Sequence</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.FormsPage.html#Decision+tables">Decision tables</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Outside+specs2">Outside specs2</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Matchers.html#Without+any+dependency+on+specs2">Without any dependency on specs2</a>
            
          </li></ul>
          </li></ul>
          </li><li id="357921332"><a href="../guide/org.specs2.guide.Runners.html#Runners">Runners</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Dependencies">Dependencies</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Fine-grained+jars">Fine-grained jars</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Arguments">Arguments</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#API">API</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Most%2FLeast+frequently+used+arguments">Most/Least frequently used arguments</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Shortcuts">Shortcuts</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Output+directory">Output directory</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Storing+previous+results">Storing previous results</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Status+flags">Status flags</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Diffs">Diffs</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#StackTraceFilter">StackTraceFilter</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Command+line">Command line</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#System+properties">System properties</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#In+the+shell">In the shell</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Console+output">Console output</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Html+output">Html output</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#JUnit+XML+output">JUnit XML output</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Files+Runner">Files Runner</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#In+the+console">In the console</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Via+SBT">Via SBT</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#testOnly+arguments">testOnly arguments</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Output+formats">Output formats</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Html">Html</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Markdown">Markdown</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#JUnit">JUnit</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Console">Console</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Files+runner">Files runner</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Colors">Colors</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Via+IDEA">Via IDEA</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Via+JUnit">Via JUnit</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Arguments_1">Arguments</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Via+Eclipse">Via Eclipse</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Via+Maven">Via Maven</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#With+your+own">With your own</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#Executor">Executor</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#In+sbt">In sbt</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Notifier">Notifier</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#NotifierRunner">NotifierRunner</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#In+sbt_1">In sbt</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Runners.html#Exporter">Exporter</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Runners.html#In+sbt_2">In sbt</a>
            
          </li></ul>
          </li></ul>
          </li></ul>
          </li><li id="1616640666"><a href="../guide/org.specs2.guide.HowTo.html#HowTo">HowTo</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Declare+arguments">Declare arguments</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Use+command-line+arguments">Use command-line arguments</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Add+a+title">Add a title</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Use+descriptions">Use descriptions</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Pending+until+fixed">Pending until fixed</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Enhance+failures">Enhance failures</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Share+examples">Share examples</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Create+an+index">Create an index</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Tag+examples">Tag examples</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.HowTo.html#In+a+unit+specification">In a unit specification</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Skip+examples">Skip examples</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Debug+statements">Debug statements</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Remove+implicits">Remove implicits</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Print+execution+data">Print execution data</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.HowTo.html#With+example+description">With example description</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#Capture+snippets">Capture snippets</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.HowTo.html#snippet">snippet</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#cuts">cuts</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#evaluation">evaluation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#offsets">offsets</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#parameters">parameters</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#names">names</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.HowTo.html#outside+specs2">outside specs2</a>
            
          </li></ul>
          </li></ul>
          </li><li id="933385725"><a href="../guide/org.specs2.guide.Philosophy.html#Philosophy">Philosophy</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#The+origins">The origins</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#The+score">The score</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Conciseness">Conciseness</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Readability">Readability</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Extensibility">Extensibility</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Configuration">Configuration</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Clear+implementation">Clear implementation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#User+support">User support</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#A+new+hope">A new hope</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Functional+%2F+immutable">Functional / immutable</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Chaining+everything">Chaining everything</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Arguments+have+to+be+supplied">Arguments have to be supplied</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Concurrency+is+a+breeze">Concurrency is a breeze</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#A+simple+structure">A simple structure</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Contexts">Contexts</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Indentation">Indentation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Operators">Operators</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Forms">Forms</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#But+if+you+STILL+want+mutable+specifications">But if you STILL want mutable specifications</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Dependencies+control">Dependencies control</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Implicit+definitions+control">Implicit definitions control</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Philosophy.html#Enter+Scala+2.10">Enter Scala 2.10</a>
            
          </li></ul>
          </li></ul>
          </li><li id="692223377"><a href="../guide/org.specs2.guide.Design.html#Design">Design</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Design.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Design.html#Structure">Structure</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Design.html#Creation">Creation</a>
            <ul><li id=""><a href="../guide/org.specs2.guide.Design.html#Creating+Fragments">Creating Fragments</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Design.html#Mutable+Specification">Mutable Specification</a>
            
          </li></ul>
          </li><li id=""><a href="../guide/org.specs2.guide.Design.html#Execution">Execution</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Design.html#Reporting">Reporting</a>
            
          </li><li id=""><a href="../guide/org.specs2.guide.Design.html#Dependencies">Dependencies</a>
            
          </li></ul>
          </li></ul>
          </li></ul>
      <script>$(function () {  $('#tree').jstree({'core':{'initially_open':['195980865','2046015986'], 'animation':200}, 'plugins':['themes', 'html_data']}); });</script>
    </div></div></div>
                <div class="col3"><div id="rightcolumn"></div></div>
              </div>
            </div>
          </div></body></html>
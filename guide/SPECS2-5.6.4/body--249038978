

The most frequent way to specify some expected behaviour with <s2>specs2</s2> is to use _matchers_. You generally execute an action, a command or a function and then check if the actual value you get is equal to an expected one (the ["arrange-act-assert"](http://bit.ly/arrange_act_assert) paradigm).

For example, if you create a specification for an object manipulating paths:

```
// describe the functionality
s2"the directoryPath method should return well-formed paths $e1"

// give an example with some code
def e1 = Paths.directoryPath("/tmp/path/to/dir") must beEqualTo("/tmp/path/to/dir/")
```


The `must` operator takes the actual value returned by `directoryPath` and applies it to a `Matcher` built with the expected value. `beEqualTo` is one of the many matchers defined by <s2>specs2</s2>, it just checks if 2 values are equal.

In the following sections you will learn:

 - the different ways of checking the [equality](#equality) of values
 - how to use the matchers for the most [common data types](#out-of-the-box) in Scala, and most notably collections
 - how to use [other types of matchers](#optional) in less common situations: json, xml, files,...
 - how to [derive](#derive-matchers) a new matcher from an existing one
 - how to create [your own matchers](#create-your-own)

### Equality


The most common type of matcher is `beEqualTo` to test the equality of 2 values with the underlying `==` operator where:

 - the compared types must be the same (as if the `language:strictEquality` option has been turned on)

 - the comparison of `Arrays` uses the `.deep` method on `Arrays`, transforming them to `IndexedSeqs` (possibly nested)
   Otherwise `==` on arrays uses the reference equality, so that `Array(1, 2, 3) === Array(1, 2, 3)`, despite the fact that `Array(1, 2, 3) != Array(1, 2, 3)`

Several syntaxes can be used, according to your own taste

 Matcher                    |  Comment
 -------------------------- | --------------------------
 `1 must beEqualTo(1)      `| the normal way
 `1 must be_==(1)          `| with a symbol
 `1 should be_==(1)        `| for should lovers
 `1 === 1                  `| the ultimate shortcut

There are also other notions of equality:

 Matcher            |  Comment
 ----------         | -----------------------------------------------------
 `be_==~           `| check if `(a: A) === conversion(b: B)` when there is an implicit conversion `Conversion[B, A]`
 `beTheSameAs      `| reference equality: check if `a eq b` (`a must be(b)` also works)
 `be               `| `a must be(b)`: synonym for `beTheSameAs`
 `beTrue, beFalse  `| shortcuts for Boolean equality
 `beLike           `| partial equality, using a `PartialFunction[T, Result]`: `(1, 2) must beLike { case (1, _) => ok }`

Now let's check out the other matchers.

### Out of the box

These are the all the available matchers when you extend `Specification`:

<td class="info"><form>
    <table><tr><th colspan="101">Specification matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="String"><form>
    <table><tr><td class="none" style="info"><p>Matching on strings is very common. Here are the matchers which can help you:</p>
<table>
  <thead>
    <tr><th>Matcher                               </th><th> Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code class="prettyprint">beMatching</code>                          </td><td> check if a string matches a regular expression</td></tr>
    <tr><td><code class="prettyprint">beMatchingWithPart(s)</code>               </td><td> shortcut for <code class="prettyprint">beMatching(&quot;(.|\\s)*&quot;+s+&quot;(.|\\s)*&quot;)</code> (alias: <code class="prettyprint">=~</code>)</td></tr>
    <tr><td><code class="prettyprint">find(exp).withGroups(a, b, c)</code>       </td><td> check if some groups are found in a string</td></tr>
    <tr><td><code class="prettyprint">haveSize</code>                            </td><td> check the size of a string (alias <code class="prettyprint">haveLength</code>)</td></tr>
    <tr><td><code class="prettyprint">beEmpty</code>                             </td><td> check if a string is empty</td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).ignoreCase</code>             </td><td> check if 2 strings are equal regardless of casing</td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).ignoreSpace</code>            </td><td> check if 2 strings are equal when you <code class="prettyprint">replaceAll(&quot;\\s&quot;, &quot;&quot;)</code></td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).trimmed</code>                </td><td> check if 2 strings are equal when trimmed</td></tr>
    <tr><td><code class="prettyprint">beEqualTo(b).ignoreSpace.ignoreCase</code> </td><td> you can compose them</td></tr>
    <tr><td><code class="prettyprint">contain(b)</code>                          </td><td> check if a string contains another one</td></tr>
    <tr><td><code class="prettyprint">startWith(b)</code>                        </td><td> check if a string starts with another one</td></tr>
    <tr><td><code class="prettyprint">endWith(b)</code>                          </td><td> check if a string ends with another one</td></tr>
  </tbody>
</table>
</td></tr></table></form></div><div class="tabbertab" title="Traversable"><form>
    <table><tr><td class="none" style="info"><p>Traversables can be checked with several matchers. If you want to check the size of a <code class="prettyprint">Traversable</code></p>
<ul>
  <li>
    <p>check if it is empty<br/>
    <code class="prettyprint">Seq() must beEmpty</code><br/>
    <code class="prettyprint">Seq(1, 2, 3) must not(beEmpty)</code></p>
  </li>
  <li>
    <p>check its size<br/>
    <code class="prettyprint">Seq(1, 2) must haveSize(2)</code><br/>
    <code class="prettyprint">Seq(1, 2) must haveLength(2)</code> // equivalent to size<br/>
    <code class="prettyprint">Seq(1, 2) must haveSize(be_&gt;=(1))</code> // with a matcher</p>
  </li>
  <li>
    <p>check its ordering (works with any type <code class="prettyprint">T</code> which has an <code class="prettyprint">Ordering</code>)<br/>
    <code class="prettyprint">Seq(1, 2, 3) must beSorted</code></p>
  </li>
</ul>
<h4><a href="#check-each-element-individually" id="check-each-element-individually">Check each element individually</a></h4>
<p>Then you can check the elements which are contained in the Traversable</p>
<ul>
  <li>
    <p>if a simple value is contained<br/>
    <code class="prettyprint">Seq(1, 2, 3) must contain(2)</code></p>
  </li>
  <li>
    <p>if a value matching a specific matcher is contained<br/>
    <code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;=(2))</code></p>
  </li>
  <li>
    <p>if a value passing a function returning a <code class="prettyprint">Result</code> is contained<br/>
    <code class="prettyprint">Seq(1, 2, 3) must contain((i: Int) =&gt; i must be_&gt;=(2))</code></p>
  </li>
  <li>
    <p>note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in another you need to use a matcher<br/>
    <code class="prettyprint">Seq(Seq(1)) must contain(===(Seq(1)))</code></p>
  </li>
  <li>
    <p>there are also 2 specialized matchers to check the string representation of the elements<br/>
    <code class="prettyprint">Seq(1234, 6237) must containMatch(&quot;23&quot;)</code>   <code class="prettyprint">// matches with &quot;.*23.*&quot;</code><br/>
    <code class="prettyprint">Seq(1234, 6234) must containPattern(&quot;.*234&quot;)</code>   <code class="prettyprint">// matches with &quot;.*234&quot;</code></p>
  </li>
</ul>
<p>For each of the check above you can indicate how many times the check should be satisfied:</p>
<ul>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).forall</code>  // this will stop after the first failure</li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).foreach</code> // this will report all failures</li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(0)).atLeastOnce</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).atMostOnce</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).exactly(1.times)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(2)).exactly(1)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(1)).between(1.times, 2.times)</code></li>
  <li><code class="prettyprint">Seq(1, 2, 3) must contain(be_&gt;(1)).between(1, 2)</code></li>
</ul>
<h4><a href="#check-all-elements" id="check-all-elements">Check all elements</a></h4>
<p>The other types of checks involve comparing the Traversable elements to other elements (values, matchers, function returning a <code class="prettyprint">Result</code>)</p>
<ul>
  <li>
    <p>with a set of values<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(2, 4)</code><br/>
    which is the same thing as<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(2, 4))</code></p>
  </li>
  <li>
    <p>with a set of matchers<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(be_&gt;(0), be_&gt;(1)))</code></p>
  </li>
  <li>
    <p>checking that the order is satisfied<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(allOf(be_&gt;(0), be_&gt;(1)).inOrder)</code></p>
  </li>
</ul>
<p>Note that <code class="prettyprint">allOf</code> tries to make each check be successful at least once, even if it is on the same value. On the other hand, if you want to specify that each check must succeed on a <em>different</em> value you should use <code class="prettyprint">onDistinctValues</code>. For example this will fail:<br/>
<code class="prettyprint">Seq(1) must contain(allOf(1, 1)).onDistinctValues</code></p>
<p>The <code class="prettyprint">eachOf</code> method does the same thing (and this example will fail as well):<br/>
<code class="prettyprint">Seq(1) must contain(eachOf(1, 1))</code></p>
<p>Another frequent use of Traversable matchers is to check if the Traversable have the right number of elements. For this you can use:</p>
<ul>
  <li>
    <p><code class="prettyprint">atLeast</code>, which is actually another name for <code class="prettyprint">allOf</code>, where the traversable can contain more elements than required<br/>
    <code class="prettyprint">Seq(1, 2, 3, 4) must contain(atLeast(2, 4))</code></p>
  </li>
  <li>
    <p><code class="prettyprint">atMost</code> where the traversable can not contain more elements than required<br/>
    <code class="prettyprint">Seq(2, 3) must contain(atMost(2, 3, 4))</code></p>
  </li>
  <li>
    <p><code class="prettyprint">exactly</code> where the traversable must contain exactly the specified number of elements<br/>
    <code class="prettyprint">Seq(1, 2) must contain(exactly(2, 1))</code></p>
  </li>
</ul>
<p>The <code class="prettyprint">atLeast/atMost/exactly</code> operators work on distinct values by default (because this is easier for counting the correspondence between actual values and expected ones). However you can use <code class="prettyprint">onDistinctValues(false)</code> if you don't care.</p>
<p>Finally, if you want to get the differences between 2 traversables:</p>
<p><code class="prettyprint">Seq(2, 4, 1) must containTheSameElementsAs(Seq(1, 4, 2))</code></p>
</td></tr></table></form></div><div class="tabbertab" title="Numeric"><form>
    <table><tr><td class="none" style="info"><p>Numerical values can be compared with the following matchers</p>
<ul>
  <li>
    <p><code class="prettyprint">beLessThanOrEqualTo</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&lt;=</code><br/>
    <code class="prettyprint">1 must be_&lt;=(2)</code><br/>
    <code class="prettyprint">1 must beLessThanOrEqualTo(2)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beLessThan</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&lt;</code><br/>
    <code class="prettyprint">1 must be_&lt;(2)</code><br/>
    <code class="prettyprint">1 must beLessThan(2)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beGreaterThanOrEqualTo</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&gt;=</code><br/>
    <code class="prettyprint">2 must be_&gt;=(1)</code><br/>
    <code class="prettyprint">2 must beGreaterThanOrEqualTo(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beGreaterThan</code> compares any <code class="prettyprint">Ordered</code> type with <code class="prettyprint">&gt;</code><br/>
    <code class="prettyprint">2 must be_&gt;(1)</code><br/>
    <code class="prettyprint">2 must beGreaterThan(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beCloseTo</code> check if 2 Numerics are close to each other<br/>
    <code class="prettyprint">1.0 must beCloseTo(1, 0.5)</code><br/>
    <code class="prettyprint">4 must be ~(5 +/- 2)</code><br/>
    <code class="prettyprint">4.994 must beCloseTo(5.0 within 2.significantFigures)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beBetween</code> check if a value is between 2 others<br/>
    <code class="prettyprint">5 must beBetween(3, 6)</code><br/>
    <code class="prettyprint">5 must beBetween(3, 6).excludingEnd</code><br/>
    <code class="prettyprint">5 must beBetween(4, 6).excludingStart</code><br/>
    <code class="prettyprint">5 must beBetween(4, 6).excludingBounds</code><br/>
    .</p>
  </li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Option/Either"><form>
    <table><tr><td class="none" style="info"><p>There are several matchers to check <code class="prettyprint">Option</code> and <code class="prettyprint">Either</code> instances:</p>
<ul>
  <li><code class="prettyprint">beSome</code> checks if an element is <code class="prettyprint">Some(_)</code></li>
  <li><code class="prettyprint">beSome(exp)</code> checks if an element is <code class="prettyprint">Some(exp)</code></li>
  <li><code class="prettyprint">beSome(matcher)</code> checks if an element is <code class="prettyprint">Some(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beSome(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Some(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Some</code> you need to use a matcher: <code class="prettyprint">beSome(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beSome.which(function)</code> checks if an element is <code class="prettyprint">Some(_</code>) and satisfies a function returning a boolean</li>
  <li><code class="prettyprint">beSome.like(partial function)</code> checks if an element is <code class="prettyprint">Some(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
  <li><code class="prettyprint">beNone</code> checks if an element is <code class="prettyprint">None</code></li>
  <li><code class="prettyprint">beAsNoneAs</code> checks if 2 values are equal to <code class="prettyprint">None</code> at the same time</li>
  <li>
    <p><code class="prettyprint">beRight</code> checks if an element is <code class="prettyprint">Right(_)</code></p>
  </li>
  <li><code class="prettyprint">beRight(exp)</code> checks if an element is `Right(exp)</li>
  <li><code class="prettyprint">beRight(matcher)</code> checks if an element is <code class="prettyprint">Right(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beRight(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Right(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Right</code> you need to use a matcher: <code class="prettyprint">beRight(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beRight.like(partial function)</code> checks if an element is <code class="prettyprint">Right(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
  <li>
    <p><code class="prettyprint">beLeft</code> checks if an element is <code class="prettyprint">Left(_)</code></p>
  </li>
  <li><code class="prettyprint">beLeft(exp)</code> checks if an element is <code class="prettyprint">Left(exp)</code></li>
  <li><code class="prettyprint">beLeft(matcher)</code> checks if an element is <code class="prettyprint">Left(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beLeft(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Left(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Left</code> you need to use a matcher: <code class="prettyprint">beLeft(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beLeft.like(partial function)</code> checks if an element is <code class="prettyprint">Left(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Try"><form>
    <table><tr><td class="none" style="info"><p>There are several matchers to check <code class="prettyprint">Try</code> instances:</p>
<ul>
  <li><code class="prettyprint">beSuccessfulTry</code> checks if an element is <code class="prettyprint">Success(_)</code></li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(exp)</code> checks if an element is <code class="prettyprint">Success(exp)</code></li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(matcher)</code> checks if an element is <code class="prettyprint">Success(a)</code> where <code class="prettyprint">a</code> satisfies the matcher</li>
  <li><code class="prettyprint">beSuccessfulTry.withValue(function: A =&gt; AsResult[B])</code> checks if an element is <code class="prettyprint">Success(a)</code> where <code class="prettyprint">function(a)</code> returns a successful <code class="prettyprint">Result</code><br/>
    (note that a <code class="prettyprint">Seq[A]</code> is also a function <code class="prettyprint">Int =&gt; A</code> so if you want to check that a sequence is contained in <code class="prettyprint">Success</code> you need to use a matcher: <code class="prettyprint">beSuccessfulTry.withValue(===(Seq(1))</code>)</li>
  <li><code class="prettyprint">beSuccessfulTry.which(function)</code> checks if an element is <code class="prettyprint">Success(_)</code> and satisfies a function returning a boolean</li>
  <li><code class="prettyprint">beSuccessfulTry.like(partial function)</code> checks if an element is <code class="prettyprint">Success(_)</code> and satisfies a partial function returning a <code class="prettyprint">Result</code></li>
  <li><code class="prettyprint">beFailedTry</code> checks if an element is <code class="prettyprint">Failure(_)</code></li>
  <li><code class="prettyprint">beFailedTry.withThrowable[T]</code> checks if an element is <code class="prettyprint">Failure(t: T)</code></li>
  <li><code class="prettyprint">beFailedTry.withThrowable[T](pattern)</code> checks if an element is <code class="prettyprint">Failure(t: T)</code> and <code class="prettyprint">t.getMessage</code> matches <code class="prettyprint">pattern</code></li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Future"><form>
    <table><tr><td class="none" style="info"><p>Testing <code class="prettyprint">Futures</code> is quite easy with specs2. You can simply return a value that is <code class="prettyprint">Future[R]</code> where <code class="prettyprint">R</code> has an <code class="prettyprint">AsResult</code><br/>
instance (meaning that <code class="prettyprint">R</code> is some kind of result like: <code class="prettyprint">Boolean</code>, <code class="prettyprint">Result</code>,...).<br/>
Then your future will be executed when specs2 executes your example and the result will be collected.</p>
<p>However you will not get the possibility to specify retries or timeouts. For retries and timeouts<br/>
you can use the <code class="prettyprint">await</code> method on matchers:</p>
<pre><code>Future(1) must be_&gt;(0).await
</code></pre>
<p>You can specify a timeout value and a number of retries</p>
<pre><code>Future { Thread.sleep(100); 1 } must be_&gt;(0).await(retries = 2, timeout = 100.millis)

// only retries, timeout is 1.second
Future { Thread.sleep(100); 1 } must be_&gt;(0).retryAwait(retries = 2)

// only timeout, retries = 0
Future { Thread.sleep(100); 1 } must be_&gt;(0).awaitFor(100.millis)
</code></pre>
<p>Another possibility is for you to obtain a <code class="prettyprint">Future[Result]</code> (or any <code class="prettyprint">Future[R]</code> where <code class="prettyprint">R</code> has an <code class="prettyprint">AsResult</code> typeclass instance).<br/>
In that case you can use <code class="prettyprint">await</code> directly on the <code class="prettyprint">Future</code> to get a <code class="prettyprint">Result</code></p>
<pre><code>Future(1 === 1).await
Future(1 === 1).await(retries = 2, timeout = 100.millis)
</code></pre>
<h4><a href="#execution" id="execution">Execution</a></h4>
<p>The <code class="prettyprint">await</code> method require an implicit <code class="prettyprint">org.specs2.concurrent.ExecutionEnv</code> (see <a href="org.specs2.guide.ExecutionEnvironments.html">here</a> for more details). You can pass one in the body of your examples:</p>
<pre><code>class MyFutureSpec(using ee: ExecutionEnv) extends Specification:
  def is = s2&quot;&quot;&quot;

  Let's check this scala future ${Future(1) must be_&gt;(0).await}

  &quot;&quot;&quot;

// in a mutable specification
class MyMutableFutureSpec(using ee: ExecutionEnv) extends mutable.Specification:
  &quot;Let's check this scala future&quot; &gt;&gt; {
    Future(1) must be_&gt;(0).await
  }
</code></pre>
<h4><a href="#time-factor" id="time-factor">Time factor</a></h4>
<p>Some actions can be a lot slower when executed on a continuous integration server rather than a developer machine and some timeouts will fail.<br/>
You can avoid this by setting the <code class="prettyprint">timeFactor</code> argument which will multiply the durations used when <code class="prettyprint">awaiting / attempting</code> by a constant factor.</p>
<pre><code>sbt&gt; testOnly *MyFuturesSpec* -- timeFactor 3
</code></pre>
<ul>
  <li>use the <a href="org.specs2.guide.ExecutionEnvironment.html">execution environment</a></li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Exception"><form>
    <table><tr><td class="none" style="info"><p>specs2 offers very compact ways of checking that some exceptions are thrown:</p>
<h3><a href="#for-expressions-throwing-an-exception" id="for-expressions-throwing-an-exception">for expressions throwing an exception</a></h3>
<ul>
  <li><code class="prettyprint">throwA[ExceptionType]</code> checks if a block of code throws an exception of the given type</li>
  <li><code class="prettyprint">throwA[ExceptionType](message = &quot;boom&quot;)</code> additionally checks if the exception message is as expected (<code class="prettyprint">message</code> is<br/>
    being interpreted as a regular expression)</li>
  <li><code class="prettyprint">throwA(exception)</code> or <code class="prettyprint">throwAn(exception)</code> checks if a block of code throws an exception of the same type, with the<br/>
    same message</li>
  <li><code class="prettyprint">throwA[ExceptionType].like { case e =&gt; e must matchSomething }</code> or<br/>
    <code class="prettyprint">throwA(exception).like { case e =&gt; e must matchSomething }</code> checks that the thrown exception satisfies a property</li>
</ul>
<h3><a href="#for-expressions-that-shouldnt-throw-an-exception" id="for-expressions-that-shouldnt-throw-an-exception">for expressions that shouldn't throw an exception</a></h3>
<ul>
  <li><code class="prettyprint">not(throwAn[Exception])</code> checks that an expression doesn't throw any exceptions</li>
  <li><code class="prettyprint">not(throwAn[Exception].like { case e =&gt; e.message must startWith(&quot;FAIL&quot;) })</code> checks that an expression doesn't an exception with the specified message (another message is allowed)</li>
  <li><code class="prettyprint">not(throwAn[IllegalArgumentException])</code> checks that an expression doesn't throw any <code class="prettyprint">IllegalArgumentException</code> (but exceptions of other types are permitted)</li>
</ul>
<h3><a href="#for-exception-values" id="for-exception-values">for exception values</a></h3>
<ul>
  <li><code class="prettyprint">beException[ExceptionType](&quot;message&quot;)</code> checks that a <code class="prettyprint">Throwable</code> has an expected type and that its message satisfies<br/>
    a regular expression</li>
</ul>
<hr/>
<p>For all the above matchers you can use <code class="prettyprint">throwAn</code> instead of <code class="prettyprint">throwA</code> if the exception name starts with a vowel for better<br/>
readability.</p>
</td></tr></table></form></div><div class="tabbertab" title="Map"><form>
    <table><tr><td class="none" style="info"><p>Maps have their own matchers as well, to check keys and values:</p>
<ul>
  <li>
    <p><code class="prettyprint">haveKey</code> checks if a Map has a given key<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must haveKey(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">haveKeys</code> checks if a Map has several keys<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;, 2 -&gt; &quot;2&quot;) must haveKeys(1, 2)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">haveValue</code> checks if a Map has a given value<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must haveValue(&quot;1&quot;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">haveValues</code> checks if a Map has several values<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;, 2 -&gt; &quot;2&quot;) must haveValues(&quot;1&quot;, &quot;2&quot;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">havePair</code> checks if a Map has a given pair of values<br/>
    <code class="prettyprint">Map(1 -&gt; &quot;1&quot;) must havePair(1 -&gt; &quot;1&quot;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">havePairs</code> checks if a Map has some pairs of values<br/>
    <code class="prettyprint">Map(1-&gt;&quot;1&quot;, 2-&gt;&quot;2&quot;, 3-&gt;&quot;3&quot;) must havePairs(1-&gt;&quot;1&quot;, 2-&gt;&quot;2&quot;)</code></p>
  </li>
</ul>
<p>But Maps are also PartialFunctions, so:</p>
<ul>
  <li>
    <p><code class="prettyprint">beDefinedAt</code> checks if a PartialFunction is defined for a given value<br/>
    <code class="prettyprint">partial must beDefinedAt(1)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beDefinedBy</code> checks if a PartialFunction is defined for a given value<br/>
    and returns another one<br/>
    <code class="prettyprint">partial must beDefinedBy(1 -&gt; true)</code></p>
  </li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Any"><form>
    <table><tr><td class="none" style="info"><p>These matchers can be used with any object, regardless of its type:</p>
<ul>
  <li><code class="prettyprint">beLike { case exp =&gt; result }</code> checks if an object is like a given pattern. <code class="prettyprint">result</code> can be any expression using a matcher</li>
  <li><code class="prettyprint">beLike { case exp =&gt; exp must beXXX }</code> checks if an object is like a given pattern, and verifies a condition</li>
  <li><code class="prettyprint">beNull</code> checks if an object is null</li>
  <li><code class="prettyprint">beAsNullAs</code> when 2 objects must be null at the same time if one of them is null</li>
  <li><code class="prettyprint">beOneOf(a, b, c)</code> checks if an object is one of a given list</li>
  <li><code class="prettyprint">haveClass</code> checks the class of an object</li>
  <li><code class="prettyprint">haveSuperclass</code> checks if the class of an object as another class as one of its ancestors</li>
  <li><code class="prettyprint">haveInterface</code> checks if an object is implementing a given interface</li>
  <li><code class="prettyprint">beAssignableFrom</code> checks if a class is assignable from another</li>
  <li><code class="prettyprint">beAnInstanceOf[T]</code> checks if an object is an instance of type <code class="prettyprint">T</code></li>
</ul>
<h4><a href="#with-a-typeclass" id="with-a-typeclass">With a typeclass</a></h4>
<p>These matchers can be used with types having a specific typeclass instance:</p>
<table>
  <thead>
    <tr><th>Matcher    </th><th> Typeclass                       </th><th> Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code class="prettyprint">beEmpty</code>  </td><td> <code class="prettyprint">org.specs2.collection.IsEmpty</code> </td><td> matches values which can be described as &quot;empty&quot;: string, list, option,...</td></tr>
    <tr><td><code class="prettyprint">haveSize</code> </td><td> <code class="prettyprint">org.specs2.collection.Sized</code>   </td><td> matches values which can have a &quot;size&quot;: string, list, JSON,...</td></tr>
  </tbody>
</table>
</td></tr></table></form></div></div></td></tr></table></form></td>

### Optional

Those matchers are optional. To use them, you need to add a new trait to your specification.

Those are additional "data" matchers:

<td class="info"><form>
    <table><tr><th colspan="101">Optional data matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="Result"><form>
    <table><tr><td class="none" style="info"><p>That's only if you want to check the result of other matchers!</p>
<pre><code>// you need to extend the ResultMatchers trait
class MatchersSpec extends Specification with matcher.ResultMatchers:
  def is =
    &quot;beMatching is using a regexp&quot; ! {
      (&quot;Hello&quot; must beMatching(&quot;h.*&quot;)) must beSuccessful
    }
</code></pre>
</td></tr></table></form></div><div class="tabbertab" title="Termination"><form>
    <table><tr><td class="none" style="info"><p>Sometimes you just want to specify that a block of code is going to terminate.<br/>
The <code class="prettyprint">org.specs2.matcher.TerminationMatchers</code> trait is here to help. If you mix in that trait, you can write:</p>
<pre><code>Thread.sleep(100) must terminate

// the default is retries = 0, sleep = 100.millis
Thread.sleep(100) must terminate(retries = 1, sleep = 60.millis)
</code></pre>
<p>Note that the behaviour of this matcher is a bit different from the <code class="prettyprint">eventually</code> operator. In this case, we let the current Thread sleep during the given <code class="prettyprint">sleep</code> time and then we check if the computation is finished, then, we retry for the given number of <code class="prettyprint">retries</code>.</p>
<p>In a further scenario, we might want to check that triggering another action is able to unblock the first one:</p>
<pre><code>action must terminate.when(action2)
action must terminate.when(&quot;starting the second action&quot;, action2)
action must terminate(retries = 3, sleep = 100.millis).when(action2)
</code></pre>
<p>When a second action is specified like that, <code class="prettyprint">Action</code> will be started and <code class="prettyprint">action2</code> will be started on the first retry. Otherwise, if you want to specify that <code class="prettyprint">Action</code> can <em>only</em> terminate when <code class="prettyprint">action2</code> is started, you write:</p>
<pre><code>action must terminate.onlyWhen(action2)
</code></pre>
<h4><a href="#executionenv" id="executionenv">ExecutionEnv</a></h4>
<p>The <code class="prettyprint">terminate</code> matcher needs an implicit <code class="prettyprint">ExecutionEnv</code> to be used. See the  page to learn how to get one.</p>
</td></tr></table></form></div></div></td></tr></table></form></td>

Those matchers can be used to check "content":

<td class="info"><form>
    <table><tr><th colspan="101">Optional content matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="Xml"><form>
    <table><tr><td class="none" style="info"><p>It is very useful to have literal Xml in Scala, it is even more useful to have matchers for it! If you want to use those matchers you need to extend the <code class="prettyprint">org.specs2.matcher.XmlMatchers</code> trait:</p>
<ul>
  <li>
    <p><code class="prettyprint">beEqualToIgnoringSpace</code> compares 2 Nodes, without considering spaces<br/>
    <code class="prettyprint">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; must ==/(&lt;a&gt; &lt;b/&gt;&lt;/a&gt;)</code><br/>
    <code class="prettyprint">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; must beEqualToIgnoringSpace(&lt;a&gt; &lt;b/&gt;&lt;/a&gt;)</code></p>
  </li>
  <li>
    <p><code class="prettyprint">beEqualToIgnoringSpace</code> can also do an ordered comparison<br/>
    <code class="prettyprint">&lt;a&gt;&lt;c/&gt; &lt;b/&gt;&lt;/a&gt; must ==/(&lt;a&gt; &lt;c/&gt;&lt;b/&gt;&lt;/a&gt;).ordered</code></p>
  </li>
  <li>
    <p>on the other hand <code class="prettyprint">beEqualToIgnoringSpace</code> will not check attributes order<br/>
    <code class="prettyprint">&lt;n a=&quot;1&quot; b=&quot;2&quot;/&gt; must ==/(&lt;n b=&quot;2&quot; a=&quot;1&quot;/&gt;)</code></p>
  </li>
  <li>
    <p>the <code class="prettyprint">\\</code> matcher is an XPath-like matcher matching if a node is a direct child of another<br/>
    <code class="prettyprint">&lt;a&gt;&lt;b/&gt;&lt;/a&gt; must \\\\(&quot;b&quot;)</code></p>
  </li>
  <li>
    <p>You can also check attribute names<br/>
    <code class="prettyprint">&lt;a&gt;&lt;b name=&quot;value&quot;&gt;&lt;/b&gt;&lt;/a&gt; must \\(&quot;b&quot;, &quot;name&quot;)</code></p>
  </li>
  <li>
    <p>And attribute names and values as well (values are checked using a regular expression, use the quote method if you want an exact match)<br/>
    <code class="prettyprint">&lt;a&gt;&lt;b n=&quot;v&quot; n2=&quot;v2&quot; n3=&quot;v3&quot;&gt;&lt;/b&gt;&lt;/a&gt; must \\(&quot;b&quot;, &quot;n&quot;-&gt;&quot;v&quot;, &quot;n2&quot;-&gt;&quot;v\\d&quot;)</code></p>
  </li>
  <li>
    <p>Or the content of a <code class="prettyprint">Text</code> node<br/>
    <code class="prettyprint">&lt;a&gt;hello&lt;/a&gt; must \\(&quot;a&quot;) \\&gt; &quot;hello&quot;</code> (alias <code class="prettyprint">textIs</code>)<br/>
    <code class="prettyprint">&lt;a&gt;hello&lt;/a&gt; must \\(&quot;a&quot;) \\&gt;~ &quot;h.*&quot;</code>  (alias <code class="prettyprint">textMatches</code>)</p>
  </li>
  <li>
    <p>The equivalent of <code class="prettyprint">\\</code> for a &quot;deep&quot; match is simply <code class="prettyprint">\\\\</code><br/>
    <code class="prettyprint">&lt;a&gt;&lt;s&gt;&lt;c&gt;&lt;/c&gt;&lt;/s&gt;&lt;/a&gt; must \\\\(&quot;c&quot;)</code></p>
  </li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Json"><form>
    <table><tr><td class="none" style="info"><p><a href="http://www.json.org">Json</a> is a simple data format essentially modeling recursive key-values.<br/>
You can use the following matchers provided by the <code class="prettyprint">org.specs2.matcher.JsonMatchers</code> trait to check JSON strings:</p>
<ul>
  <li>
    <p><code class="prettyprint">/(value)</code> checks if a value is present at the root of the document. This can only be the case if that document is an Array</p>
  </li>
  <li>
    <p><code class="prettyprint">/(regex)</code> checks if a value matching the regex is present at the root of the document. This can only be the case if that document is an Array</p>
  </li>
  <li>
    <p><code class="prettyprint">/(key -&gt; value)</code> checks if a pair is present at the root of the document. This can only be the case if that document is a Map</p>
  </li>
  <li>
    <p><code class="prettyprint">*/(value)</code> checks if a value is present anywhere in the document, either as an entry in an Array, or as the value for a key in a Map</p>
  </li>
  <li>
    <p><code class="prettyprint">*/(key -&gt; value)</code> checks if a pair is present anywhere in a Map of the document</p>
  </li>
  <li>
    <p><code class="prettyprint">/#(i)</code> selects the ith element in a 0-based indexed Array or a Map and allow further checks on that element</p>
  </li>
</ul>
<p>Now the interesting part comes from the fact that those matchers can be chained to search specific paths in the Json document. For example, for the following document:</p>
<pre><code>// taken from an example in the Lift project
    val person = &quot;&quot;&quot;{
  &quot;person&quot;: {
    &quot;name&quot;: &quot;Joe&quot;,
    &quot;age&quot;: 35,
    &quot;spouse&quot;: {
      &quot;person&quot;: {
        &quot;name&quot;: &quot;Marilyn&quot;,
        &quot;age&quot;: 33
      }
    }
  }
}
&quot;&quot;&quot;
</code></pre>
<p>You can use these combinations:</p>
<pre><code>person must /(&quot;person&quot;) */ (&quot;person&quot;) / (&quot;age&quot; -&gt; 33.0) // by default numbers are parsed as Doubles
</code></pre>
<p>You can as well use regular expressions or String matchers instead of values to verify the presence of keys or elements. For example:</p>
<pre><code>person must /(&quot;p.*&quot;.r) */ &quot;.*on&quot;.r / (&quot;age&quot; -&gt; &quot;\\d+\\.\\d&quot;.r)
person must /(&quot;p.*&quot;.r) */ &quot;.*on&quot;.r / (&quot;age&quot; -&gt; startWith(&quot;3&quot;))
person must /(&quot;p.*&quot;.r) */ &quot;.*on&quot;.r / (&quot;age&quot; -&gt; (be_&gt;(30) ^^ ((_: String).toInt)))
</code></pre>
<p>You can also access some records by their index:</p>
<pre><code>person must /(&quot;person&quot;) /# 2 / &quot;person&quot;
</code></pre>
<p>Finally you can use Json matchers to match elements in an array:</p>
<pre><code>val json = &quot;&quot;&quot;{&quot;products&quot;:[{&quot;name&quot;:&quot;shirt&quot;,&quot;price&quot;:10, &quot;ids&quot;:[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]},{&quot;name&quot;:&quot;shoe&quot;,&quot;price&quot;:5}]}&quot;&quot;&quot;

def aProductWith(name: Matcher[JsonType], price: Matcher[JsonType]): Matcher[String] =
  /(&quot;name&quot;).andHave(name) and /(&quot;price&quot;).andHave(price)

def haveProducts(products: Matcher[String]*): Matcher[String] =
  /(&quot;products&quot;).andHave(allOf(products*))

json must haveProducts(
  aProductWith(name = &quot;shirt&quot;, price = 10) and /(&quot;ids&quot;).andHave(exactly(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)),
  aProductWith(name = &quot;shoe&quot;, price = 5)
)
</code></pre>
<p>The <code class="prettyprint">andHave</code> method accepts any <code class="prettyprint">Matcher[JsonType]</code> where <code class="prettyprint">JsonType</code> is either <code class="prettyprint">JsonArray</code>, <code class="prettyprint">JsonMap</code>, <code class="prettyprint">JsonNumber</code>, <code class="prettyprint">JsonString</code>, <code class="prettyprint">JsonNull</code>. In the example above we pass directly <code class="prettyprint">shirt</code> and <code class="prettyprint">10</code> as <code class="prettyprint">Matcher[JsonType]</code> because there are implicit conversions from <code class="prettyprint">Int</code>, <code class="prettyprint">Boolean</code>, <code class="prettyprint">Double</code>, <code class="prettyprint">String</code> and <code class="prettyprint">Traversable[String]</code> matchers (like <code class="prettyprint">allOf</code>) to a <code class="prettyprint">Matcher[JsonType]</code>.</p>
</td></tr></table></form></div><div class="tabbertab" title="File"><form>
    <table><tr><td class="none" style="info"><p>The Java api for files is more or less mimicked as matchers which can operate on strings denoting paths or on Files (with the <code class="prettyprint">org.specs2.matcher.FileMatchers</code> trait)</p>
<ul>
  <li><code class="prettyprint">beEqualToIgnoringSep</code> checks if 2 paths are the same regardless of their separators<br/>
    <code class="prettyprint">&quot;c:\temp\hello&quot; must beEqualToIgnoringSep(&quot;c:/temp/hello&quot;)</code></li>
  <li><code class="prettyprint">beAnExistingPath</code> checks if a path exists</li>
  <li><code class="prettyprint">beAReadablePath</code> checks if a path is readable</li>
  <li><code class="prettyprint">beAWritablePath</code> checks if a path is writable</li>
  <li><code class="prettyprint">beAnAbsolutePath</code> checks if a path is absolute</li>
  <li><code class="prettyprint">beAHiddenPath</code> checks if a path is hidden</li>
  <li><code class="prettyprint">beAFilePath</code> checks if a path is a file</li>
  <li><code class="prettyprint">beADirectoryPath</code> checks if a path is a directory</li>
  <li><code class="prettyprint">havePathName</code> checks if a path has a given name</li>
  <li><code class="prettyprint">haveAsAbsolutePath</code> checks if a path has a given absolute path</li>
  <li><code class="prettyprint">haveAsCanonicalPath</code> checks if a path has a given canonical path</li>
  <li><code class="prettyprint">haveParentPath</code> checks if a path has a given parent path</li>
  <li><code class="prettyprint">listPaths</code> checks if a path has a given list of children</li>
  <li><code class="prettyprint">exist</code> checks if a file exists</li>
  <li>
    <p><code class="prettyprint">beReadable</code> checks if a file is readable</p>
  </li>
  <li><code class="prettyprint">beWritable</code> checks if a file is writable</li>
  <li><code class="prettyprint">beAbsolute</code> checks if a file is absolute</li>
  <li><code class="prettyprint">beHidden</code> checks if a file is hidden</li>
  <li><code class="prettyprint">beAFile</code> checks if a file is a file</li>
  <li><code class="prettyprint">beADirectory</code> checks if a file is a directory</li>
  <li><code class="prettyprint">haveName</code> checks if a file has a given name</li>
  <li><code class="prettyprint">haveAbsolutePath</code> checks if a file has a given absolute path</li>
  <li><code class="prettyprint">haveCanonicalPath</code> checks if afile has a given canonical path</li>
  <li><code class="prettyprint">haveParent</code> checks if a file has a given parent path</li>
  <li><code class="prettyprint">haveList</code> checks if a file has a given list of children</li>
</ul>
</td></tr></table></form></div><div class="tabbertab" title="Content"><form>
    <table><tr><td class="none" style="info"><h5><a href="#file-contents" id="file-contents">File contents</a></h5>
<p>The matchers from the <code class="prettyprint">org.specs2.matcher.ContentMatchers</code> trait can help us check the contents of files. For example we can check that 2 text files have the same lines:</p>
<pre><code>(file1, file2) must haveSameLines
  file1 must haveSameLinesAs(file2)
</code></pre>
<p>We can check that the content of one file is contained in another one:</p>
<pre><code>file1 must containLines(file2)
</code></pre>
<p>If the files are binary files we can also check that they have the same MD5 hash:</p>
<pre><code>(file1, file2) must haveSameMD5
  file1 must haveSameMD5As(file2)
</code></pre>
<p><strong><em>Order</em></strong></p>
<p>It is possible to relax the constraint by requiring the equality or containment to be true regardless of the order of lines:</p>
<pre><code>(file1, file2) must haveSameLines.unordered
  file1 must haveSameLinesAs(file2).unordered
  file1 must containLines(file2).unordered
</code></pre>
<p><strong><em>Show differences</em></strong></p>
<p>By default only the different lines are being shown with a bit of context (lines before and after the differences).<br/>
You can however change this strategy. For example if there are too many differences, you can specify that you only want the first 10:</p>
<pre><code>(file1, file2) must haveSameLines.showOnly(10.differences)
</code></pre>
<p>In the code above <code class="prettyprint">10.differences</code> builds a <code class="prettyprint">DifferenceFilter</code> which is merely a filtering function: <code class="prettyprint">(lines: Seq[LineComparison]) =&gt; Seq[LineComparison])</code><br/>
keeping the first 10 differences. A <code class="prettyprint">LineComparison</code> is the result of comparing a list of lines, either a line has been added, deleted, modified or is the same.</p>
<h5><a href="#directories-contents" id="directories-contents">Directories contents</a></h5>
<p>We can compare the contents of 2 directories. We can for example check if no files are missing and none has been added:</p>
<pre><code>actualDir must haveSamePathsAs(expectedDir)
  // with a file filter applied to both the actual and expected directories
  actualDir must haveSamePathsAs(expectedDir).withFilter((file: File) =&gt; !file.isHidden)
</code></pre>
<p>Once we know that all files are present we can check their content:</p>
<pre><code>// the default comparison expects that files are text files and that comparison must be done line by line
actualDir must haveSameFilesAs(expectedDir)

// with a file filter applied to both the actual and expected directories
actualDir must haveSameFilesAs(expectedDir).withFilter((file: File) =&gt; !file.isHidden)

// with a MD5 matcher for binary files
actualDir must haveSameFilesAs(expectedDir).withMatcher(haveSameMD5)

// it is also possible to only check the content of actual files when they exist in the expected directory
actualDir must haveSameFilesContentAs(expectedDir)
</code></pre>
<h5><a href="#lines-contents" id="lines-contents">Lines contents</a></h5>
<p>Files are not the only possible source of lines and it is useful to be able to check the content of a <code class="prettyprint">File</code> with a <code class="prettyprint">Seq[String]</code>:</p>
<pre><code>file1 must haveSameLinesAs(Seq(line1, line2, line3))
</code></pre>
<p>This is because those 2 types implement the <code class="prettyprint">org.specs2.text.LinesContent</code> trait, defining:</p>
<ul>
  <li>a name for the overall content</li>
  <li>a method for returning the lines</li>
  <li>a default method for computing the differences of 2 sequences of lines (in case you need to override this logic)</li>
</ul>
<p>So if you have a specific type <code class="prettyprint">T</code> which you can represent as a <code class="prettyprint">Seq[String]</code>, you can create an implicit <code class="prettyprint">LinesContent</code><br/>
and then you'll be able to use the <code class="prettyprint">ContentMatchers</code>:</p>
<pre><code>given [T]: LinesContent[T] with
  def name(t: T) = &quot;My list of lines&quot;
  def lines(t: T): Seq[String] = Seq()// your implementation goes here
</code></pre>
</td></tr></table></form></div></div></td></tr></table></form></td>

And finally those matchers are Scala / Language related

<td class="info"><form>
    <table><tr><th colspan="101">Optional language matchers</th></tr><tr><td colspan="100" class="info"><div class="tabber"><div class="tabbertab" title="Typecheck"><form>
    <table><tr><td class="none" style="info"><h3><a href="#typecheck-matchers" id="typecheck-matchers">Typecheck matchers</a></h3>
<p>Some behaviours can be encoded with the type system and you just want to check that a given expression will typecheck:</p>
<pre><code>import org.specs2.execute.*, Typecheck.*
import org.specs2.matcher.TypecheckMatchers.*

typecheck {
  &quot;&quot;&quot;
  // there must be a Monoid instance for Text
  Monoid[Text].zero
  &quot;&quot;&quot;
} must succeed
</code></pre>
<p>You might also want to check that another expression will fail to typecheck:</p>
<pre><code>typecheck {
  &quot;&quot;&quot;
  // there must be not a Monoid instance for Plane
  Monoid[Plane].zero
  &quot;&quot;&quot;
} must not(succeed)

typecheck {
  &quot;&quot;&quot;
  // there must be not a Monoid instance for Plane
  Monoid[Plane].zero
  &quot;&quot;&quot;
} must failWith(&quot;no implicit argument of type org.specs2.fp.Monoid\\[org.specs2.guide.matchers.Plane\\] was found&quot;)
</code></pre>
<h4><a href="#typecheckresult" id="typecheckresult">TypecheckResult</a></h4>
<p>Note that you actually don't have to use the <code class="prettyprint">succeed</code> matcher because <code class="prettyprint">typecheck</code> returns a <code class="prettyprint">TypecheckResult</code> object which has an <code class="prettyprint">AsResult</code> instance:</p>
<pre><code>&quot;this should typecheck ok&quot; ! typecheck {
  &quot;&quot;&quot;
  // there must be not a Monoid instance for Plane
  Monoid[Plane].zero
  &quot;&quot;&quot;
}
</code></pre>
<p>This is also why you can indicate that a block of code must be marked as <code class="prettyprint">Pending</code> until it typechecks:</p>
<pre><code>typecheck {
  &quot;&quot;&quot;
  // there must be not a Monoid instance for Plane
  Monoid[Plane].zero
  &quot;&quot;&quot;
  }.pendingUntilFixed(&quot;find a way to make this typecheck!&quot;)
</code></pre>
</td></tr></table></form></div><div class="tabbertab" title="Scala Interpreter"><form>
    <table><tr><td class="none" style="info"><p>In the rare case where you want to use the Scala interpreter and execute a script:</p>
<pre><code>class ScalaInterpreterMatchersSpec extends org.specs2.mutable.Spec with ScalaInterpreterMatchers {
  def interpret(s: String): String = &quot;&quot; // you have to provide your own Scala interpreter here
  &quot;A script can be interpreted&quot; &gt;&gt; {
    &quot;1 + 1&quot; &gt;| &quot;2&quot;
  }
}
</code></pre>
</td></tr></table></form></div></div></td></tr></table></form></td>


### Derive matchers

The easiest way to create a new matcher is to derive it from an existing one. You can:

 * use logical operators 

```
def beBetween(i: Int, j: Int) = be_>=(i) and be_<=(j)
```


 * "adapt" the actual value 

```
// This matcher adapts the existing `be_<=` matcher to a matcher applicable to `Any`
def beShort1 = be_<=(5) ^^ { (t: Any) => t.toString.length }

// you can use aka to provide some information about the original value, before adaptation
def beShort2 = be_<=(5) ^^ { (t: Any) => t.toString.length aka "the string size" }

// The adaptation can also be done the other way around when it's more readable
def haveExtension(extension: =>String) = ((_: File).getPath) ^^ endWith(extension)
```


 * adapt the actual and expected values. This matcher compares 2 `Human` objects but set their `wealth` field to 0
   so that the equals method will not fail on that field: 

```
def beMostlyEqualTo(h: Human) = be_==(h) ^^^ ((_: Human).copy(wealth = 0))
// then
Human(age = 20, wealth = 1000) must beMostlyEqualTo(Human(age = 20, wealth = 1)) // success
```


 * use `eventually` to try a matcher a number of times until it succeeds: 

```
val iterator = List(1, 2, 3).iterator

// Use eventually(retries, n.millis) to specify the number of tries and waiting time
iterator.next must be_==(3).eventually
```


 * use `await` to create a matcher that will match on `Matcher[Future[T]]` (this requires an <link class="ok">  <a href="org.specs2.guide.ExecutionEnvironments.html" tooltip="" class="ok">execution environment</a></link>): 

```
Future(1) must be_>(0).await
Future { Thread.sleep(100); 1 } must be_>(0).await(retries = 2, timeout = 100.millis)
```


 * use `when` or `unless` to apply a matcher only if a condition is satisfied: 

```
1 must be_==(2).when(false) // will return a success
1 must be_==(2).unless(true) // same thing

1 must be_==(2).when(false, "don't check this") // will return a success
1 must be_==(2).unless(true, "don't check this") // same thing
```


 * use `iff` to say that a matcher must succeed if and only if a condition is satisfied: 

```
1 must be_==(1).iff(true) // will return a success
1 must be_==(2).iff(true) // will return a failure
1 must be_==(2).iff(false) // will return a success
1 must be_==(1).iff(false) // will return a failure
```


 * use `orSkip` to return a `Skipped` result instead of a Failure if the condition is not satisfied 

```
1 must be_==(2).orSkip
1 must be_==(2).orSkip("Precondition failed") // prints "Precondition failed: '1' is not equal to '2'"
1 must be_==(2).orSkip((ko: String) => "BAD " + ko) // prints "BAD '1' is not equal to '2'"
```


 * use `orPending` to return a `Pending` result instead of a Failure if the condition is not satisfied 

```
1 must be_==(2).orPending
1 must be_==(2).orPending("Precondition failed") // prints "Precondition failed: '1' is not equal to '2'"
1 must be_==(2).orPending((ko: String) => "BAD " + ko) // prints "BAD '1' is not equal to '2'"
```


### Create your own

The easiest way to create a new matcher is to create it from a function returning a tuple with a boolean and one or more messages: 

```
// import the necessary implicit conversions if you are outside of a Specification
// import org.specs2.matcher.Matcher.{given}

// annotate the return type so that implicit conversions can transform your function into a Matcher object
// here just return a boolean and a failure message
def startWithHello: Matcher[String] = { (s: String) =>
  (s.startsWith("hello"), s + " doesn't start with hello")
}
```


If you want absolute power over matching, you can define your own matcher extending `Matcher`: 

```
import org.specs2.execute.Result.*

case class BeMyOwnEmpty() extends Matcher[String] {
  def apply[S <: String](s: Expectable[S]) = {
    result(s.value.isEmpty, s.description + " is not empty")
  }
}

"" must BeMyOwnEmpty()
```


In the code above you have to:

 * define the `apply` method (and its somewhat complex signature)

 * use the protected `result` method to return a `Boolean` condition and a failure message

 * you can use the `description` method on the `Expectable` class to return the full description of the expectable including
   the optional description you setup using the `aka` method


<h3 id="Now learn how to..." class="ribbon both-ribbon">Now learn how to...</h3>

<div class="ribbon-content">
    

 - use <link class="ok">  <a href="org.specs2.guide.StandardResults.html" tooltip="" class="ok">standard results</a></link> (`failure`, `success`, `skipped`, `todo`...) instead of matchers
 - add <link class="ok">  <a href="org.specs2.guide.ExpectationDescription.html" tooltip="" class="ok">descriptions</a></link> to your expectations to create even better failure messages
 - use <link class="ok">  <a href="org.specs2.guide.UseDatatables.html" tooltip="" class="ok">datatables</a></link> to conveniently group several examples into one
 - use <link class="ok">  <a href="org.specs2.guide.UseScalaCheck.html" tooltip="" class="ok">ScalaCheck</a></link> to generate and verify data for your examples
 - use <link class="ok">  <a href="org.specs2.guide.UseForms.html" tooltip="" class="ok">Forms</a></link> to display actual and expected values in html tables

</div>


<h3 id="And if you want to know more" class="ribbon both-ribbon">And if you want to know more</h3>

<div class="ribbon-content">
    

 - read the <link class="ok">  <a href="org.specs2.guide.matchers.ReferenceCard.html" tooltip="" class="ok">reference card</a></link> on all of <s2>specs2</s2> matchers
 - implement the <link class="ok">  <a href="org.specs2.guide.AsResultTypeclass.html" tooltip="" class="ok">`AsResult` typeclass</a></link> to go beyond matchers
 - use <s2>specs2</s2> matchers <link class="ok">  <a href="org.specs2.guide.matchers.OutsideSpecs2.html" tooltip="" class="ok">outside &lt;s2&gt;specs2&lt;/s2&gt;</a></link>

</div>